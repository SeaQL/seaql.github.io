"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[90967],{48859:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>p});var a=n(76687);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=d(n),p=r,y=u["".concat(s,".").concat(p)]||u[p]||c[p]||i;return n?a.createElement(y,l(l({ref:t},m),{},{components:n})):a.createElement(y,l({ref:t},m))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},63433:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(31308),r=(n(76687),n(48859));const i={},l="Multi Selects",o={unversionedId:"relation/multi-selects",id:"relation/multi-selects",title:"Multi Selects",description:"Nested Models",source:"@site/docs/06-relation/09-multi-selects.md",sourceDirName:"06-relation",slug:"/relation/multi-selects",permalink:"/SeaORM/docs/next/relation/multi-selects",draft:!1,editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/09-multi-selects.md",tags:[],version:"current",lastUpdatedBy:"Chris Tsang",lastUpdatedAt:1741482608,formattedLastUpdatedAt:"Mar 9, 2025",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bakery Schema",permalink:"/SeaORM/docs/next/relation/bakery-schema"},next:{title:"Robust & Correct",permalink:"/SeaORM/docs/next/write-test/testing"}},s={},d=[{value:"Nested Models",id:"nested-models",level:2},{value:"Join with alias",id:"join-with-alias",level:3},{value:"Three-way Join",id:"three-way-join",level:2},{value:"Three-Model select",id:"three-model-select",level:2}],m={toc:d};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"multi-selects"},"Multi Selects"),(0,r.kt)("h2",{id:"nested-models"},"Nested Models"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"FromQueryResult")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DerivePartialModel")," macros allows you to nest objects easily, simplifying the construction of complex queries."),(0,r.kt)("p",null,"As a simple first example, we'd like to select ",(0,r.kt)("inlineCode",{parentName:"p"},"Cake")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Bakery"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(FromQueryResult)]\nstruct Cake {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(FromQueryResult)]\nstruct Bakery {\n    #[sea_orm(from_alias = "bakery_id")]\n    id: i32,\n    #[sea_orm(from_alias = "bakery_name")]\n    brand: String,\n}\n\nlet cake: Cake = cake::Entity::find()\n    .select_only()\n    .column(cake::Column::Id)\n    .column(cake::Column::Name)\n    .column_as(bakery::Column::Id, "bakery_id")\n    .column_as(bakery::Column::Name, "bakery_name")\n    .left_join(bakery::Entity)\n    .order_by_asc(cake::Column::Id)\n    .into_model()\n    .one(db)\n    .await?\n    .unwrap();\n\nassert_eq!(\n    cake,\n    Cake {\n        id: 1,\n        name: "Basque cheesecake".to_string(),\n        bakery: Some(Bakery {\n            id: 20,\n            brand: "Super Baker".to_string(),\n        })\n    }\n);\n')),(0,r.kt)("p",null,"Because the tables ",(0,r.kt)("inlineCode",{parentName:"p"},"cake")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bakery")," have some duplicate column names, we'd have to do custom selects. ",(0,r.kt)("inlineCode",{parentName:"p"},"select_only")," here clears the default select list, and we apply aliases with ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.column_as"},(0,r.kt)("inlineCode",{parentName:"a"},"column_as")),". Then, in ",(0,r.kt)("inlineCode",{parentName:"p"},"FromQueryResult")," we use ",(0,r.kt)("inlineCode",{parentName:"p"},"from_alias")," to map the query result back to the nested struct."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/derive.DerivePartialModel.html"},(0,r.kt)("inlineCode",{parentName:"a"},"DerivePartialModel"))," allows you to omit the custom selects and aliases.\nThe previous example can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(DerivePartialModel)] // FromQueryResult is no longer needed\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "bakery::Entity", from_query_result)]\nstruct Bakery {\n    id: i32,\n    #[sea_orm(from_col = "Name")]\n    brand: String,\n}\n\n// same as previous example, but without the custom selects\nlet cake: Cake = cake::Entity::find()\n    .left_join(bakery::Entity)\n    .order_by_asc(cake::Column::Id)\n    .into_partial_model()\n    .one(db)\n    .await?\n    .unwrap();\n')),(0,r.kt)("p",null,"Under the hood, ",(0,r.kt)("inlineCode",{parentName:"p"},"bakery_")," prefix will be added to the column alias in the SQL query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    "cake"."id" AS "id",\n    "cake"."name" AS "name",\n    "bakery"."id" AS "bakery_id",\n    "bakery"."name" AS "bakery_brand"\nFROM "cake"\nLEFT JOIN "bakery" ON "cake"."bakery_id" = "bakery"."id"\nORDER BY "cake"."id" ASC LIMIT 1\n')),(0,r.kt)("h3",{id:"join-with-alias"},"Join with alias"),(0,r.kt)("p",null,"When the same table is joined more than once in the same query, it's necessary to use an alias. You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"alias")," attribute to select columns from an alias."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct CakeFactory {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Factory>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "bakery::Entity", alias = "factory", from_query_result)]\nstruct Factory {\n    id: i32,\n    #[sea_orm(from_col = "name")]\n    plant: String,\n}\n\nlet cake_factory: CakeFactory = cake::Entity::find()\n    .join_as(\n        JoinType::LeftJoin,\n        cake::Relation::Bakery.def(),\n        Alias::new("factory"),\n    )\n    .order_by_asc(cake::Column::Id)\n    .into_partial_model()\n    .one(db)\n    .await?\n    .unwrap();\n')),(0,r.kt)("p",null,"Results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    "cake"."id" AS "id",\n    "cake"."name" AS "name",\n    "factory"."id" AS "bakery_id",\n    "factory"."name" AS "bakery_plant"\nFROM "cake"\nLEFT JOIN "bakery" AS "factory" ON "cake"."bakery_id" = "factory"."id"\nORDER BY "cake"."id" ASC LIMIT 1\n')),(0,r.kt)("h2",{id:"three-way-join"},"Three-way Join"),(0,r.kt)("p",null,"Our join tree starts from Order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Customer\n      -> LineItem -> Cake\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "order::Entity", from_query_result)]\nstruct Order {\n    id: i32,\n    total: Decimal,\n    #[sea_orm(nested)]\n    customer: Customer,\n    #[sea_orm(nested)]\n    line: LineItem,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "customer::Entity", from_query_result)]\nstruct Customer {\n    name: String,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "lineitem::Entity", from_query_result)]\nstruct LineItem {\n    price: Decimal,\n    quantity: i32,\n    #[sea_orm(nested)]\n    cake: Cake,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    name: String,\n}\n\nlet items: Vec<Order> = order::Entity::find()\n    .left_join(customer::Entity)\n    .left_join(lineitem::Entity)\n    .join(JoinType::LeftJoin, lineitem::Relation::Cake.def())\n    .order_by_asc(order::Column::Id)\n    .order_by_asc(lineitem::Column::Id)\n    .into_partial_model()\n    .all(db)\n    .await?;\n\nassert_eq!(\n    items,\n    [\n        Order {\n            id: 101,\n            total: Decimal::from(10),\n            customer: Customer {\n                name: "Bob".to_owned()\n            },\n            line: LineItem {\n                cake: Cake {\n                    name: "Cheesecake".to_owned()\n                },\n                price: Decimal::from(2),\n                quantity: 2,\n            }\n        },\n        ..\n    ]\n);\n')),(0,r.kt)("p",null,"Since Cake is a related Entity of LineItem, not Order, it does not satisfy the trait bound of ",(0,r.kt)("inlineCode",{parentName:"p"},"left_join"),". It is thus necessary to use the more flexible ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," method."),(0,r.kt)("h2",{id:"three-model-select"},"Three-Model select"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Lineitem -> Cake\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(db)\n        .await?;\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"find_also_related")," is based on relations of the first entity.\n",(0,r.kt)("inlineCode",{parentName:"p"},"and_also_related")," is based on relations of the second entity."),(0,r.kt)("p",null,"To do this instead, you can write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Customer\n      -> LineItem\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"order::Entity::find()\n    .find_also_related(customer::Entity)\n    .find_also_related(lineitem::Entity)\n")))}c.isMDXComponent=!0}}]);