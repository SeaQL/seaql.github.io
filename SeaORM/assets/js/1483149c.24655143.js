"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[28484],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},39365:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"generate-entity/entity-first","title":"Entity First Workfllow","description":"What\'s Entity first?","source":"@site/docs/04-generate-entity/06-entity-first.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/entity-first","permalink":"/SeaORM/docs/generate-entity/entity-first","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/04-generate-entity/06-entity-first.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1761563260000,"sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"New Type","permalink":"/SeaORM/docs/generate-entity/newtype"},"next":{"title":"Basic Schema","permalink":"/SeaORM/docs/basic-crud/basic-schema"}}');var s=t(74848),r=t(28453);const o={},a="Entity First Workfllow",l={},d=[{value:"What&#39;s Entity first?",id:"whats-entity-first",level:2},{value:"Entity Registry",id:"entity-registry",level:2},{value:"Resolving Entity Relations",id:"resolving-entity-relations",level:2},{value:"Schema Sync in Action",id:"schema-sync-in-action",level:2},{value:"Adding Table",id:"adding-table",level:3},{value:"Adding Columns",id:"adding-columns",level:3},{value:"Rename Column",id:"rename-column",level:3},{value:"Add Foreign Key",id:"add-foreign-key",level:3},{value:"Add Unique Key",id:"add-unique-key",level:3},{value:"Remove Unique Key",id:"remove-unique-key",level:3},{value:"Footnotes",id:"footnotes",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"entity-first-workfllow",children:"Entity First Workfllow"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,s.jsx)(n.code,{children:"2.0.0"})]})}),"\n",(0,s.jsx)(n.h2,{id:"whats-entity-first",children:"What's Entity first?"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM used to adopt a schema\u2011first approach: meaning you design database tables and write migration scripts first, then generate entities from that schema."}),"\n",(0,s.jsx)(n.p,{children:"Entity\u2011first flips the flow: you hand-write the entity files, and let SeaORM generates the tables and foreign keys for you."}),"\n",(0,s.jsxs)(n.p,{children:["All you have to do is to add the following to your ",(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/examples/quickstart/src/main.rs",children:(0,s.jsx)(n.code,{children:"main.rs"})})," right after creating the database connection:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let db = &Database::connect(db_url).await?;\n// synchronizes database schema with entity definitions\ndb.get_schema_registry("my_crate::entity::*").sync(db).await?;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This requires two feature flags ",(0,s.jsx)(n.code,{children:"schema-sync"})," and ",(0,s.jsx)(n.code,{children:"entity-registry"}),", and we're going to explain what they do."]}),"\n",(0,s.jsx)(n.h2,{id:"entity-registry",children:"Entity Registry"}),"\n",(0,s.jsxs)(n.p,{children:["The above function ",(0,s.jsx)(n.code,{children:"get_schema_registry"})," unfolds into the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"db.get_schema_builder()\n    .register(comment::Entity)\n    .register(post::Entity)\n    .register(profile::Entity)\n    .register(user::Entity)\n    .sync(db)\n    .await?;\n"})}),"\n",(0,s.jsx)(n.p,{children:"You might be wondering: how can SeaORM recognize my entities when, at compile time, the SeaORM crate itself has no knowledge of them?"}),"\n",(0,s.jsxs)(n.p,{children:["Rest assured, there's no source\u2011file scanning or other hacks involved - this is powered by the brilliant ",(0,s.jsx)(n.a,{href:"https://docs.rs/inventory/latest/inventory/",children:(0,s.jsx)(n.code,{children:"inventory"})})," crate. The ",(0,s.jsx)(n.code,{children:"inventory"})," crate works by registering items (called plugins) into linker-collected sections."]}),"\n",(0,s.jsxs)(n.p,{children:["At compile-time, each ",(0,s.jsx)(n.code,{children:"Entity"})," module registers itself to the global ",(0,s.jsx)(n.code,{children:"inventory"})," along with their module paths and some metadata. On runtime, SeaORM then filters the Entities you requested and construct a ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.15/sea_orm/schema/struct.SchemaBuilder.html",children:(0,s.jsx)(n.code,{children:"SchemaBuilder"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"EntityRegistry"})," is completely optional and just adds extra convenience, it's perfectly fine for you to ",(0,s.jsx)(n.code,{children:"register"})," Entities manually like above."]}),"\n",(0,s.jsx)(n.h2,{id:"resolving-entity-relations",children:"Resolving Entity Relations"}),"\n",(0,s.jsxs)(n.p,{children:["If you remember from the previous post, you'll notice that ",(0,s.jsx)(n.code,{children:"comment"})," has a foreign key referencing ",(0,s.jsx)(n.code,{children:"post"}),". Since SQLite doesn't allow adding foreign keys after the fact, the ",(0,s.jsx)(n.code,{children:"post"})," table must be created before the ",(0,s.jsx)(n.code,{children:"comment"})," table."]}),"\n",(0,s.jsx)(n.p,{children:"This is where SeaORM shines: it automatically builds a dependency graph from your entities and determines the correct topological order to create the tables, so you don't have to keep track of them in your head."}),"\n",(0,s.jsx)(n.h2,{id:"schema-sync-in-action",children:"Schema Sync in Action"}),"\n",(0,s.jsxs)(n.p,{children:["The second feature, ",(0,s.jsx)(n.code,{children:"schema-sync"}),", compares the in\u2011memory entity definitions with the live database schema, detects missing tables, columns, and keys, and creates them idempotently - no matter how many times you run ",(0,s.jsx)(n.code,{children:"sync"}),", the schema converges to the same state."]}),"\n",(0,s.jsx)(n.p,{children:"Let's walk through the different scenarios:"}),"\n",(0,s.jsx)(n.h3,{id:"adding-table",children:"Adding Table"}),"\n",(0,s.jsxs)(n.p,{children:["Let's say you added a new Entity under ",(0,s.jsx)(n.code,{children:"mod.rs"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="entity/mod.rs"',children:"//! `SeaORM` Entity, @generated by sea-orm-codegen 2.0.0-rc.14\n\npub mod prelude;\n\npub mod post;\npub mod upvote; // \u2b05 new entity module\n..\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The next time you ",(0,s.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'CREATE TABLE "upvote" ( "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, .. )\n'})}),"\n",(0,s.jsx)(n.p,{children:"This will create the table along with any foreign keys."}),"\n",(0,s.jsx)(n.h3,{id:"adding-columns",children:"Adding Columns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="entity/profile.rs"',children:'use sea_orm::entity::prelude::*;\n\n#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "profile")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub picture: String,\n    pub date_of_birth: Option<DateTimeUtc>, // \u2b05 new column\n    ..\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The next time you ",(0,s.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'ALTER TABLE "profile" ADD COLUMN "date_of_birth" timestamp with time zone\n'})}),"\n",(0,s.jsxs)(n.p,{children:["How about adding a non-nullable column? You can set a ",(0,s.jsx)(n.code,{children:"default_value"})," or ",(0,s.jsx)(n.code,{children:"default_expr"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[sea_orm(default_value = 0)]\npub post_count: i32,\n\n// this doesn\'t work in SQLite\n#[sea_orm(default_expr = "Expr::current_timestamp()")]\npub updated_at: DateTimeUtc,\n'})}),"\n",(0,s.jsx)(n.h3,{id:"rename-column",children:"Rename Column"}),"\n",(0,s.jsx)(n.p,{children:"If you only want to rename the field name in code, you can simply remap the column name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'pub struct Model {\n    ..\n    #[sea_orm(column_name = "date_of_birth")]\n    pub dob: Option<DateTimeUtc>, // \u2b05 renamed for brevity\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This doesn't involve any schema change."}),"\n",(0,s.jsx)(n.p,{children:"If you want to actually rename the column, then you have to add a special attribute. Note that you can't simply change the field name, as this will be recognized as adding a new column."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'pub struct Model {\n    ..\n    #[sea_orm(renamed_from = "date_of_birth")] // \u2b05 special annotation\n    pub dob: Option<DateTimeUtc>,\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The next time you ",(0,s.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'ALTER TABLE "profile" RENAME COLUMN "date_of_birth" TO "dob"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Nice, isn't it?"}),"\n",(0,s.jsx)(n.h3,{id:"add-foreign-key",children:"Add Foreign Key"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a new table with a foreign key:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="entity/upvote.rs"',children:'use sea_orm::entity::prelude::*;\n\n#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "upvote")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub post_id: i32,\n    #[sea_orm(belongs_to, from = "post_id", to = "id")]\n    pub post: HasOne<super::post::Entity>,\n    ..\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The next time you ",(0,s.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'CREATE TABLE "upvote" (\n    "post_id" integer NOT NULL PRIMARY KEY,\n    ..\n    FOREIGN KEY ("post_id") REFERENCES "post" ("id")\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If however, the ",(0,s.jsx)(n.code,{children:"post"})," relation is added after the table has been created, then the foreign key couldn't be created for SQLite. Relational queries would still work, but functions completely client-side."]}),"\n",(0,s.jsx)(n.h3,{id:"add-unique-key",children:"Add Unique Key"}),"\n",(0,s.jsx)(n.p,{children:"Now, let's say we've forgotten to add a unique constraint on user name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="entity/user.rs"',children:'use sea_orm::entity::prelude::*;\n\n#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "user")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)] // \u2b05 add unique key\n    pub name: String,\n    #[sea_orm(unique)]\n    pub email: String,\n    ..\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The next time you ",(0,s.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'CREATE UNIQUE INDEX "idx-user-name" ON "user" ("name")\n'})}),"\n",(0,s.jsx)(n.p,{children:"As mentioned in the previous blog post, you'll also get a shorthand method generated on the Entity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'user::Entity::find_by_name("Bob")..\n'})}),"\n",(0,s.jsx)(n.h3,{id:"remove-unique-key",children:"Remove Unique Key"}),"\n",(0,s.jsx)(n.p,{children:"Well, you've changed your mind and want to remove the unique constraint on user name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // no annotation\n    pub name: String,\n    #[sea_orm(unique)]\n    pub email: String,\n    ..\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The next time you ",(0,s.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'DROP INDEX "idx-user-name"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"footnotes",children:"Footnotes"}),"\n",(0,s.jsxs)(n.p,{children:["Note that in general schema sync would not attempt to do any destructive actions, so meaning no ",(0,s.jsx)(n.code,{children:"DROP"})," on tables, columns and foreign keys. Dropping index is an exception here."]}),"\n",(0,s.jsxs)(n.p,{children:["Every time the application starts, a full schema discovery is performed. This may not be desirable in production, so ",(0,s.jsx)(n.code,{children:"sync"})," is gated behind a feature flag ",(0,s.jsx)(n.code,{children:"schema-sync"})," that can be turned off based on build profile."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);