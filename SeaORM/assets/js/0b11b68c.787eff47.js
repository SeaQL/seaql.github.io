"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[61476],{22098:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"relation/complex-relations","title":"Complex Relations","description":"Linked","source":"@site/docs/06-relation/04-complex-relations.md","sourceDirName":"06-relation","slug":"/relation/complex-relations","permalink":"/SeaORM/docs/relation/complex-relations","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/04-complex-relations.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1762632495000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Many to Many","permalink":"/SeaORM/docs/relation/many-to-many"},"next":{"title":"Model Loader","permalink":"/SeaORM/docs/relation/model-loader"}}');var t=a(74848),r=a(28453);const s={},l="Complex Relations",o={},d=[{value:"Linked",id:"linked",level:2},{value:"Defining the Link",id:"defining-the-link",level:3},{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Eager Loading",id:"eager-loading",level:3},{value:"Self Referencing Relations",id:"self-referencing-relations",level:2},{value:"Entity Loader",id:"entity-loader",level:3},{value:"Model Loader",id:"model-loader",level:3},{value:"Diamond Relations",id:"diamond-relations",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"complex-relations",children:"Complex Relations"})}),"\n",(0,t.jsx)(n.h2,{id:"linked",children:"Linked"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Related"})," trait is a representation of the arrows (1-1, 1-N, M-N) we draw on Entity Relationship Diagrams. A ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.Linked.html",children:(0,t.jsx)(n.code,{children:"Linked"})})," is composed of a chain of relations, and is useful when:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["there exist multiple join paths between a pair of entities, making it impossible to impl ",(0,t.jsx)(n.code,{children:"Related"})]}),"\n",(0,t.jsx)(n.li,{children:"joining across multiple entities in a relational query"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Implementing ",(0,t.jsx)(n.code,{children:"Linked"})," trait is completely optional, as there are other ways of doing relational queries in SeaORM, which will be explained in later chapters.\nWith ",(0,t.jsx)(n.code,{children:"Linked"})," implemented, several ",(0,t.jsx)(n.code,{children:"find_*_linked"})," helper methods become available, and relationships can be defined in a single place."]}),"\n",(0,t.jsx)(n.h3,{id:"defining-the-link",children:"Defining the Link"}),"\n",(0,t.jsxs)(n.p,{children:["Take ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/entity_linked.rs",children:"this"})," as an example, where we join cake and filling via an intermediate ",(0,t.jsx)(n.code,{children:"cake_filling"})," table."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="entity/links.rs"',children:"pub struct CakeToFilling;\n\nimpl Linked for CakeToFilling {\n    type FromEntity = cake::Entity;\n    type ToEntity = filling::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            cake_filling::Relation::Cake.def().rev(), // cake -> cake_filling\n            cake_filling::Relation::Filling.def(),    // cake_filling -> filling\n        ]\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,t.jsxs)(n.p,{children:["Find fillings that can be filled into a cake with the ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/trait.ModelTrait.html#method.find_linked",children:(0,t.jsx)(n.code,{children:"find_linked"})})," method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let cake_model = cake::Model {\n    id: 12,\n    name: "Chocolate".into(),\n};\n\nassert_eq!(\n    cake_model\n        .find_linked(cake::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `filling`.`id`, `filling`.`name`, `filling`.`vendor_id`",\n        "FROM `filling`",\n        "INNER JOIN `cake_filling` AS `r0` ON `r0`.`filling_id` = `filling`.`id`",\n        "INNER JOIN `cake` AS `r1` ON `r1`.`id` = `r0`.`cake_id`",\n        "WHERE `r1`.`id` = 12",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.Select.html#method.find_also_linked",children:(0,t.jsx)(n.code,{children:"find_also_linked"})})," is a dual of ",(0,t.jsx)(n.code,{children:"find_also_related"}),"; ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.Select.html#method.find_with_linked",children:(0,t.jsx)(n.code,{children:"find_with_linked"})})," is a dual of ",(0,t.jsx)(n.code,{children:"find_with_related"}),"; :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .find_also_linked(links::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id` AS `A_id`, `cake`.`name` AS `A_name`,",\n        "`r1`.`id` AS `B_id`, `r1`.`name` AS `B_name`, `r1`.`vendor_id` AS `B_vendor_id`",\n        "FROM `cake`",\n        "LEFT JOIN `cake_filling` AS `r0` ON `cake`.`id` = `r0`.`cake_id`",\n        "LEFT JOIN `filling` AS `r1` ON `r0`.`filling_id` = `r1`.`id`",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"self-referencing-relations",children:"Self Referencing Relations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="staff.rs"',children:'use sea_orm::entity::prelude::*;\n\n#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "staff")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    pub reports_to_id: Option<i32>,\n    #[sea_orm(\n        self_ref,\n        relation_enum = "ReportsTo",\n        from = "reports_to_id",\n        to = "id"\n    )]\n    pub reports_to: HasOne<Entity>,\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"entity-loader",children:"Entity Loader"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let staff = staff::Entity::load()\n    .with(staff::Relation::ReportsTo)\n    .all(db)\n    .await?;\n\nassert_eq!(staff[0].name, "Alan");\nassert_eq!(staff[0].reports_to, None);\n\nassert_eq!(staff[1].name, "Ben");\nassert_eq!(staff[1].reports_to.as_ref().unwrap().name, "Alan");\n\nassert_eq!(staff[2].name, "Alice");\nassert_eq!(staff[2].reports_to.as_ref().unwrap().name, "Alan");\n\nassert_eq!(staff[3].name, "Elle");\nassert_eq!(staff[3].reports_to, None);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"model-loader",children:"Model Loader"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let staff = staff::Entity::find()\n    .order_by_asc(staff::Column::Id)\n    .all(db)\n    .await?;\n\nlet reports_to = staff\n    .load_self(staff::Entity, staff::Relation::ReportsTo, db)\n    .await?;\n\nassert_eq!(staff[0].name, "Alan");\nassert_eq!(reports_to[0], None);\n\nassert_eq!(staff[1].name, "Ben");\nassert_eq!(reports_to[1].unwrap().name, "Alan");\n\nassert_eq!(staff[2].name, "Alice");\nassert_eq!(reports_to[2].unwrap().name, "Alan");\n\nassert_eq!(staff[3].name, "Elle");\nassert_eq!(reports_to[3], None);\n'})}),"\n",(0,t.jsx)(n.p,{children:"It can works in reverse too."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let manages = staff\n    .load_self_rev(\n        staff::Entity::find().order_by_asc(staff::Column::Id),\n        staff::Relation::ReportsTo,\n        db,\n    )\n    .await?;\n\nassert_eq!(staff[0].name, "Alan");\nassert_eq!(manages[0].len(), 2);\nassert_eq!(manages[0][0].name, "Ben");\nassert_eq!(manages[0][1].name, "Alice");\n\nassert_eq!(staff[1].name, "Ben");\nassert_eq!(manages[1].len(), 0);\n\nassert_eq!(staff[2].name, "Alice");\nassert_eq!(manages[2].len(), 0);\n\nassert_eq!(staff[3].name, "Elle");\nassert_eq!(manages[3].len(), 0);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"diamond-relations",children:"Diamond Relations"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes there exist multiple relations between a pair of entities. Here we take the simplest example, where ",(0,t.jsx)(n.code,{children:"Bakery"})," can have multiple ",(0,t.jsx)(n.code,{children:"Worker"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "bakery")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    pub manager_id: i32,\n    pub cashier_id: i32,\n    #[sea_orm(belongs_to, relation_enum = "Manager", from = "manager_id", to = "id")]\n    pub manager: HasOne<super::worker::Entity>,\n    #[sea_orm(belongs_to, relation_enum = "Cashier", from = "cashier_id", to = "id")]\n    pub cashier: HasOne<super::worker::Entity>,\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["How can we define the ",(0,t.jsx)(n.code,{children:"Worker"})," Entity?\nBy default, ",(0,t.jsx)(n.code,{children:"has_many"})," invokes the ",(0,t.jsx)(n.code,{children:"Related"})," trait to define the relation.\nAs a consequence, we have to specify the ",(0,t.jsx)(n.code,{children:"Relation"})," variant of the related entity manually with the ",(0,t.jsx)(n.code,{children:"via_rel"})," attribute."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="worker.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "worker")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(has_many, relation_enum = "BakeryManager", via_rel = "Manager")]\n    pub manager_of: HasMany<super::bakery::Entity>,\n    #[sea_orm(has_many, relation_enum = "BakeryCashier", via_rel = "Cashier")]\n    pub cashier_of: HasMany<super::bakery::Entity>,\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"For compact Entities, it looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="worker.rs"',children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "worker")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = "super::bakery::Entity", via_rel = "Relation::Manager")]\n    BakeryManager,\n    #[sea_orm(has_many = "super::bakery::Entity", via_rel = "Relation::Cashier")]\n    BakeryCashier,\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then you can use the relations like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fruit::Entity::find().join(JoinType::LeftJoin, fruit::Relation::ToppingOf.def());\n"})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>l});var i=a(96540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);