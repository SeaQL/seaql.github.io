"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[50559],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(96540);const l={},a=t.createContext(l);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},83522:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"relation/many-to-many","title":"Many to Many","description":"A many-to-many relation is formed by three tables, where two tables are related via a junction table. As an example, a Cake has many Filling and Filling are shared by many Cake via an intermediate entity CakeFilling.","source":"@site/versioned_docs/version-0.11.x/06-relation/03-many-to-many.md","sourceDirName":"06-relation","slug":"/relation/many-to-many","permalink":"/SeaORM/docs/0.11.x/relation/many-to-many","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-0.11.x/06-relation/03-many-to-many.md","tags":[],"version":"0.11.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1759584009000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"One to Many","permalink":"/SeaORM/docs/0.11.x/relation/one-to-many"},"next":{"title":"Chained Relations","permalink":"/SeaORM/docs/0.11.x/relation/chained-relations"}}');var l=i(74848),a=i(28453);const r={},o="Many to Many",s={},d=[{value:"Defining the Relation",id:"defining-the-relation",level:2},{value:"Defining the Inverse Relation",id:"defining-the-inverse-relation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"many-to-many",children:"Many to Many"})}),"\n",(0,l.jsxs)(n.p,{children:["A many-to-many relation is formed by three tables, where two tables are related via a junction table. As an example, a ",(0,l.jsx)(n.code,{children:"Cake"})," has many ",(0,l.jsx)(n.code,{children:"Filling"})," and ",(0,l.jsx)(n.code,{children:"Filling"})," are shared by many ",(0,l.jsx)(n.code,{children:"Cake"})," via an intermediate entity ",(0,l.jsx)(n.code,{children:"CakeFilling"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"defining-the-relation",children:"Defining the Relation"}),"\n",(0,l.jsxs)(n.p,{children:["On the ",(0,l.jsx)(n.code,{children:"Cake"})," entity, implement the ",(0,l.jsx)(n.code,{children:"Related<filling::Entity>"})," trait."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Relation"})," in SeaORM is an arrow: it has ",(0,l.jsx)(n.code,{children:"from"})," and ",(0,l.jsx)(n.code,{children:"to"}),". ",(0,l.jsx)(n.code,{children:"cake_filling::Relation::Cake"})," defines ",(0,l.jsx)(n.code,{children:"CakeFilling -> Cake"}),". Calling ",(0,l.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.RelationDef.html#method.rev",children:(0,l.jsx)(n.code,{children:"rev"})})," reverses it into ",(0,l.jsx)(n.code,{children:"Cake -> CakeFilling"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Chaining this with ",(0,l.jsx)(n.code,{children:"cake_filling::Relation::Filling"})," which defines ",(0,l.jsx)(n.code,{children:"CakeFilling -> Filling"})," resulting in ",(0,l.jsx)(n.code,{children:"Cake -> CakeFilling -> Filling"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'{4,10} title="entity/cake.rs"',children:"impl Related<super::filling::Entity> for Entity {\n    // The final relation is Cake -> CakeFilling -> Filling\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        // The original relation is CakeFilling -> Cake,\n        // after `rev` it becomes Cake -> CakeFilling\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Similarly, on the ",(0,l.jsx)(n.code,{children:"Filling"})," entity, implement the ",(0,l.jsx)(n.code,{children:"Related<cake::Entity>"})," trait. First, join with intermediate table ",(0,l.jsx)(n.code,{children:"via"})," the inverse of ",(0,l.jsx)(n.code,{children:"cake_filling::Relation::Filling"})," relation, then join ",(0,l.jsx)(n.code,{children:"to"})," ",(0,l.jsx)(n.code,{children:"Cake"})," entity  with ",(0,l.jsx)(n.code,{children:"cake_filling::Relation::Cake"})," relation."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'{3,7} title="entity/filling.rs"',children:"impl Related<super::cake::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Cake.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Filling.def().rev())\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"defining-the-inverse-relation",children:"Defining the Inverse Relation"}),"\n",(0,l.jsxs)(n.p,{children:["On the ",(0,l.jsx)(n.code,{children:"CakeFilling"})," entity, its ",(0,l.jsx)(n.code,{children:"cake_id"})," attribute is referencing the primary key of ",(0,l.jsx)(n.code,{children:"Cake"})," entity, and its ",(0,l.jsx)(n.code,{children:"filling_id"})," attribute is referencing the primary key of ",(0,l.jsx)(n.code,{children:"Filling"})," entity."]}),"\n",(0,l.jsx)(n.p,{children:"To define the inverse relation:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Add two new variants ",(0,l.jsx)(n.code,{children:"Cake"})," and ",(0,l.jsx)(n.code,{children:"Filling"})," to the ",(0,l.jsx)(n.code,{children:"Relation"})," enum."]}),"\n",(0,l.jsxs)(n.li,{children:["Define both relations with ",(0,l.jsx)(n.code,{children:"Entity::belongs_to()"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="entity/cake_filling.rs"',children:"#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Cake,\n    Filling,\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Cake => Entity::belongs_to(super::cake::Entity)\n                .from(Column::CakeId)\n                .to(super::cake::Column::Id)\n                .into(),\n            Self::Filling => Entity::belongs_to(super::filling::Entity)\n                .from(Column::FillingId)\n                .to(super::filling::Column::Id)\n                .into(),\n        }\n    }\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Alternatively, the definition can be shortened by the ",(0,l.jsx)(n.code,{children:"DeriveRelation"})," macro, where the following eliminates the need for the ",(0,l.jsx)(n.code,{children:"RelationTrait"})," implementation above:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::cake::Entity",\n        from = "Column::CakeId",\n        to = "super::cake::Column::Id"\n    )]\n    Cake,\n    #[sea_orm(\n        belongs_to = "super::filling::Entity",\n        from = "Column::FillingId",\n        to = "super::filling::Column::Id"\n    )]\n    Filling,\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);