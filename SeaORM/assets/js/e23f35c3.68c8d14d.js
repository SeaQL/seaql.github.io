"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[46519],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var a=t(96540);const s={},o=a.createContext(s);function r(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(o.Provider,{value:n},e.children)}},75962:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"write-test/mock","title":"Mock Interface","description":"You can unit test your application logic using the mock database interface.","source":"@site/versioned_docs/version-1.1.x/07-write-test/02-mock.md","sourceDirName":"07-write-test","slug":"/write-test/mock","permalink":"/SeaORM/docs/write-test/mock","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/07-write-test/02-mock.md","tags":[],"version":"1.1.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1758919343000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Robust & Correct","permalink":"/SeaORM/docs/write-test/testing"},"next":{"title":"Using SQLite","permalink":"/SeaORM/docs/write-test/sqlite"}}');var s=t(74848),o=t(28453);const r={},i="Mock Interface",c={},d=[{value:"Mocking Query Result",id:"mocking-query-result",level:2},{value:"Mocking Execution Result",id:"mocking-execution-result",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"mock-interface",children:"Mock Interface"})}),"\n",(0,s.jsx)(n.p,{children:"You can unit test your application logic using the mock database interface."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["You need to enable the ",(0,s.jsx)(n.code,{children:"mock"})," feature flag in Cargo.toml."]})}),"\n",(0,s.jsx)(n.p,{children:"The mock database has no data in it, so you have to define the expected data to be returned when CRUD operations are performed."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The query result should be provided to support select operations"}),"\n",(0,s.jsx)(n.li,{children:"The exec result should be provided to support insert, update, and delete operations"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To ensure the correctness of your application logic, you can also validate the transaction log in the mock database."}),"\n",(0,s.jsxs)(n.p,{children:["Check out how we write unit tests using mock connection ",(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/executor/paginator.rs#L250",children:"here"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"mocking-query-result",children:"Mocking Query Result"}),"\n",(0,s.jsxs)(n.p,{children:["We create a mock database for PostgreSQL with ",(0,s.jsx)(n.code,{children:"MockDatabase::new(DatabaseBackend::Postgres)"}),". Then, query results are prepared using the ",(0,s.jsx)(n.code,{children:"append_query_results"})," method. Note that we pass a vector of vectors to it, representing multiple query results, each with more than one model. Finally, we convert it into a connection and use it to perform CRUD operations just like a normal live connection."]}),"\n",(0,s.jsxs)(n.p,{children:["One special thing about ",(0,s.jsx)(n.code,{children:"MockDatabase"})," is that you can check the transaction log of it. Any SQL query run on the mock database will be recorded; you can validate each of the log to ensure the correctness of your application logic."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use sea_orm::{\n        entity::prelude::*, entity::*, tests_cfg::*,\n        DatabaseBackend, MockDatabase, Transaction,\n    };\n\n    #[async_std::test]\n    async fn test_find_cake() -> Result<(), DbErr> {\n        // Create MockDatabase with mock query results\n        let db = MockDatabase::new(DatabaseBackend::Postgres)\n            .append_query_results([\n                // First query result\n                vec![cake::Model {\n                    id: 1,\n                    name: "New York Cheese".to_owned(),\n                }],\n                // Second query result\n                vec![\n                    cake::Model {\n                        id: 1,\n                        name: "New York Cheese".to_owned(),\n                    },\n                    cake::Model {\n                        id: 2,\n                        name: "Chocolate Forest".to_owned(),\n                    },\n                ],\n            ])\n            .append_query_results([\n                // Third query result\n                [(\n                    cake::Model {\n                        id: 1,\n                        name: "Apple Cake".to_owned(),\n                    },\n                    fruit::Model {\n                        id: 2,\n                        name: "Apple".to_owned(),\n                        cake_id: Some(1),\n                    },\n                )],\n            ])\n            .into_connection();\n\n        // Find a cake from MockDatabase\n        // Return the first query result\n        assert_eq!(\n            cake::Entity::find().one(&db).await?,\n            Some(cake::Model {\n                id: 1,\n                name: "New York Cheese".to_owned(),\n            })\n        );\n\n        // Find all cakes from MockDatabase\n        // Return the second query result\n        assert_eq!(\n            cake::Entity::find().all(&db).await?,\n            [\n                cake::Model {\n                    id: 1,\n                    name: "New York Cheese".to_owned(),\n                },\n                cake::Model {\n                    id: 2,\n                    name: "Chocolate Forest".to_owned(),\n                },\n            ]\n        );\n\n        // Find all cakes with its related fruits\n        assert_eq!(\n            cake::Entity::find()\n                .find_also_related(fruit::Entity)\n                .all(&db)\n                .await?,\n            [(\n                cake::Model {\n                    id: 1,\n                    name: "Apple Cake".to_owned(),\n                },\n                Some(fruit::Model {\n                    id: 2,\n                    name: "Apple".to_owned(),\n                    cake_id: Some(1),\n                })\n            )]\n        );\n\n        // Checking transaction log\n        assert_eq!(\n            db.into_transaction_log(),\n            [\n                Transaction::from_sql_and_values(\n                    DatabaseBackend::Postgres,\n                    r#"SELECT "cake"."id", "cake"."name" FROM "cake" LIMIT $1"#,\n                    [1u64.into()]\n                ),\n                Transaction::from_sql_and_values(\n                    DatabaseBackend::Postgres,\n                    r#"SELECT "cake"."id", "cake"."name" FROM "cake""#,\n                    []\n                ),\n                Transaction::from_sql_and_values(\n                    DatabaseBackend::Postgres,\n                    r#"SELECT "cake"."id" AS "A_id", "cake"."name" AS "A_name", "fruit"."id" AS "B_id", "fruit"."name" AS "B_name", "fruit"."cake_id" AS "B_cake_id" FROM "cake" LEFT JOIN "fruit" ON "cake"."id" = "fruit"."cake_id""#,\n                    []\n                ),\n            ]\n        );\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"mocking-execution-result",children:"Mocking Execution Result"}),"\n",(0,s.jsxs)(n.p,{children:["This is very similar to mocking query result, the differences are that we use the ",(0,s.jsx)(n.code,{children:"append_exec_results"})," method here and we perform insert, update, and delete operations here in the unit test. The ",(0,s.jsx)(n.code,{children:"append_exec_results"})," method takes a vector of ",(0,s.jsx)(n.code,{children:"MockExecResult"}),", each representing the exec result of the corresponding operation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use sea_orm::{\n        entity::prelude::*, entity::*, tests_cfg::*,\n        DatabaseBackend, MockDatabase, MockExecResult, Transaction,\n    };\n\n    #[async_std::test]\n    async fn test_insert_cake() -> Result<(), DbErr> {\n        // Create MockDatabase with mock execution result\n        let db = MockDatabase::new(DatabaseBackend::Postgres)\n            .append_query_results([\n                [cake::Model {\n                    id: 15,\n                    name: "Apple Pie".to_owned(),\n                }],\n                [cake::Model {\n                    id: 16,\n                    name: "Apple Pie".to_owned(),\n                }],\n            ])\n            .append_exec_results([\n                MockExecResult {\n                    last_insert_id: 15,\n                    rows_affected: 1,\n                },\n                MockExecResult {\n                    last_insert_id: 16,\n                    rows_affected: 1,\n                },\n            ])\n            .into_connection();\n\n        // Prepare the ActiveModel\n        let apple = cake::ActiveModel {\n            name: Set("Apple Pie".to_owned()),\n            ..Default::default()\n        };\n\n        // Insert the ActiveModel into MockDatabase\n        assert_eq!(\n            apple.clone().insert(&db).await?,\n            cake::Model {\n                id: 15,\n                name: "Apple Pie".to_owned()\n            }\n        );\n\n        // If you want to check the last insert id\n        let insert_result = cake::Entity::insert(apple).exec(&db).await?;\n        assert_eq!(insert_result.last_insert_id, 16);\n\n        // Checking transaction log\n        assert_eq!(\n            db.into_transaction_log(),\n            [\n                Transaction::from_sql_and_values(\n                    DatabaseBackend::Postgres,\n                    r#"INSERT INTO "cake" ("name") VALUES ($1) RETURNING "id", "name""#,\n                    ["Apple Pie".into()]\n                ),\n                Transaction::from_sql_and_values(\n                    DatabaseBackend::Postgres,\n                    r#"INSERT INTO "cake" ("name") VALUES ($1) RETURNING "id""#,\n                    ["Apple Pie".into()]\n                ),\n            ]\n        );\n\n        Ok(())\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);