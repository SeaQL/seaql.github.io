"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[85182],{27636:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"relation/multi-selects","title":"multi-selects","description":"Multi Selects","source":"@site/docs/06-relation/10-multi-selects.md","sourceDirName":"06-relation","slug":"/relation/multi-selects","permalink":"/SeaORM/docs/relation/multi-selects","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/10-multi-selects.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1759961829000,"sidebarPosition":10,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Nested Selects","permalink":"/SeaORM/docs/relation/nested-selects"},"next":{"title":"Relational Query","permalink":"/SeaORM/docs/relation/relational-query"}}');var i=t(74848),r=t(28453);const o={},s=void 0,a={},d=[{value:"Multi Selects",id:"multi-selects",level:2},{value:"Select Three Models",id:"select-three-models",level:3},{value:"Consolidate results",id:"consolidate-results",level:3},{value:"Chain",id:"chain",level:4},{value:"Star",id:"star",level:4}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"multi-selects",children:"Multi Selects"}),"\n",(0,i.jsx)(n.p,{children:"In the previous chapter, we used partial models for querying multiple entities together. We can achieve the same using the multi-select API."}),"\n",(0,i.jsx)(n.h3,{id:"select-three-models",children:"Select Three Models"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"Order -> LineItem -> Cake\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .all(db)\n        .await?;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"find_also_related"})," is based on relations of the first entity.\n",(0,i.jsx)(n.code,{children:"and_also_related"})," is based on relations of the second entity."]}),"\n",(0,i.jsx)(n.p,{children:"To have a different join topology, you can write:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"Order -> Customer\n      -> LineItem\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"order::Entity::find()\n    .find_also_related(customer::Entity)\n    .find_also_related(lineitem::Entity)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"consolidate-results",children:"Consolidate results"}),"\n",(0,i.jsx)(n.p,{children:"You can consolidate query results on three model selects. The output has different shape depending on the topology of the join."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,i.jsx)(n.code,{children:"2.0.0"})]})}),"\n",(0,i.jsx)(n.h4,{id:"chain",children:"Chain"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"Order -> LineItem -> Cake\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(&ctx.db)\n        .await?;\n\n// flat result\nassert_eq!(\n    items,\n    vec![\n        (order, Some(line_1), Some(cake_1)),\n        (order, Some(line_2), Some(cake_2)),\n    ]\n);\n\nlet items: Vec<(order::Model, Vec<(lineitem::Model, Vec<cake::Model>)>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .consolidate() // <-\n        .all(&ctx.db)\n        .await?;\n\n// consolidated by order first, then by line\nassert_eq!(\n    items,\n    vec![(\n        order,\n        vec![(line_1, vec![cake_1]), (line_2, vec![cake_2])]\n    )]\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"It can comprise two one-to-many relations. For example,"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"vec![\n    (bakery, Some(baker_1), Some(cake_1)),\n    (bakery, Some(baker_1), Some(cake_2)),\n    (bakery, Some(baker_2), Some(cake_3)),\n]\n// would be consolidated into:\nvec![(\n    bakery,\n    vec![\n        (baker_1, vec![cake_1, cake_2]),\n        (baker_2, vec![cake_3]),\n    ]\n)]\n"})}),"\n",(0,i.jsx)(n.h4,{id:"star",children:"Star"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"Order -> Customer\n      -> LineItem\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let items: Vec<(order::Model, Option<customer::Model>, Option<lineitem::Model>)> =\n    order::Entity::find()\n        .find_also_related(customer::Entity)\n        .find_also_related(lineitem::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(&ctx.db)\n        .await?;\n\n// flat result\nassert_eq!(\n    items,\n    vec![\n        (order, Some(customer), Some(line_1)),\n        (order, Some(customer), Some(line_2)),\n    ]\n);\n\nlet items: Vec<(order::Model, Vec<customer::Model>, Vec<lineitem::Model>)> =\n    order::Entity::find()\n        .find_also_related(customer::Entity)\n        .find_also_related(lineitem::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .consolidate() // <-\n        .all(&ctx.db)\n        .await?;\n\n// consolidated by order\nassert_eq!(\n    items,\n    vec![(\n        order,\n        vec![customer],\n        vec![line_1, line_2]\n    )]\n);\n"})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var l=t(96540);const i={},r=l.createContext(i);function o(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),l.createElement(r.Provider,{value:n},e.children)}}}]);