"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[29723],{48859:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(76687);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=a.createContext({}),s=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,u=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(t),m=o,y=c["".concat(u,".").concat(m)]||c[m]||p[m]||r;return t?a.createElement(y,i(i({ref:n},d),{},{components:t})):a.createElement(y,i({ref:n},d))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=c;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},35964:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(31308),o=(t(76687),t(48859));const r={},i="Advanced Joins",l={unversionedId:"advanced-query/advanced-joins",id:"version-1.1.x/advanced-query/advanced-joins",title:"Advanced Joins",description:"An anatomy of a complex relational query with multiple joins and custom selects.",source:"@site/versioned_docs/version-1.1.x/08-advanced-query/04-advanced-joins.md",sourceDirName:"08-advanced-query",slug:"/advanced-query/advanced-joins",permalink:"/SeaORM/docs/advanced-query/advanced-joins",draft:!1,editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/08-advanced-query/04-advanced-joins.md",tags:[],version:"1.1.x",lastUpdatedBy:"prakashachanta",lastUpdatedAt:1740737909,formattedLastUpdatedAt:"Feb 28, 2025",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Aggregate Functions",permalink:"/SeaORM/docs/advanced-query/aggregate-function"},next:{title:"Sub Query",permalink:"/SeaORM/docs/advanced-query/subquery"}},u={},s=[{value:"Schema",id:"schema",level:2},{value:"<code>BaseProduct</code>",id:"baseproduct",level:4},{value:"<code>ComplexProduct</code>",id:"complexproduct",level:4},{value:"<code>ProductType</code>",id:"producttype",level:4},{value:"1. Define result data structure",id:"1-define-result-data-structure",level:2},{value:"2. Define helper aliases",id:"2-define-helper-aliases",level:2},{value:"3. Custom selects",id:"3-custom-selects",level:2},{value:"Custom join conditions",id:"custom-join-conditions",level:3},{value:"4. Filter Conditions",id:"4-filter-conditions",level:2},{value:"5. Extra: associated models",id:"5-extra-associated-models",level:2},{value:"<code>ProductHistory</code>",id:"producthistory",level:4}],d={toc:s};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"advanced-joins"},"Advanced Joins"),(0,o.kt)("p",null,"An anatomy of a complex relational query with multiple joins and custom selects."),(0,o.kt)("h2",{id:"schema"},"Schema"),(0,o.kt)("p",null,"Suppose we have a schema design of ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseProduct")," -> ",(0,o.kt)("inlineCode",{parentName:"p"},"ComplexProduct"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseProduct")," -> ",(0,o.kt)("inlineCode",{parentName:"p"},"ProductTypes"),"."),(0,o.kt)("h4",{id:"baseproduct"},(0,o.kt)("inlineCode",{parentName:"h4"},"BaseProduct")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "base_product")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i64,\n    #[sea_orm(unique)]\n    pub name: String,\n    pub type_id: i32, // linking to product_type\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_one = "super::complex_product::Entity")]\n    ComplexProduct,\n    #[sea_orm(has_many = "super::product_history::Entity")]\n    ProductHistory,\n    #[sea_orm(\n        belongs_to = "super::product_type::Entity",\n        from = "Column::TypeId",\n        to = "super::product_type::Column::Id",\n        on_update = "NoAction",\n        on_delete = "NoAction"\n    )]\n    ProductType,\n}\n')),(0,o.kt)("h4",{id:"complexproduct"},(0,o.kt)("inlineCode",{parentName:"h4"},"ComplexProduct")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "complex_product")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub product_id: i64, // linking to base_product\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub price: Option<Decimal>,\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub lot_size: Option<Decimal>,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n')),(0,o.kt)("h4",{id:"producttype"},(0,o.kt)("inlineCode",{parentName:"h4"},"ProductType")),(0,o.kt)("p",null,"Basically a 'enum table'."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "product_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)]\n    pub name: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = "super::base_product::Entity")]\n    BaseProduct,\n}\n')),(0,o.kt)("h2",{id:"1-define-result-data-structure"},"1. Define result data structure"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone, Debug, PartialEq, Eq, FromQueryResult, Serialize)]\npub struct ComplexProduct {\n    pub id: i64,\n    pub name: String,\n    pub r#type: String,\n    pub price: Decimal,\n    pub lot_size: Decimal,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n    #[sea_orm(skip)]\n    pub history: Vec<product_history::Model>,\n}\n")),(0,o.kt)("p",null,"With ",(0,o.kt)("inlineCode",{parentName:"p"},"Serialize"),", you can transform the select result into JSON directly."),(0,o.kt)("h2",{id:"2-define-helper-aliases"},"2. Define helper aliases"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(DeriveIden, Clone, Copy)]\npub struct Id;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Name;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Base;\n\nuse complex_product::Entity as Prod;\npub type ProdCol = <Prod as EntityTrait>::Column;\ntype ProdRel = <Prod as EntityTrait>::Relation;\n")),(0,o.kt)("p",null,"This would make our code much more concise and readable."),(0,o.kt)("p",null,"Avoid using ",(0,o.kt)("inlineCode",{parentName:"p"},"Alias::new")," because it's error-prone and slightly more expensive."),(0,o.kt)("h2",{id:"3-custom-selects"},"3. Custom selects"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn query() -> Select<complex_product::Entity> {\n    complex_product::Entity::find()\n        .select_only()\n        .tbl_col_as((Base, Id), "id")\n        .tbl_col_as((Base, Name), "name")\n        .column_as(product_type::Column::Name, "type")\n        .column_as(ProdCol::Price, "price")\n        .column_as(ProdCol::LotSize, "lot_size")\n        .column_as(ProdCol::DateAdded, "date_added")\n        .column_as(ProdCol::LastModified, "last_modified")\n        .join_as(JoinType::InnerJoin, ProdRel::BaseProduct.def(), Base)\n        .join(JoinType::InnerJoin, base_product::Relation::ProductType.def().from_alias(Base))\n        .order_by_asc(Expr::col((Base, Id)))\n}\n')),(0,o.kt)("p",null,"Our query starts from ",(0,o.kt)("inlineCode",{parentName:"p"},"ComplexProduct"),". We join back to ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseProduct"),", alias it as ",(0,o.kt)("inlineCode",{parentName:"p"},"Base"),". We then join to ",(0,o.kt)("inlineCode",{parentName:"p"},"ProductType")," via ",(0,o.kt)("inlineCode",{parentName:"p"},"Base"),"."),(0,o.kt)("h3",{id:"custom-join-conditions"},"Custom join conditions"),(0,o.kt)("p",null,"You can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"join")," method to construct complex joins in select queries. It takes any ",(0,o.kt)("inlineCode",{parentName:"p"},"RelationDef"),", and you can further customize the join conditions. Below is an illustration (albeit it's from the Bakery schema):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use sea_orm::{JoinType, RelationTrait};\nuse sea_query::Expr;\n\nassert_eq!(\n    cake::Entity::find()\n        .column_as(filling::Column::Id.count(), "count")\n        .column_as(\n            Expr::col((Alias::new("fruit_alias"), fruit::Column::Name)).into_simple_expr(),\n            "fruit_name"\n        )\n        // construct `RelationDef` on the fly\n        .join_rev(\n            JoinType::InnerJoin,\n            cake_filling::Entity::belongs_to(cake::Entity)\n                .from(cake_filling::Column::CakeId)\n                .to(cake::Column::Id)\n                .into()\n        )\n        // reuse a `Relation` from existing Entity\n        .join(JoinType::InnerJoin, cake_filling::Relation::Filling.def())\n        // join with table alias and custom on condition\n        .join_as(\n            JoinType::LeftJoin,\n            cake::Relation::Fruit\n                .def()\n                .on_condition(|_left, right| {\n                    Expr::col((right, fruit::Column::Name))\n                        .like("%tropical%")\n                        .into_condition()\n                }),\n            Alias::new("fruit_alias")\n        )\n        .group_by(cake::Column::Id)\n        .having(filling::Column::Id.count().equals(Expr::value(2)))\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id`, `cake`.`name`, COUNT(`filling`.`id`) AS `count`, `fruit_alias`.`name` AS `fruit_name` FROM `cake`",\n        "INNER JOIN `cake_filling` ON `cake_filling`.`cake_id` = `cake`.`id`",\n        "INNER JOIN `filling` ON `cake_filling`.`filling_id` = `filling`.`id`",\n        "LEFT JOIN `fruit` AS `fruit_alias` ON `cake`.`id` = `fruit_alias`.`cake_id` AND `fruit_alias`.`name` LIKE \'%tropical%\'",\n        "GROUP BY `cake`.`id`",\n        "HAVING COUNT(`filling`.`id`) = 2",\n    ]\n    .join(" ")\n);\n')),(0,o.kt)("h2",{id:"4-filter-conditions"},"4. Filter Conditions"),(0,o.kt)("p",null,"Suppose we support the following query parameters on the API:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"\n#[derive(Default, Deserialize)]\npub struct Query {\n    #[serde(default)]\n    pub id: Vec<i64>,\n    pub name: Option<String>,\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn condition(query: Query) -> Condition {\n    Condition::all()\n        .add_option(if !query.id.is_empty() {\n            Some(Expr::col((Base, Id)).is_in(query.id))\n        } else { None })\n        .add_option(if let Some(name) = &query.name {\n            Some(Expr::col((Base, Name)).like(name))\n        } else { None })\n}\n")),(0,o.kt)("p",null,"Bonus tip: if you're only using Postgres you can replace ",(0,o.kt)("inlineCode",{parentName:"p"},"is_in")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"any"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use sea_orm::sea_query::extension::postgres::PgFunc;\n\nExpr::col((Base, Id)).eq(PgFunc::any(query.id)) // WHERE base.id = ANY($N)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let products = query()\n    .filter(condition(q))\n    .into_model::<ComplexProduct>()\n    .all(db)\n    .await?;\n")),(0,o.kt)("h2",{id:"5-extra-associated-models"},"5. Extra: associated models"),(0,o.kt)("p",null,"Now, suppose we have a data structure associated with each ",(0,o.kt)("inlineCode",{parentName:"p"},"BaseProduct")," recording its history:"),(0,o.kt)("h4",{id:"producthistory"},(0,o.kt)("inlineCode",{parentName:"h4"},"ProductHistory")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]\n#[sea_orm(table_name = "product_history")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[serde(skip)]\n    pub id: i32,\n    pub product_id: i64,\n    pub from: DateTime,\n    pub until: DateTime,\n    pub name: Option<String>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n')),(0,o.kt)("p",null,"Let's make a helper function to query the histories associated to a set of products:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn history_of(ids: Vec<i64>) -> Select<product_history::Entity> {\n    product_history::Entity::find()\n        .filter(Expr::col(product_history::Column::ProductId).is_in(ids))\n        .order_by_asc(product_history::Column::Id)\n}\n\nlet histories = history_of(products.iter().map(|s| s.id).collect::<Vec<_>>())\n    .all(db)\n    .await?;\n")),(0,o.kt)("p",null,"The final step is to associate ",(0,o.kt)("inlineCode",{parentName:"p"},"product_history::Model")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"ComplexProduct"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn associate(\n    mut parent: Vec<ComplexProduct>,\n    children: Vec<product_history::Model>,\n) -> Vec<ComplexProduct> {\n    let len = parent.len();\n    parent.dedup_by_key(|s| s.id);\n    if len != parent.len() {\n        warn!("parent is not unique.");\n    }\n\n    let parent_id_map: HashMap<i64, usize> = parent\n        .iter()\n        .enumerate()\n        .map(|(i, s)| (s.id, i))\n        .collect();\n\n    // put children into associated parent\n    for item in children {\n        if let Some(index) = parent_id_map.get(&item.product_id) {\n            parent[*index].history.push(item);\n        }\n    }\n\n    parent\n}\n\nlet products = associate(products, histories);\n')),(0,o.kt)("p",null,'This is sometimes called "data loader" pattern, and can be generalized with generics to work with any model.'))}p.isMDXComponent=!0}}]);