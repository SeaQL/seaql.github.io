"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[67397],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}},68010:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"write-test/sqlite","title":"Using SQLite","description":"If you want to test high level application domain logic that\'s not tied to database specific features, you can use SQLite in integration tests.","source":"@site/docs/07-write-test/03-sqlite.md","sourceDirName":"07-write-test","slug":"/write-test/sqlite","permalink":"/SeaORM/docs/write-test/sqlite","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/07-write-test/03-sqlite.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1759961829000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Mock Interface","permalink":"/SeaORM/docs/write-test/mock"},"next":{"title":"Custom Select","permalink":"/SeaORM/docs/advanced-query/custom-select"}}');var a=n(74848),i=n(28453);const r={},o="Using SQLite",l={},c=[{value:"Integration Test",id:"integration-test",level:2},{value:"Setup database schema",id:"setup-database-schema",level:2},{value:"Performing tests",id:"performing-tests",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"using-sqlite",children:"Using SQLite"})}),"\n",(0,a.jsx)(t.p,{children:"If you want to test high level application domain logic that's not tied to database specific features, you can use SQLite in integration tests."}),"\n",(0,a.jsx)(t.p,{children:"Of course, it is not a substitute to integration testing against the target database, but a supplement: SQLite runs in memory, and is quick to run and easy to write tests. You don't have to setup Docker container for executing them, so you can have more comprehensive tests on every layer of the application."}),"\n",(0,a.jsxs)(t.p,{children:["Check out a simple example ",(0,a.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/tests/basic.rs",children:"here"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"integration-test",children:"Integration Test"}),"\n",(0,a.jsxs)(t.p,{children:["It is recommended to execute more complex test cases in ",(0,a.jsx)(t.a,{href:"https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html",children:"integration tests"}),". The following code snippet illustrates the steps of connecting to a database, setting up schema and performing tests."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'async fn main() -> Result<(), DbErr> {\n    // Connecting SQLite\n    let db = Database::connect("sqlite::memory:").await?;\n\n    // Setup database schema\n    setup_schema(&db).await?;\n\n    // Performing tests\n    testcase(&db).await?;\n\n    Ok(())\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"setup-database-schema",children:"Setup database schema"}),"\n",(0,a.jsxs)(t.p,{children:["To create tables in SQLite database for testing, instead of writing ",(0,a.jsx)(t.a,{href:"https://docs.rs/sea-query/*/sea_query/table/struct.TableCreateStatement.html",children:(0,a.jsx)(t.code,{children:"TableCreateStatement"})})," manually, you can derive it from ",(0,a.jsx)(t.code,{children:"Entity"})," using ",(0,a.jsx)(t.a,{href:"https://docs.rs/sea-orm/*/sea_orm/schema/struct.Schema.html#method.create_table_from_entity",children:(0,a.jsx)(t.code,{children:"Schema::create_table_from_entity"})}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"async fn setup_schema(db: &DbConn) {\n\n    // Setup Schema helper\n    let schema = Schema::new(DbBackend::Sqlite);\n\n    // Derive from Entity\n    let stmt: TableCreateStatement = schema.create_table_from_entity(MyEntity);\n\n    // Or write DDL manually\n    assert_eq!(\n        stmt.build(SqliteQueryBuilder),\n        Table::create()\n            .table(MyEntity)\n            .col(integer(MyEntity::Column::Id))\n            //...\n            .build(SqliteQueryBuilder)\n    );\n\n    // Execute create table statement\n    let result = db.execute(&stmt).await;\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"performing-tests",children:"Performing tests"}),"\n",(0,a.jsx)(t.p,{children:"Execute test cases and assert against the results. Here is a simple function that demonstrates the whole setup neatly:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'#[tokio::test]\nasync fn main() {\n    // create in memory database\n    let db = &Database::connect("sqlite::memory:").await.unwrap();\n\n    // setup schema\n    db.execute(\n        &Schema::new(db.get_database_backend())\n            .create_table_from_entity(post::Entity)\n    )\n    .await\n    .unwrap();\n\n    // this is your application request handler\n    let post = Mutation::create_post(\n        db,\n        post::Model {\n            id: 0,\n            title: "Title A".to_owned(),\n            text: "Text A".to_owned(),\n        },\n    )\n    .await\n    .unwrap();\n\n    assert_eq!(\n        post,\n        post::ActiveModel {\n            id: sea_orm::ActiveValue::Unchanged(1),\n            title: sea_orm::ActiveValue::Unchanged("Title A".to_owned()),\n            text: sea_orm::ActiveValue::Unchanged("Text A".to_owned())\n        }\n    );\n\n    let post = Mutation::create_post(\n        db,\n        post::Model {\n            id: 0,\n            title: "Title B".to_owned(),\n            text: "Text B".to_owned(),\n        },\n    )\n    .await\n    .unwrap();\n\n    assert_eq!(\n        post,\n        post::ActiveModel {\n            id: sea_orm::ActiveValue::Unchanged(2),\n            title: sea_orm::ActiveValue::Unchanged("Title B".to_owned()),\n            text: sea_orm::ActiveValue::Unchanged("Text B".to_owned())\n        }\n    );\n\n    let post = Query::find_post_by_id(db, 1).await.unwrap().unwrap();\n\n    assert_eq!(post.id, 1);\n    assert_eq!(post.title, "Title A");\n\n    let post = Mutation::update_post_by_id(\n        db,\n        1,\n        post::Model {\n            id: 1,\n            title: "New Title A".to_owned(),\n            text: "New Text A".to_owned(),\n        },\n    )\n    .await\n    .unwrap();\n\n    assert_eq!(\n        post,\n        post::Model {\n            id: 1,\n            title: "New Title A".to_owned(),\n            text: "New Text A".to_owned(),\n        }\n    );\n\n    let result = Mutation::delete_post(db, 2).await.unwrap();\n    assert_eq!(result.rows_affected, 1);\n\n    let post = Query::find_post_by_id(db, 2).await.unwrap();\n    assert!(post.is_none());\n\n    let result = Mutation::delete_all_posts(db).await.unwrap();\n    assert_eq!(result.rows_affected, 1);\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Here ",(0,a.jsx)(t.code,{children:"unwrap"})," is used, because in case the test fails, it tells you exactly where."]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);