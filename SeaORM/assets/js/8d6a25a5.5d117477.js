"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[80612],{48859:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>p});var a=t(76687);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=d(t),p=r,y=u["".concat(s,".").concat(p)]||u[p]||c[p]||i;return t?a.createElement(y,o(o({ref:n},m),{},{components:t})):a.createElement(y,o({ref:n},m))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},30403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=t(31308),r=(t(76687),t(48859));const i={},o="Multi Selects",l={unversionedId:"relation/multi-selects",id:"version-1.1.x/relation/multi-selects",title:"Multi Selects",description:"Nested Models",source:"@site/versioned_docs/version-1.1.x/06-relation/09-multi-selects.md",sourceDirName:"06-relation",slug:"/relation/multi-selects",permalink:"/SeaORM/docs/relation/multi-selects",draft:!1,editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/06-relation/09-multi-selects.md",tags:[],version:"1.1.x",lastUpdatedBy:"Chris Tsang",lastUpdatedAt:1741482608,formattedLastUpdatedAt:"Mar 9, 2025",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bakery Schema",permalink:"/SeaORM/docs/relation/bakery-schema"},next:{title:"Robust & Correct",permalink:"/SeaORM/docs/write-test/testing"}},s={},d=[{value:"Nested Models",id:"nested-models",level:2},{value:"Join with alias",id:"join-with-alias",level:3},{value:"Three-way Join",id:"three-way-join",level:2},{value:"Three-Model select",id:"three-model-select",level:2}],m={toc:d};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"multi-selects"},"Multi Selects"),(0,r.kt)("h2",{id:"nested-models"},"Nested Models"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"FromQueryResult")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DerivePartialModel")," macros allows you to nest objects easily, simplifying the construction of complex queries."),(0,r.kt)("p",null,"As a simple first example, we'd like to select ",(0,r.kt)("inlineCode",{parentName:"p"},"Cake")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Bakery"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(FromQueryResult)]\nstruct Cake {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(FromQueryResult)]\nstruct Bakery {\n    #[sea_orm(from_alias = "bakery_id")]\n    id: i32,\n    #[sea_orm(from_alias = "bakery_name")]\n    brand: String,\n}\n\nlet cake: Cake = cake::Entity::find()\n    .select_only()\n    .column(cake::Column::Id)\n    .column(cake::Column::Name)\n    .column_as(bakery::Column::Id, "bakery_id")\n    .column_as(bakery::Column::Name, "bakery_name")\n    .left_join(bakery::Entity)\n    .order_by_asc(cake::Column::Id)\n    .into_model()\n    .one(db)\n    .await?\n    .unwrap();\n\nassert_eq!(\n    cake,\n    Cake {\n        id: 1,\n        name: "Basque cheesecake".to_string(),\n        bakery: Some(Bakery {\n            id: 20,\n            brand: "Super Baker".to_string(),\n        })\n    }\n);\n')),(0,r.kt)("p",null,"Because the tables ",(0,r.kt)("inlineCode",{parentName:"p"},"cake")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bakery")," have some duplicate column names, we'd have to do custom selects. ",(0,r.kt)("inlineCode",{parentName:"p"},"select_only")," here clears the default select list, and we apply aliases with ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.column_as"},(0,r.kt)("inlineCode",{parentName:"a"},"column_as")),". Then, in ",(0,r.kt)("inlineCode",{parentName:"p"},"FromQueryResult")," we use ",(0,r.kt)("inlineCode",{parentName:"p"},"from_alias")," to map the query result back to the nested struct."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/derive.DerivePartialModel.html"},(0,r.kt)("inlineCode",{parentName:"a"},"DerivePartialModel"))," allows you to omit the custom selects and aliases.\nThe previous example can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(DerivePartialModel)] // FromQueryResult is no longer needed\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "bakery::Entity", from_query_result)]\nstruct Bakery {\n    id: i32,\n    #[sea_orm(from_col = "Name")]\n    brand: String,\n}\n\n// same as previous example, but without the custom selects\nlet cake: Cake = cake::Entity::find()\n    .left_join(bakery::Entity)\n    .order_by_asc(cake::Column::Id)\n    .into_partial_model()\n    .one(db)\n    .await?\n    .unwrap();\n')),(0,r.kt)("p",null,"Under the hood, ",(0,r.kt)("inlineCode",{parentName:"p"},"bakery_")," prefix will be added to the column alias in the SQL query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    "cake"."id" AS "id",\n    "cake"."name" AS "name",\n    "bakery"."id" AS "bakery_id",\n    "bakery"."name" AS "bakery_brand"\nFROM "cake"\nLEFT JOIN "bakery" ON "cake"."bakery_id" = "bakery"."id"\nORDER BY "cake"."id" ASC LIMIT 1\n')),(0,r.kt)("h3",{id:"join-with-alias"},"Join with alias"),(0,r.kt)("p",null,"When the same table is joined more than once in the same query, it's necessary to use an alias. You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"alias")," attribute to select columns from an alias."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct CakeFactory {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Factory>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "bakery::Entity", alias = "factory", from_query_result)]\nstruct Factory {\n    id: i32,\n    #[sea_orm(from_col = "name")]\n    plant: String,\n}\n\nlet cake_factory: CakeFactory = cake::Entity::find()\n    .join_as(\n        JoinType::LeftJoin,\n        cake::Relation::Bakery.def(),\n        Alias::new("factory"),\n    )\n    .order_by_asc(cake::Column::Id)\n    .into_partial_model()\n    .one(db)\n    .await?\n    .unwrap();\n')),(0,r.kt)("p",null,"Results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    "cake"."id" AS "id",\n    "cake"."name" AS "name",\n    "factory"."id" AS "bakery_id",\n    "factory"."name" AS "bakery_plant"\nFROM "cake"\nLEFT JOIN "bakery" AS "factory" ON "cake"."bakery_id" = "factory"."id"\nORDER BY "cake"."id" ASC LIMIT 1\n')),(0,r.kt)("h2",{id:"three-way-join"},"Three-way Join"),(0,r.kt)("p",null,"Our join tree starts from Order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Customer\n      -> LineItem -> Cake\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "order::Entity", from_query_result)]\nstruct Order {\n    id: i32,\n    total: Decimal,\n    #[sea_orm(nested)]\n    customer: Customer,\n    #[sea_orm(nested)]\n    line: LineItem,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "customer::Entity", from_query_result)]\nstruct Customer {\n    name: String,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "lineitem::Entity", from_query_result)]\nstruct LineItem {\n    price: Decimal,\n    quantity: i32,\n    #[sea_orm(nested)]\n    cake: Cake,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    name: String,\n}\n\nlet items: Vec<Order> = order::Entity::find()\n    .left_join(customer::Entity)\n    .left_join(lineitem::Entity)\n    .join(JoinType::LeftJoin, lineitem::Relation::Cake.def())\n    .order_by_asc(order::Column::Id)\n    .order_by_asc(lineitem::Column::Id)\n    .into_partial_model()\n    .all(db)\n    .await?;\n\nassert_eq!(\n    items,\n    [\n        Order {\n            id: 101,\n            total: Decimal::from(10),\n            customer: Customer {\n                name: "Bob".to_owned()\n            },\n            line: LineItem {\n                cake: Cake {\n                    name: "Cheesecake".to_owned()\n                },\n                price: Decimal::from(2),\n                quantity: 2,\n            }\n        },\n        ..\n    ]\n);\n')),(0,r.kt)("p",null,"Since Cake is a related Entity of LineItem, not Order, it does not satisfy the trait bound of ",(0,r.kt)("inlineCode",{parentName:"p"},"left_join"),". It is thus necessary to use the more flexible ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," method."),(0,r.kt)("h2",{id:"three-model-select"},"Three-Model select"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Lineitem -> Cake\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(db)\n        .await?;\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"find_also_related")," is based on relations of the first entity.\n",(0,r.kt)("inlineCode",{parentName:"p"},"and_also_related")," is based on relations of the second entity."),(0,r.kt)("p",null,"To do this instead, you can write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Customer\n      -> LineItem\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"order::Entity::find()\n    .find_also_related(customer::Entity)\n    .find_also_related(lineitem::Entity)\n")))}c.isMDXComponent=!0}}]);