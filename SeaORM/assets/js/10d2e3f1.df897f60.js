"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[88897],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var l=i(96540);const t={},a=l.createContext(t);function s(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),l.createElement(a.Provider,{value:n},e.children)}},28752:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"relation/many-to-many","title":"Many to Many","description":"A many-to-many relation is formed by three tables, where two tables are related via a junction table. As an example, a Cake has many Filling and Filling are shared by many Cake via an intermediate entity CakeFilling.","source":"@site/docs/06-relation/03-many-to-many.md","sourceDirName":"06-relation","slug":"/relation/many-to-many","permalink":"/SeaORM/docs/next/relation/many-to-many","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/03-many-to-many.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756725675000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"One to Many","permalink":"/SeaORM/docs/next/relation/one-to-many"},"next":{"title":"Complex Relations","permalink":"/SeaORM/docs/next/relation/complex-relations"}}');var t=i(74848),a=i(28453);const s={},r="Many to Many",o={},d=[{value:"Defining the Relation",id:"defining-the-relation",level:2},{value:"Defining the Inverse Relation",id:"defining-the-inverse-relation",level:2},{value:"Limitation of Codegen",id:"limitation-of-codegen",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"many-to-many",children:"Many to Many"})}),"\n",(0,t.jsxs)(n.p,{children:["A many-to-many relation is formed by three tables, where two tables are related via a junction table. As an example, a ",(0,t.jsx)(n.code,{children:"Cake"})," has many ",(0,t.jsx)(n.code,{children:"Filling"})," and ",(0,t.jsx)(n.code,{children:"Filling"})," are shared by many ",(0,t.jsx)(n.code,{children:"Cake"})," via an intermediate entity ",(0,t.jsx)(n.code,{children:"CakeFilling"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-relation",children:"Defining the Relation"}),"\n",(0,t.jsxs)(n.p,{children:["On the ",(0,t.jsx)(n.code,{children:"Cake"})," entity, implement the ",(0,t.jsx)(n.code,{children:"Related<filling::Entity>"})," trait."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Relation"})," in SeaORM is an arrow: it has ",(0,t.jsx)(n.code,{children:"from"})," and ",(0,t.jsx)(n.code,{children:"to"}),". ",(0,t.jsx)(n.code,{children:"cake_filling::Relation::Cake"})," defines ",(0,t.jsx)(n.code,{children:"CakeFilling -> Cake"}),". Calling ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.RelationDef.html#method.rev",children:(0,t.jsx)(n.code,{children:"rev"})})," reverses it into ",(0,t.jsx)(n.code,{children:"Cake -> CakeFilling"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Chaining this with ",(0,t.jsx)(n.code,{children:"cake_filling::Relation::Filling"})," which defines ",(0,t.jsx)(n.code,{children:"CakeFilling -> Filling"})," resulting in ",(0,t.jsx)(n.code,{children:"Cake -> CakeFilling -> Filling"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'{4,10} title="entity/cake.rs"',children:"impl Related<super::filling::Entity> for Entity {\n    // The final relation is Cake -> CakeFilling -> Filling\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        // The original relation is CakeFilling -> Cake,\n        // after `rev` it becomes Cake -> CakeFilling\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Similarly, on the ",(0,t.jsx)(n.code,{children:"Filling"})," entity, implement the ",(0,t.jsx)(n.code,{children:"Related<cake::Entity>"})," trait. First, join with intermediate table ",(0,t.jsx)(n.code,{children:"via"})," the inverse of ",(0,t.jsx)(n.code,{children:"cake_filling::Relation::Filling"})," relation, then join ",(0,t.jsx)(n.code,{children:"to"})," ",(0,t.jsx)(n.code,{children:"Cake"})," entity  with ",(0,t.jsx)(n.code,{children:"cake_filling::Relation::Cake"})," relation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'{3,7} title="entity/filling.rs"',children:"impl Related<super::cake::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Cake.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Filling.def().rev())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-inverse-relation",children:"Defining the Inverse Relation"}),"\n",(0,t.jsxs)(n.p,{children:["On the ",(0,t.jsx)(n.code,{children:"CakeFilling"})," entity, its ",(0,t.jsx)(n.code,{children:"cake_id"})," attribute is referencing the primary key of ",(0,t.jsx)(n.code,{children:"Cake"})," entity, and its ",(0,t.jsx)(n.code,{children:"filling_id"})," attribute is referencing the primary key of ",(0,t.jsx)(n.code,{children:"Filling"})," entity."]}),"\n",(0,t.jsx)(n.p,{children:"To define the inverse relation:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Add two new variants ",(0,t.jsx)(n.code,{children:"Cake"})," and ",(0,t.jsx)(n.code,{children:"Filling"})," to the ",(0,t.jsx)(n.code,{children:"Relation"})," enum."]}),"\n",(0,t.jsxs)(n.li,{children:["Define both relations with ",(0,t.jsx)(n.code,{children:"Entity::belongs_to()"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="entity/cake_filling.rs"',children:'#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::cake::Entity",\n        from = "Column::CakeId",\n        to = "super::cake::Column::Id"\n    )]\n    Cake,\n    #[sea_orm(\n        belongs_to = "super::filling::Entity",\n        from = "Column::FillingId",\n        to = "super::filling::Column::Id"\n    )]\n    Filling,\n}\n'})}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"It's expanded to:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Cake,\n    Filling,\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Cake => Entity::belongs_to(super::cake::Entity)\n                .from(Column::CakeId)\n                .to(super::cake::Column::Id)\n                .into(),\n            Self::Filling => Entity::belongs_to(super::filling::Entity)\n                .from(Column::FillingId)\n                .to(super::filling::Column::Id)\n                .into(),\n        }\n    }\n}\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"limitation-of-codegen",children:"Limitation of Codegen"}),"\n",(0,t.jsxs)(n.p,{children:["Note that the implementation of ",(0,t.jsx)(n.code,{children:"Related"})," with ",(0,t.jsx)(n.code,{children:"via"})," and ",(0,t.jsx)(n.code,{children:"to"})," methods will not be generated if there exists multiple paths via an intermediate table."]}),"\n",(0,t.jsx)(n.p,{children:"For example, in the schema defined below, there are two paths:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Path 1. ",(0,t.jsx)(n.code,{children:"users <-> users_votes <-> bills"})]}),"\n",(0,t.jsxs)(n.li,{children:["Path 2. ",(0,t.jsx)(n.code,{children:"users <-> users_saved_bills <-> bills"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Therefore, the implementation of ",(0,t.jsx)(n.code,{children:"Related<R>"})," will not be generated."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE users\n(\n  id uuid  PRIMARY KEY  DEFAULT uuid_generate_v1mc(),\n  email TEXT UNIQUE NOT NULL,\n  ...\n);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE bills\n(\n  id uuid  PRIMARY KEY  DEFAULT uuid_generate_v1mc(),\n  ...\n);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE users_votes\n(\n  user_id uuid REFERENCES users (id) ON UPDATE CASCADE ON DELETE CASCADE,\n  bill_id uuid REFERENCES bills (id) ON UPDATE CASCADE ON DELETE CASCADE,\n  vote boolean NOT NULL,\n  CONSTRAINT users_bills_pkey PRIMARY KEY (user_id, bill_id)\n);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE users_saved_bills\n(\n  user_id uuid REFERENCES users (id) ON UPDATE CASCADE ON DELETE CASCADE,\n  bill_id uuid REFERENCES bills (id) ON UPDATE CASCADE ON DELETE CASCADE,\n  CONSTRAINT users_saved_bills_pkey PRIMARY KEY (user_id, bill_id)\n);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);