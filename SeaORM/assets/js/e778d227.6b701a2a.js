"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[40782],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},37337:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"internal-design/diesel","title":"Compare with Diesel","description":"This is an inevitable and controversial topic, and the technical difference between SeaORM and Diesel is already widely discussed. So I\'d like to point out a few design choices we made different deliberately that\'s intended to make working with SeaORM a nicer experience.","source":"@site/docs/12-internal-design/03-diesel.md","sourceDirName":"12-internal-design","slug":"/internal-design/diesel","permalink":"/SeaORM/docs/internal-design/diesel","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/12-internal-design/03-diesel.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1760805209000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Derive Macros","permalink":"/SeaORM/docs/internal-design/derive-macro"},"next":{"title":"Architecture","permalink":"/SeaORM/docs/internal-design/architecture"}}');var s=i(74848),a=i(28453);const r={},l="Compare with Diesel",o={},c=[{value:"Async first",id:"async-first",level:2},{value:"Transaction API",id:"transaction-api",level:3},{value:"Database Backend Generic",id:"database-backend-generic",level:2},{value:"Entity-based Relational Model",id:"entity-based-relational-model",level:2},{value:"Reflection",id:"reflection",level:2},{value:"Utilities included",id:"utilities-included",level:2},{value:"You can go Entity first",id:"you-can-go-entity-first",level:2},{value:"Nested select and other ergonomics",id:"nested-select-and-other-ergonomics",level:2},{value:"Ergononmic raw SQL",id:"ergononmic-raw-sql",level:3},{value:"Compile-time consciousness",id:"compile-time-consciousness",level:2},{value:"Community Adoption",id:"community-adoption",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"compare-with-diesel",children:"Compare with Diesel"})}),"\n",(0,s.jsx)(n.p,{children:"This is an inevitable and controversial topic, and the technical difference between SeaORM and Diesel is already widely discussed. So I'd like to point out a few design choices we made different deliberately that's intended to make working with SeaORM a nicer experience."}),"\n",(0,s.jsx)(n.h2,{id:"async-first",children:"Async first"}),"\n",(0,s.jsxs)(n.p,{children:["SeaORM started out to offer first-class async support. You don't need to bring in a connection pool dependency (e.g. ",(0,s.jsx)(n.code,{children:"r2d2"}),"). We offer many examples for popular web frameworks, they are part of our CI so they never breaks."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/actix_example",children:"Actix Example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/axum_example",children:"Axum Example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/graphql_example",children:"GraphQL Example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/jsonrpsee_example",children:"jsonrpsee Example"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/loco_example",children:"Loco TODO Example"})," / ",(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/loco_starter",children:"Loco REST Starter"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/poem_example",children:"Poem Example"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/rocket_example",children:"Rocket Example"})," / ",(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/rocket_okapi_example",children:"Rocket OpenAPI Example"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/salvo_example",children:"Salvo Example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/tonic_example",children:"Tonic Example"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/examples/seaography_example",children:"Seaography Example (Bakery)"})," / ",(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/seaography/tree/main/examples/sqlite",children:"Seaography Example (Sakila)"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We highly recommend ",(0,s.jsx)(n.a,{href:"https://loco.rs/",children:"Loco.rs"}),'. If you\'re looking for a batteries-included framework, this offers an experience closest to "Ruby on Rails" in Rust.']}),"\n",(0,s.jsx)(n.p,{children:"(Diesel offers limited examples and first-party support to web frameworks)"}),"\n",(0,s.jsx)(n.h3,{id:"transaction-api",children:"Transaction API"}),"\n",(0,s.jsxs)(n.p,{children:["There are pros and cons with closure-based API or ",(0,s.jsx)(n.code,{children:"begin()"})," / ",(0,s.jsx)(n.code,{children:"commit()"})," interface (Aka ",(0,s.jsx)(n.code,{children:"TransactionManager"}),"). SeaORM supports both, but Diesel actively discourages you from using ",(0,s.jsx)(n.code,{children:"begin()"})," / ",(0,s.jsx)(n.code,{children:"commit()"})," API."]}),"\n",(0,s.jsx)(n.p,{children:"So you can do this when you need it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let txn = db.begin().await?;\n\n{\n    let txn = txn.begin().await?;\n\n    {\n        let txn = txn.begin().await?;\n        // this will not be committed\n    }\n\n    // commit nested transaction\n    txn.commit().await?;\n}\n\ntxn.commit().await?;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"database-backend-generic",children:"Database Backend Generic"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM's Entity API is a backend generic facade, it doesn't require a database backend at compile time. (In fact it doesn't even require an async runtime to compile the entities). That means you can design a complex application that uses Postgres in production but have lots of tests written against SQLite."}),"\n",(0,s.jsxs)(n.p,{children:["In fact, this is what ",(0,s.jsx)(n.a,{href:"https://zed.dev/",children:"Zed Editor"})," did with their ",(0,s.jsx)(n.a,{href:"https://github.com/zed-industries/zed/blob/main/crates/collab/README.md",children:"collab"})," API server."]}),"\n",(0,s.jsxs)(n.p,{children:["SeaORM tries to offer abstraction across database features where sensible. Startups can build their products to be database generic. In fact, this how ",(0,s.jsx)(n.a,{href:"https://docs.risingwave.com/get-started/architecture",children:"RisingWave"})," implement their data store to support Postgres, MySQL, and SQLite."]}),"\n",(0,s.jsxs)(n.p,{children:["Diesel offers some capabilities to write code generic to multiple databases ",(0,s.jsx)(n.em,{children:"lately"}),", but you'd still have to manage cross-database differences yourself. But fundamentally, in SeaORM you only compile once: business logic is compiled-once (i.e. not trait based), and the differences are handled with ",(0,s.jsx)(n.code,{children:"match"})," statements in the backend. Compared to Diesel, where code has to be monomorphized once for each backend."]}),"\n",(0,s.jsx)(n.h2,{id:"entity-based-relational-model",children:"Entity-based Relational Model"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM's relational modelling is on a higher level: we consider M-N relation as an atomic unit and can skip the junction table join in many scenarios."}),"\n",(0,s.jsx)(n.p,{children:"Consider our readme example,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// SeaORM\nlet cake_with_filling: Vec<(cake::Model, Option<fruit::Model>)> =\n    Cake::find().find_also_related(Filling).all(db).await?;\n"})}),"\n",(0,s.jsx)(n.p,{children:"To do this in Diesel, you'd need two joins:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Diesel\nlet cake_with_filling: Vec<(Cake, Filling)> =\n    cake::table\n        .inner_join(cake_filling::table.inner_join(filling::table))\n        .select((cake::all_columns, filling::all_columns))\n        .load::<(Cake, Filling)>(conn)?;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following is only possible in SeaORM:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// SeaORM\nlet cake_with_fillings: Vec<(cake::Model, Vec<filling::Model>)> = Cake::find()\n    .find_with_related(Filling) // two joins are performed\n    .all(db) // rows are consolidated by left entity\n    .await?;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reflection",children:"Reflection"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM Model and ActiveModel have some useful reflection capabilities. You can get / set attributes dynamically on runtime."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let mut fruit = fruit::Model { .. };\nfruit.set("name".parse().unwrap(), "orange".into());\nassert_eq!(fruit.name, "orange");\n'})}),"\n",(0,s.jsx)(n.p,{children:"In fact, you can work easily with JSON inputs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let fruit = fruit::ActiveModel::from_json(json!({\n    "name": "Apple",\n}))?;\n\nassert_eq!(\n    fruit,\n    fruit::ActiveModel {\n        id: ActiveValue::NotSet,\n        name: ActiveValue::Set("Apple".to_owned()),\n        cake_id: ActiveValue::NotSet,\n    }\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"(You can't do any reflection in Diesel, in fact, you have to write the struct yourself.)"}),"\n",(0,s.jsx)(n.h2,{id:"utilities-included",children:"Utilities included"}),"\n",(0,s.jsx)(n.p,{children:"For example, SeaORM offers offset based and cursor based pagination out of the box, so you don't have to write your own."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let paginator = Post::find()\n    .order_by_asc(post::Column::Id)\n    .paginate(db, posts_per_page);\nlet num_pages = paginator.num_pages().await?;\nlet posts: Vec<post::Model> = paginator.fetch_page(current_page).await?;\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let mut cursor = post::Entity::find().cursor_by(post::Column::Id);\n\n// Filter paginated result by "post"."id" > 1 AND "post"."id" < 100\ncursor.after(1).before(100);\n\n// Get first 10 rows (order by "post"."id" ASC)\nlet posts: Vec<post::Model> = cursor.first(10).all(db).await?\n'})}),"\n",(0,s.jsx)(n.p,{children:"(Diesel doesn't provide such utilities.)"}),"\n",(0,s.jsx)(n.h2,{id:"you-can-go-entity-first",children:"You can go Entity first"}),"\n",(0,s.jsx)(n.p,{children:"An Entity contains all the essential information about the database schema, so you only have one place to look at, and can use them to setup database schema."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "lineitem")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique_key = "item")]\n    pub order_id: i32,\n    #[sea_orm(unique_key = "item")]\n    pub cake_id: i32,\n}\n\nlet stmts = Schema::new(backend).create_index_from_entity(lineitem::Entity);\n\nassert_eq!(\n    backend.build(stmts[0]),\n    r#"CREATE UNIQUE INDEX "idx-lineitem-item" ON "lineitem" ("order_id", "cake_id")"#\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Trust me, we'll implement automatic migration soon!"}),"\n",(0,s.jsx)(n.p,{children:"(In Diesel it's not possible to go back from schema description to DDL)"}),"\n",(0,s.jsx)(n.h2,{id:"nested-select-and-other-ergonomics",children:"Nested select and other ergonomics"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM 2.0 introduced many new features that's not possible in Diesel."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use sea_orm::DerivePartialModel;\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity")]\nstruct CakeWithFruit {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    fruit: Option<fruit::Model>,\n}\n\nlet cakes: Vec<CakeWithFruit> = Cake::find()\n    .left_join(fruit::Entity) // no need to specify join condition\n    .into_partial_model() // only the columns in the partial model will be selected\n    .all(db)\n    .await?;\n'})}),"\n",(0,s.jsx)(n.p,{children:"SeaORM:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#[derive(DerivePartialModel)]"})," auto\u2011generates the projection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"into_partial_model()"})," selects only the needed columns"]}),"\n",(0,s.jsx)(n.li,{children:"Joins can be inferred from entity relations"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Diesel:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You must explicitly select the columns"}),"\n",(0,s.jsx)(n.li,{children:"You must explicitly map the tuple into your struct"}),"\n",(0,s.jsx)(n.li,{children:'No built\u2011in "partial model" derive'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ergononmic-raw-sql",children:"Ergononmic raw SQL"}),"\n",(0,s.jsx)(n.p,{children:"Raw SQL with parameter expansion is a life-saver when a query is complex enough to require writing it in SQL!"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let item = Item { id: 2 }; // nested parameter access\n\nlet cake_ids = [2, 3, 4]; // expanded by the `..` operator\n\n// can use nested select with raw SQL\nlet cake: Option<CakeWithBakery> = CakeWithBakery::find_by_statement(raw_sql!(\n    Sqlite,\n    r#"SELECT "cake"."name", "bakery"."name" AS "bakery_name"\n       FROM "cake"\n       LEFT JOIN "bakery" ON "cake"."bakery_id" = "bakery"."id"\n       WHERE "cake"."id" = {item.id} OR "cake"."id" IN ({..cake_ids})"#\n))\n.one(db)\n.await?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"compile-time-consciousness",children:"Compile-time consciousness"}),"\n",(0,s.jsx)(n.p,{children:"Why complex schema compiles so slowly in Diesel? Here's a high-level explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Diesel's ",(0,s.jsx)(n.code,{children:"table!"})," macro generates a lot of code: one module per table, one struct per column, traits for joins, etc. This gives you the type\u2011safe query builder, but it means thousands of distinct types are generated under the hood"]}),"\n",(0,s.jsx)(n.li,{children:"Diesel encodes SQL queries into Rust types. That means every query you write produces a unique, deeply nested type. Type inference and trait resolution can get very heavy"}),"\n",(0,s.jsx)(n.li,{children:"Everything has to be in one big crate, so rustc can't parallelize compilation effectively"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The worst part: ",(0,s.jsxs)(n.a,{href:"https://github.com/diesel-rs/diesel/issues/4333",children:[(0,s.jsx)(n.code,{children:"allow_tables_to_appear_in_same_query"})," has O(N^2) complexity"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"allow_tables_to_appear_in_same_query!(users, posts, comments);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Expands to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"allow_tables_to_appear_in_same_query!(users, posts);\nallow_tables_to_appear_in_same_query!(users, comments);\nallow_tables_to_appear_in_same_query!(posts, comments);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you have 100 entities, it expands to ",(0,s.jsx)(n.code,{children:"100 C 2 = 4950"})," which is a binomial expansion."]}),"\n",(0,s.jsx)(n.p,{children:"SeaORM is designed to scale well with complexity and be friendly with incremental compilation."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SeaQuery, the underlying query builder, is a separate crate. While this is a mandatory dependency, it's very lightweight, not generics-heavy and quick to compile"}),"\n",(0,s.jsxs)(n.li,{children:["SeaORM generates a fixed number of structs per entity: ",(0,s.jsx)(n.code,{children:"Entity"}),", ",(0,s.jsx)(n.code,{children:"Model"}),", ",(0,s.jsx)(n.code,{children:"ActiveModel"}),", ",(0,s.jsx)(n.code,{children:"Column"})," and ",(0,s.jsx)(n.code,{children:"PrimaryKey"}),". ",(0,s.jsx)(n.code,{children:"Column"})," is a single enum regardless of number of columns"]}),"\n",(0,s.jsx)(n.li,{children:"SeaORM scales linearly with schema complexity: it is proprotional to the number of entities and relations among them"}),"\n",(0,s.jsx)(n.li,{children:"As mentioned above, SeaORM Entities can be compiled in pure crates. In case you've got a really complex schema, you can simply break them down into multiple crates"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"community-adoption",children:"Community Adoption"}),"\n",(0,s.jsx)(n.p,{children:"The SeaORM team is obsessed on improving documentation, examples and ecosystem integration."}),"\n",(0,s.jsx)(n.p,{children:"We are excited to see real-world applications built by companies and startups using SeaORM. Here's a few, ordered alphabetically:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("a",{href:"https://caido.io/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/caido-logo.png"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://lap.dev/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/lapdev-logo.png"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://mydatamyconsent.com/",children:(0,s.jsx)("img",{style:{width:250},src:"https://www.sea-ql.org/SeaORM/img/other/mydatamyconsent-logo.png"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://openobserve.ai/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/openobserve-logo.svg"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://prefix.dev/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/prefixdev-logo.png"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://qdx.co/",children:(0,s.jsx)("img",{style:{width:80},src:"https://www.sea-ql.org/static/sponsors/QDX.svg"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://risingwave.com/",children:(0,s.jsx)("img",{style:{width:220},src:"https://www.sea-ql.org/SeaORM/img/other/risingwave-logo.svg"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://www.svix.com/",children:(0,s.jsx)("img",{style:{width:180},src:"https://www.sea-ql.org/SeaORM/img/other/svix-logo.svg"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://www.systeminit.com/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/systeminit-logo.png"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://upvpn.app/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/upvpn-logo.png"})}),"\xa0\xa0\xa0\xa0\n",(0,s.jsx)("a",{href:"https://zed.dev/",children:(0,s.jsx)("img",{style:{width:200},src:"https://www.sea-ql.org/SeaORM/img/other/zed-logo.png"})}),"\xa0\xa0\xa0\xa0"]}),"\n",(0,s.jsxs)(n.p,{children:["In fact, SeaORM has 250k weekly downloads on ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/sea-orm",children:"crates.io"}),", most of them happening on weekdays, suggesting that SeaORM is used heavily in professional contexts. This one metric hints that SeaORM has more user activity than Diesel (please take this claim with a grain of salt)."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);