"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[65761],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var l=i(96540);const a={},t=l.createContext(a);function s(e){const n=l.useContext(t);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),l.createElement(t.Provider,{value:n},e.children)}},65055:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"relation/chained-relations","title":"Chained Relations","description":"The Related trait is a representation of the arrows (1-1, 1-N, M-N) we draw on Entity Relationship Diagrams. A Linked is composed of a chain of relations, and is useful when:","source":"@site/versioned_docs/version-0.6.x/07-relation/04-chained-relations.md","sourceDirName":"07-relation","slug":"/relation/chained-relations","permalink":"/SeaORM/docs/0.6.x/relation/chained-relations","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-0.6.x/07-relation/04-chained-relations.md","tags":[],"version":"0.6.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1763071379000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Many to Many","permalink":"/SeaORM/docs/0.6.x/relation/many-to-many"},"next":{"title":"Self Referencing","permalink":"/SeaORM/docs/0.6.x/relation/self-referencing"}}');var a=i(74848),t=i(28453);const s={},o="Chained Relations",r={},d=[{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Eager Loading",id:"eager-loading",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chained-relations",children:"Chained Relations"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Related"})," trait is a representation of the arrows (1-1, 1-N, M-N) we draw on Entity Relationship Diagrams. A ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.6/sea_orm/entity/trait.Linked.html",children:(0,a.jsx)(n.code,{children:"Linked"})})," is composed of a chain of relations, and is useful when:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"there exist multiple join paths between a pair of entities"}),"\n",(0,a.jsx)(n.li,{children:"joining across multiple entities in a relational query"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Take ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/cake.rs",children:"this"})," as a simple example, where we join cake and filling via an intermediate ",(0,a.jsx)(n.code,{children:"cake_filling"})," table."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug)]\npub struct CakeToFilling;\n\nimpl Linked for CakeToFilling {\n    type FromEntity = cake::Entity;\n\n    type ToEntity = filling::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            cake_filling::Relation::Cake.def().rev(),\n            cake_filling::Relation::Filling.def(),\n        ]\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, the ",(0,a.jsx)(n.code,{children:"RelationDef"})," can be defined on the fly, where the following is equivalent to the above:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug)]\npub struct CakeToFilling;\n\nimpl Linked for CakeToFilling {\n    type FromEntity = cake::Entity;\n\n    type ToEntity = filling::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            cake_filling::Relation::Cake.def().rev(),\n            cake_filling::Entity::belongs_to(filling::Entity)\n                .from(cake_filling::Column::FillingId)\n                .to(filling::Column::Id)\n                .into(),\n        ]\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,a.jsxs)(n.p,{children:["Find fillings that can be filled into a cake with the ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.6/sea_orm/entity/prelude/trait.ModelTrait.html#method.find_linked",children:(0,a.jsx)(n.code,{children:"find_linked"})})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let cake_model = cake::Model {\n    id: 12,\n    name: "".to_owned(),\n};\n\nassert_eq!(\n    cake_model\n        .find_linked(cake::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        r#"SELECT `filling`.`id`, `filling`.`name`"#,\n        r#"FROM `filling`"#,\n        r#"INNER JOIN `cake_filling` ON `cake_filling`.`filling_id` = `filling`.`id`"#,\n        r#"INNER JOIN `cake` ON `cake`.`id` = `cake_filling`.`cake_id`"#,\n        r#"WHERE `cake`.`id` = 12"#,\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,a.jsxs)(n.p,{children:["Find all pairs of cake and filling together in a single select with the ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.6/sea_orm/entity/prelude/struct.Select.html#method.find_also_linked",children:(0,a.jsx)(n.code,{children:"find_also_linked"})})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .find_also_linked(cake::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id` AS `A_id`, `cake`.`name` AS `A_name`,",\n        "`filling`.`id` AS `B_id`, `filling`.`name` AS `B_name`",\n        "FROM `cake`",\n        "LEFT JOIN `cake_filling` ON `cake`.`id` = `cake_filling`.`cake_id`",\n        "LEFT JOIN `filling` ON `cake_filling`.`filling_id` = `filling`.`id`",\n    ]\n    .join(" ")\n);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);