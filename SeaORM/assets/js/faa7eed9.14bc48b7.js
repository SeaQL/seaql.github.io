"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[1040],{26115:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"basic-crud/select","title":"Select","description":"Once you have defined the entity, you are ready to retrieve data from the database. Each row of data in the database corresponds to a Model.","source":"@site/docs/05-basic-crud/02-select.md","sourceDirName":"05-basic-crud","slug":"/basic-crud/select","permalink":"/SeaORM/docs/basic-crud/select","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/05-basic-crud/02-select.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1772389428000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Basic Schema","permalink":"/SeaORM/docs/basic-crud/basic-schema"},"next":{"title":"ActiveModel","permalink":"/SeaORM/docs/basic-crud/active-model"}}');var i=a(74848),r=a(28453);const s={},o="Select",d={},l=[{value:"Find by Primary Key",id:"find-by-primary-key",level:2},{value:"Find with Conditions and Orders",id:"find-with-conditions-and-orders",level:2},{value:"Strongly-Typed COLUMN Constant",id:"strongly-typed-column-constant",level:3},{value:"Find by Unique Key",id:"find-by-unique-key",level:2},{value:"Find Related Models",id:"find-related-models",level:2},{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Eager Loading",id:"eager-loading",level:3},{value:"One to One",id:"one-to-one",level:4},{value:"One to Many / Many to Many",id:"one-to-many--many-to-many",level:4},{value:"Entity Loader",id:"entity-loader",level:3},{value:"Model Loader",id:"model-loader",level:3},{value:"One to One",id:"one-to-one-1",level:4},{value:"One to Many",id:"one-to-many",level:4},{value:"Many to Many",id:"many-to-many",level:4},{value:"Paginate Result",id:"paginate-result",level:2},{value:"Cursor Pagination",id:"cursor-pagination",level:2},{value:"Select Partial Model",id:"select-partial-model",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"select",children:"Select"})}),"\n",(0,i.jsxs)(n.p,{children:["Once you have defined the entity, you are ready to retrieve data from the database. Each row of data in the database corresponds to a ",(0,i.jsx)(n.code,{children:"Model"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, SeaORM will select all columns defined in the ",(0,i.jsx)(n.code,{children:"Column"})," enum."]}),"\n",(0,i.jsx)(n.h2,{id:"find-by-primary-key",children:"Find by Primary Key"}),"\n",(0,i.jsxs)(n.p,{children:["Find a model by its primary key, it can be a single key or composite key. We start by calling ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/entity/trait.EntityTrait.html#method.find_by_id",children:(0,i.jsx)(n.code,{children:"find_by_id"})})," on ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/entity/trait.EntityTrait.html",children:(0,i.jsx)(n.code,{children:"Entity"})})," which helps you construct the select query and condition automatically. Then, fetch a single model from the database with the ",(0,i.jsx)(n.code,{children:"one"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use super::cake::Entity as Cake;\nuse super::cake_filling::Entity as CakeFilling;\n\n// Find by primary key\nlet cheese: Option<cake::Model> = Cake::find_by_id(1).one(db).await?;\n\n// Find by composite primary keys\nlet vanilla: Option<cake_filling::Model> = CakeFilling::find_by_id((6, 8)).one(db).await?;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"find-with-conditions-and-orders",children:"Find with Conditions and Orders"}),"\n",(0,i.jsxs)(n.p,{children:["In addition to retrieving a model by primary key, you can also retrieve one or more models matching specific conditions in a certain order. The ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/entity/trait.EntityTrait.html#method.find",children:(0,i.jsx)(n.code,{children:"find"})})," method gives you access to the query builder in SeaORM. It supports the construction of all common select expressions like ",(0,i.jsx)(n.code,{children:"where"})," and ",(0,i.jsx)(n.code,{children:"order by"}),". They can be constructed using ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.QueryFilter.html#method.filter",children:(0,i.jsx)(n.code,{children:"filter"})})," and ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.QueryOrder.html#method.order_by",children:(0,i.jsx)(n.code,{children:"order_by_*"})})," methods respectively."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Read more about ",(0,i.jsx)(n.a,{href:"/SeaORM/docs/advanced-query/conditional-expression",children:"conditional expression"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let chocolate: Vec<cake::Model> = Cake::find()\n    .filter(cake::Column::Name.contains("chocolate"))\n    .order_by_asc(cake::Column::Name)\n    .all(db)\n    .await?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"strongly-typed-column-constant",children:"Strongly-Typed COLUMN Constant"}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,i.jsx)(n.code,{children:"2.0.0"})]}),(0,i.jsxs)(n.p,{children:["Requires ",(0,i.jsx)(n.code,{children:"#[sea_orm::model]"})," or ",(0,i.jsx)(n.code,{children:"#[sea_orm::compact_model]"}),"."]})]}),"\n",(0,i.jsxs)(n.p,{children:["SeaORM 2.0 generates a ",(0,i.jsx)(n.code,{children:"COLUMN"})," constant with type-aware methods per column. Instead of using the ",(0,i.jsx)(n.code,{children:"Column"})," enum (which accepts any value type), use ",(0,i.jsx)(n.code,{children:"COLUMN"})," for compile-time type checking:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Column enum: compiles even if the type is wrong\ncake::Column::Name.contains("chocolate")\n\n// COLUMN constant: type-checked, lowercase field names\ncake::COLUMN.name.contains("chocolate")\n\n// compile error: `like` expects a string, not an integer\ncake::COLUMN.name.like(2)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Each column is wrapped in a type-specific struct (",(0,i.jsx)(n.code,{children:"StringColumn"}),", ",(0,i.jsx)(n.code,{children:"NumericColumn"}),", ",(0,i.jsx)(n.code,{children:"DateLikeColumn"}),", etc.) that exposes only methods relevant to that type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"user::COLUMN.name.contains(\"Bob\")           // StringColumn: LIKE '%Bob%'\nuser::COLUMN.id.between(1, 100)             // NumericColumn\nuser::COLUMN.created_at.gt(some_date)       // DateTimeLikeColumn\ncollection::COLUMN.tags.contains(vec![\"a\"]) // ArrayColumn: @> ARRAY['a']\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"COLUMN"})," constant is also accessible as ",(0,i.jsx)(n.code,{children:"Entity::COLUMN"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'user::Entity::find().filter(user::Entity::COLUMN.name.contains("Bob"))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"find-by-unique-key",children:"Find by Unique Key"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,i.jsx)(n.code,{children:"2.0.0"})]})}),"\n",(0,i.jsxs)(n.p,{children:["If an entity has a ",(0,i.jsx)(n.code,{children:"#[sea_orm(unique)]"})," attribute, SeaORM generates ",(0,i.jsx)(n.code,{children:"find_by_*"})," and ",(0,i.jsx)(n.code,{children:"filter_by_*"})," convenience methods:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "user")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)]\n    pub email: String,\n    ..\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let bob = user::Entity::find_by_email("bob@sea-ql.org").one(db).await?;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For composite unique keys defined with ",(0,i.jsx)(n.code,{children:'#[sea_orm(unique_key = "pair")]'}),", a ",(0,i.jsx)(n.code,{children:"find_by_pair"})," method is generated:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let item = composite_a::Entity::find_by_pair((1, 2)).one(db).await?;\n"})}),"\n",(0,i.jsx)(n.p,{children:"These methods are also available on the Entity Loader:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let bob = user::Entity::load()\n    .filter_by_email("bob@sea-ql.org")\n    .with(profile::Entity)\n    .one(db)\n    .await?;\n'})}),"\n",(0,i.jsx)(n.h2,{id:"find-related-models",children:"Find Related Models"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Read more on the ",(0,i.jsx)(n.a,{href:"/SeaORM/docs/relation/one-to-one",children:"Relation"})," chapter."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/entity/trait.ModelTrait.html#method.find_related",children:(0,i.jsx)(n.code,{children:"find_related"})})," method."]}),"\n",(0,i.jsx)(n.p,{children:"Related models are loaded on demand when you ask for them, preferable if you want to load related models based on some application logic. Note that lazy loading will increase database round trips compared to eager loading."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Find a cake model first\nlet cheese: Option<cake::Model> = Cake::find_by_id(1).one(db).await?;\nlet cheese: cake::Model = cheese.unwrap();\n\n// Then, find all related fruits of this cake\nlet fruits: Vec<fruit::Model> = cheese.find_related(Fruit).all(db).await?;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,i.jsx)(n.p,{children:"All related models are loaded in the same query with join."}),"\n",(0,i.jsx)(n.h4,{id:"one-to-one",children:"One to One"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/struct.Select.html#method.find_also_related",children:(0,i.jsx)(n.code,{children:"find_also_related"})})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fruits_and_cakes: Vec<(fruit::Model, Option<cake::Model>)> = Fruit::find().find_also_related(Cake).all(db).await?;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"one-to-many--many-to-many",children:"One to Many / Many to Many"}),"\n",(0,i.jsxs)(n.p,{children:["Using the ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/struct.Select.html#method.find_with_related",children:(0,i.jsx)(n.code,{children:"find_with_related"})})," method, the related models will be grouped by the parent models. This method handles both 1-N and M-N cases, and will perform 2 joins when there is a junction table involved."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let cake_with_fruits: Vec<(cake::Model, Vec<fruit::Model>)> = Cake::find()\n    .find_with_related(Fruit)\n    .all(db)\n    .await?;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"entity-loader",children:"Entity Loader"}),"\n",(0,i.jsxs)(n.p,{children:["You can load related Entities into a nested struct called ",(0,i.jsx)(n.code,{children:"ModelEx"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,i.jsx)(n.code,{children:"2.0.0"})]}),(0,i.jsxs)(n.p,{children:["This requires the ",(0,i.jsx)(n.code,{children:"#[sea_orm::model]"})," or ",(0,i.jsx)(n.code,{children:"#[sea_orm::compact_model]"})," macro on entity definition. Learn more ",(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-10-20-sea-orm-2.0/",children:"here"}),"."]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// join paths:\n// cake -> fruit\n// cake -> cake_filling -> filling\n\nlet super_cake = cake::Entity::load()\n    .with(fruit::Entity) // 1-1 uses join\n    .with(filling::Entity) // M-N uses data loader\n    .one(db)\n    .await?\n    .unwrap();\n\nsuper_cake\n    == cake::ModelEx {\n        id: 12,\n        name: "Black Forest".into(),\n        fruit: Some(fruit::ModelEx {\n            name: "Cherry".into(),\n        }.into()),\n        fillings: vec![filling::ModelEx {\n            name: "Chocolate".into(),\n        }],\n    };\n'})}),"\n",(0,i.jsx)(n.h3,{id:"model-loader",children:"Model Loader"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.LoaderTrait.html",children:"LoaderTrait"})," to load related entities in batches."]}),"\n",(0,i.jsx)(n.p,{children:"Compared to eager loading, it saves bandwidth (consider the one to many case, the one side rows may duplicate) at the cost of one more database query."}),"\n",(0,i.jsx)(n.h4,{id:"one-to-one-1",children:"One to One"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.LoaderTrait.html#tymethod.load_one",children:"load_one"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fruits: Vec<fruit::Model> = Fruit::find().all(db).await?;\nlet cakes: Vec<Option<cake::Model>> = fruits.load_one(Cake, db).await?;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"one-to-many",children:"One to Many"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.LoaderTrait.html#tymethod.load_many",children:"load_many"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let cakes: Vec<cake::Model> = Cake::find().all(db).await?;\nlet fruits: Vec<Vec<fruit::Model>> = cakes.load_many(Fruit, db).await?;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"many-to-many",children:"Many to Many"}),"\n",(0,i.jsxs)(n.p,{children:["Use the same ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.LoaderTrait.html#tymethod.load_many",children:"load_many"})," method."]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,i.jsx)(n.code,{children:"2.0.0"})]}),(0,i.jsx)(n.p,{children:"You don't have to provide the junction Entity. It's where SeaORM shines!"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let cakes: Vec<cake::Model> = Cake::find().all(db).await?;\nlet fillings: Vec<Vec<filling::Model>> = cakes.load_many(Filling, db).await?;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"paginate-result",children:"Paginate Result"}),"\n",(0,i.jsxs)(n.p,{children:["Convert any SeaORM select into a ",(0,i.jsx)(n.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/struct.Paginator.html",children:"paginator"})," with custom page size."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{entity::*, query::*, tests_cfg::cake};\nlet mut cake_pages = cake::Entity::find()\n    .order_by_asc(cake::Column::Id)\n    .paginate(db, 50);\n \nwhile let Some(cakes) = cake_pages.fetch_and_next().await? {\n    // Do something on cakes: Vec<cake::Model>\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cursor-pagination",children:"Cursor Pagination"}),"\n",(0,i.jsx)(n.p,{children:"Use cursor pagination If you want to paginate rows based on column(s) such as the primary key."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{entity::*, query::*, tests_cfg::cake};\n// Create a cursor that order by `cake`.`id`\nlet mut cursor = cake::Entity::find().cursor_by(cake::Column::Id);\n\n// Filter paginated result by `cake`.`id` > 1 AND `cake`.`id` < 100\ncursor.after(1).before(100);\n\n// Get first 10 rows (order by `cake`.`id` ASC)\nfor cake in cursor.first(10).all(db).await? {\n    // Do something on cake: cake::Model\n}\n\n// Get last 10 rows (order by `cake`.`id` DESC but rows are returned in ascending order)\nfor cake in cursor.last(10).all(db).await? {\n    // Do something on cake: cake::Model\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Paginate rows based on a composite primary keys are also supported."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{entity::*, query::*, tests_cfg::cake_filling};\nlet rows = cake_filling::Entity::find()\n    .cursor_by((cake_filling::Column::CakeId, cake_filling::Column::FillingId))\n    .after((0, 1))\n    .before((10, 11))\n    .first(3)\n    .all(&db)\n    .await?;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"select-partial-model",children:"Select Partial Model"}),"\n",(0,i.jsx)(n.p,{children:"If you want to select just a subset of columns, you can define a Partial Model."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use sea_orm::DerivePartialModel;\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity")]\nstruct CakeWithFruit {\n    name: String,\n    #[sea_orm(nested)]\n    fruit: Option<fruit::Model>, // this can be a regular or another partial model\n}\n\nlet cakes: Vec<CakeWithFruit> = Cake::find()\n    .left_join(fruit::Entity)\n    .into_partial_model() // only the columns in the partial model will be selected\n    .all(db)\n    .await?;\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var t=a(96540);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);