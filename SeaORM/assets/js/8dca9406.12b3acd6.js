"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[85182],{27636:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"relation/multi-selects","title":"Multi Selects","description":"In the previous chapter, we used partial models for querying multiple entities together. We can achieve the same using the multi-select API.","source":"@site/docs/06-relation/10-multi-selects.md","sourceDirName":"06-relation","slug":"/relation/multi-selects","permalink":"/SeaORM/docs/relation/multi-selects","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/10-multi-selects.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1760805209000,"sidebarPosition":10,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Nested Selects","permalink":"/SeaORM/docs/relation/nested-selects"},"next":{"title":"Relational Query","permalink":"/SeaORM/docs/relation/relational-query"}}');var l=t(74848),o=t(28453);const r={},s="Multi Selects",a={},d=[{value:"Select Three Models",id:"select-three-models",level:2},{value:"Consolidate results",id:"consolidate-results",level:3},{value:"Chain",id:"chain",level:4},{value:"Star",id:"star",level:4},{value:"Select up to six Models",id:"select-up-to-six-models",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"multi-selects",children:"Multi Selects"})}),"\n",(0,l.jsx)(n.p,{children:"In the previous chapter, we used partial models for querying multiple entities together. We can achieve the same using the multi-select API."}),"\n",(0,l.jsx)(n.h2,{id:"select-three-models",children:"Select Three Models"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"Order -> LineItem -> Cake\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .all(db)\n        .await?;\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"find_also_related"})," is based on relations of the first entity.\n",(0,l.jsx)(n.code,{children:"and_also_related"})," is based on relations of the second entity."]}),"\n",(0,l.jsx)(n.p,{children:"To have a different join topology, you can write:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"Order -> Customer\n      -> LineItem\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"order::Entity::find()\n    .find_also_related(customer::Entity)\n    .find_also_related(lineitem::Entity)\n"})}),"\n",(0,l.jsx)(n.h3,{id:"consolidate-results",children:"Consolidate results"}),"\n",(0,l.jsx)(n.p,{children:"You can consolidate query results on three model selects. The output has different shape depending on the topology of the join."}),"\n",(0,l.jsx)(n.admonition,{type:"tip",children:(0,l.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,l.jsx)(n.code,{children:"2.0.0"})]})}),"\n",(0,l.jsx)(n.h4,{id:"chain",children:"Chain"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"Order -> LineItem -> Cake\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(&ctx.db)\n        .await?;\n\n// flat result\nassert_eq!(\n    items,\n    vec![\n        (order, Some(line_1), Some(cake_1)),\n        (order, Some(line_2), Some(cake_2)),\n    ]\n);\n\nlet items: Vec<(order::Model, Vec<(lineitem::Model, Vec<cake::Model>)>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .consolidate() // <-\n        .all(&ctx.db)\n        .await?;\n\n// consolidated by order first, then by line\nassert_eq!(\n    items,\n    vec![(\n        order,\n        vec![(line_1, vec![cake_1]), (line_2, vec![cake_2])]\n    )]\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:"It can comprise two one-to-many relations. For example,"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"vec![\n    (bakery, Some(baker_1), Some(cake_1)),\n    (bakery, Some(baker_1), Some(cake_2)),\n    (bakery, Some(baker_2), Some(cake_3)),\n]\n// would be consolidated into:\nvec![(\n    bakery,\n    vec![\n        (baker_1, vec![cake_1, cake_2]),\n        (baker_2, vec![cake_3]),\n    ]\n)]\n"})}),"\n",(0,l.jsx)(n.h4,{id:"star",children:"Star"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"Order -> Customer\n      -> LineItem\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let items: Vec<(order::Model, Option<customer::Model>, Option<lineitem::Model>)> =\n    order::Entity::find()\n        .find_also_related(customer::Entity)\n        .find_also_related(lineitem::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(&ctx.db)\n        .await?;\n\n// flat result\nassert_eq!(\n    items,\n    vec![\n        (order, Some(customer), Some(line_1)),\n        (order, Some(customer), Some(line_2)),\n    ]\n);\n\nlet items: Vec<(order::Model, Vec<customer::Model>, Vec<lineitem::Model>)> =\n    order::Entity::find()\n        .find_also_related(customer::Entity)\n        .find_also_related(lineitem::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .consolidate() // <-\n        .all(&ctx.db)\n        .await?;\n\n// consolidated by order\nassert_eq!(\n    items,\n    vec![(\n        order,\n        vec![customer],\n        vec![line_1, line_2]\n    )]\n);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"select-up-to-six-models",children:"Select up to six Models"}),"\n",(0,l.jsx)(n.admonition,{type:"tip",children:(0,l.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,l.jsx)(n.code,{children:"2.0.0"})]})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// join paths:\n// one -> two -> three -> four -> five\n// one -> six\nlet (one, two, three, four, five, six) = one::Entity::find()\n    //         from entity -> to entity\n    .find_also(one::Entity,   two::Entity)   // same as .find_also_related(two::Entity)\n    .find_also(two::Entity,   three::Entity) // same as .and_also_related(three::Entity)\n    .find_also(three::Entity, four::Entity)\n    .find_also(four::Entity,  five::Entity)\n    .find_also(one::Entity,   six::Entity)\n    .one(db)\n    .await?\n    .unwrap();\n"})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(96540);const l={},o=i.createContext(l);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);