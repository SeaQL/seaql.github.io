"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[5638],{77162:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(22374);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},80721:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"generate-entity/expanded-entity-structure","title":"Expanded Entity Structure","description":"SeaORM is dynamic, which means you have the flexibility to configure things on runtime. If you are curious what DeriveEntityModel expands into, read along. Otherwise, you can skip this for now.","source":"@site/versioned_docs/version-1.0.x/04-generate-entity/03-expanded-entity-structure.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/expanded-entity-structure","permalink":"/SeaORM/docs/1.0.x/generate-entity/expanded-entity-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.0.x/04-generate-entity/03-expanded-entity-structure.md","tags":[],"version":"1.0.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1749059591000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Entity Structure","permalink":"/SeaORM/docs/1.0.x/generate-entity/entity-structure"},"next":{"title":"Enumeration","permalink":"/SeaORM/docs/1.0.x/generate-entity/enumeration"}}');var r=t(88790),a=t(77162);const s={},l="Expanded Entity Structure",o={},d=[{value:"Entity",id:"entity",level:2},{value:"Column",id:"column",level:2},{value:"Additional properties",id:"additional-properties",level:3},{value:"Cast Column Type on Select and Save",id:"cast-column-type-on-select-and-save",level:3},{value:"Primary Key",id:"primary-key",level:2},{value:"Model",id:"model",level:2},{value:"Nullable Attribute",id:"nullable-attribute",level:3},{value:"Active Model",id:"active-model",level:2},{value:"Relation",id:"relation",level:2},{value:"Related",id:"related",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"expanded-entity-structure",children:"Expanded Entity Structure"})}),"\n",(0,r.jsxs)(n.p,{children:["SeaORM is dynamic, which means you have the flexibility to configure things on runtime. If you are curious what ",(0,r.jsx)(n.code,{children:"DeriveEntityModel"})," expands into, read along. Otherwise, you can skip this for now."]}),"\n",(0,r.jsxs)(n.p,{children:["The expanded entity format can be generated by ",(0,r.jsx)(n.code,{children:"sea-orm-cli"})," with the ",(0,r.jsx)(n.code,{children:"--expanded-format"})," option."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's go through the sections of the expanded ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/cake_expanded.rs",children:"Cake"})," entity."]}),"\n",(0,r.jsx)(n.h2,{id:"entity",children:"Entity"}),"\n",(0,r.jsxs)(n.p,{children:["By implementing the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.EntityTrait.html",children:(0,r.jsx)(n.code,{children:"EntityTrait"})}),", you can perform CRUD operations on the given table."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn schema_name(&self) -> Option<&str> {\n        None\n    }\n\n    fn table_name(&self) -> &str {\n        "cake"\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"column",children:"Column"}),"\n",(0,r.jsx)(n.p,{children:"An enum representing all columns in this table."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Name,\n}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Name => ColumnType::String(None).def(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["All column names are assumed to be in snake-case. You can override the column name by specifying the ",(0,r.jsx)(n.code,{children:"column_name"})," attribute."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub enum Column {\n    Id,      // maps to "id" in SQL\n    Name,    // maps to "name" in SQL\n    #[sea_orm(column_name = "create_at")]\n    CreateAt // maps to "create_at" in SQL\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To specify the datatype of each column, the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/enum.ColumnType.html",children:(0,r.jsx)(n.code,{children:"ColumnType"})})," enum can be used."]}),"\n",(0,r.jsx)(n.h3,{id:"additional-properties",children:"Additional properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Default Value"}),"\n",(0,r.jsx)(n.li,{children:"Unique"}),"\n",(0,r.jsx)(n.li,{children:"Indexed"}),"\n",(0,r.jsx)(n.li,{children:"Nullable"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'ColumnType::String(None).def().default_value("Sam").unique().indexed().nullable()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cast-column-type-on-select-and-save",children:"Cast Column Type on Select and Save"}),"\n",(0,r.jsxs)(n.p,{children:["If you need to select a column as one type but save it into the database as another, you can override the ",(0,r.jsx)(n.code,{children:"select_as"})," and the ",(0,r.jsx)(n.code,{children:"save_as"})," methods to perform the casting. A typical use case is selecting a column of type ",(0,r.jsx)(n.code,{children:"citext"})," (case-insensitive text) as ",(0,r.jsx)(n.code,{children:"String"})," in Rust and saving it into the database as ",(0,r.jsx)(n.code,{children:"citext"}),". One should override the ",(0,r.jsx)(n.code,{children:"ColumnTrait"}),"'s methods as below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use sea_orm::sea_query::{Expr, SimpleExpr, Alias}\n\nimpl ColumnTrait for Column {\n    // Snipped...\n\n    /// Cast column expression used in select statement.\n    fn select_as(&self, expr: Expr) -> SimpleExpr {\n        match self {\n            Column::CaseInsensitiveText => expr.cast_as(Alias::new("text")),\n            _ => self.select_enum_as(expr),\n        }\n    }\n\n    /// Cast value of a column into the correct type for database storage.\n    fn save_as(&self, val: Expr) -> SimpleExpr {\n        match self {\n            Column::CaseInsensitiveText => val.cast_as(Alias::new("citext")),\n            _ => self.save_enum_as(val),\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"primary-key",children:"Primary Key"}),"\n",(0,r.jsx)(n.p,{children:"An enum representing the primary key of this table. A composite key is represented by an enum with multiple variants."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ValueType"})," defines the type of last_insert_id in ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/struct.InsertResult.html",children:(0,r.jsx)(n.code,{children:"InsertResult"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"auto_increment"})," defines whether the primary key has an auto-generated value."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    #[sea_orm(column_name = "id")] // Override the default column name\n    Id,  // maps to "id" in SQL\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n\n    fn auto_increment() -> bool {\n        true\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Example composite key"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub enum PrimaryKey {\n    CakeId,\n    FruitId,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = (i32, i32);\n\n    fn auto_increment() -> bool {\n        false\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"model",children:"Model"}),"\n",(0,r.jsx)(n.p,{children:"The Rust struct for storing query results."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq, Eq, DeriveModel, DeriveActiveModel)]\npub struct Model {\n    pub id: i32,\n    pub name: String,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"nullable-attribute",children:"Nullable Attribute"}),"\n",(0,r.jsxs)(n.p,{children:["If the table column is nullable, wrap it with an ",(0,r.jsx)(n.code,{children:"Option"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"{3}",children:"pub struct Model {\n    pub id: i32,\n    pub name: Option<String>,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"active-model",children:"Active Model"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"ActiveModel"})," has all the attributes of its corresponding ",(0,r.jsx)(n.code,{children:"Model"})," but all attributes are wrapped in an ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/enum.ActiveValue.html",children:(0,r.jsx)(n.code,{children:"ActiveValue"})}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq)]\npub struct ActiveModel {\n    pub id: ActiveValue<i32>,\n    pub name: ActiveValue<Option<String>>,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"relation",children:"Relation"}),"\n",(0,r.jsx)(n.p,{children:"Specifying the relations with other entities."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Fruit,\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,r.jsx)(n.p,{children:"Defining trait bounds to help you query related entities together, especially helpful in many-to-many relations."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl Related<super::fruit::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Fruit.def()\n    }\n}\n\nimpl Related<super::filling::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);