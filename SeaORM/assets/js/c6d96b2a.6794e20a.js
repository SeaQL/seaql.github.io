"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[90967],{48859:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>p});var r=t(76687);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),d=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=d(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=d(t),p=a,y=c["".concat(s,".").concat(p)]||c[p]||u[p]||i;return t?r.createElement(y,l(l({ref:n},m),{},{components:t})):r.createElement(y,l({ref:n},m))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var d=2;d<i;d++)l[d]=t[d];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},63433:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=t(31308),a=(t(76687),t(48859));const i={},l="Multi Selects",o={unversionedId:"relation/multi-selects",id:"relation/multi-selects",title:"Multi Selects",description:"Nested Models",source:"@site/docs/06-relation/09-multi-selects.md",sourceDirName:"06-relation",slug:"/relation/multi-selects",permalink:"/SeaORM/docs/next/relation/multi-selects",draft:!1,editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/09-multi-selects.md",tags:[],version:"current",lastUpdatedBy:"Billy Chan",lastUpdatedAt:1743398759,formattedLastUpdatedAt:"Mar 31, 2025",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bakery Schema",permalink:"/SeaORM/docs/next/relation/bakery-schema"},next:{title:"Robust & Correct",permalink:"/SeaORM/docs/next/write-test/testing"}},s={},d=[{value:"Nested Models",id:"nested-models",level:2},{value:"Join with alias",id:"join-with-alias",level:3},{value:"Three-way Join",id:"three-way-join",level:2},{value:"Alternative shape",id:"alternative-shape",level:3},{value:"Three-Model select",id:"three-model-select",level:2}],m={toc:d};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"multi-selects"},"Multi Selects"),(0,a.kt)("h2",{id:"nested-models"},"Nested Models"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"FromQueryResult")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"DerivePartialModel")," macros allows you to nest objects easily, simplifying the construction of complex queries."),(0,a.kt)("p",null,"As a simple first example, we'd like to select ",(0,a.kt)("inlineCode",{parentName:"p"},"Cake")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"Bakery"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(FromQueryResult)]\nstruct Cake {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(FromQueryResult)]\nstruct Bakery {\n    #[sea_orm(from_alias = "bakery_id")]\n    id: i32,\n    #[sea_orm(from_alias = "bakery_name")]\n    brand: String,\n}\n\nlet cake: Cake = cake::Entity::find()\n    .select_only()\n    .column(cake::Column::Id)\n    .column(cake::Column::Name)\n    .column_as(bakery::Column::Id, "bakery_id")\n    .column_as(bakery::Column::Name, "bakery_name")\n    .left_join(bakery::Entity)\n    .order_by_asc(cake::Column::Id)\n    .into_model()\n    .one(db)\n    .await?\n    .unwrap();\n\nassert_eq!(\n    cake,\n    Cake {\n        id: 1,\n        name: "Basque cheesecake".to_string(),\n        bakery: Some(Bakery {\n            id: 20,\n            brand: "Super Baker".to_string(),\n        })\n    }\n);\n')),(0,a.kt)("p",null,"Because the tables ",(0,a.kt)("inlineCode",{parentName:"p"},"cake")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"bakery")," have some duplicate column names, we'd have to do custom selects. ",(0,a.kt)("inlineCode",{parentName:"p"},"select_only")," here clears the default select list, and we apply aliases with ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.column_as"},(0,a.kt)("inlineCode",{parentName:"a"},"column_as")),". Then, in ",(0,a.kt)("inlineCode",{parentName:"p"},"FromQueryResult")," we use ",(0,a.kt)("inlineCode",{parentName:"p"},"from_alias")," to map the query result back to the nested struct."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/derive.DerivePartialModel.html"},(0,a.kt)("inlineCode",{parentName:"a"},"DerivePartialModel"))," allows you to omit the custom selects and aliases.\nThe previous example can be written as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(DerivePartialModel)] // FromQueryResult is no longer needed\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "bakery::Entity", from_query_result)]\nstruct Bakery {\n    id: i32,\n    #[sea_orm(from_col = "Name")]\n    brand: String,\n}\n\n// same as previous example, but without the custom selects\nlet cake: Cake = cake::Entity::find()\n    .left_join(bakery::Entity)\n    .order_by_asc(cake::Column::Id)\n    .into_partial_model()\n    .one(db)\n    .await?\n    .unwrap();\n')),(0,a.kt)("p",null,"Under the hood, ",(0,a.kt)("inlineCode",{parentName:"p"},"bakery_")," prefix will be added to the column alias in the SQL query."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    "cake"."id" AS "id",\n    "cake"."name" AS "name",\n    "bakery"."id" AS "bakery_id",\n    "bakery"."name" AS "bakery_brand"\nFROM "cake"\nLEFT JOIN "bakery" ON "cake"."bakery_id" = "bakery"."id"\nORDER BY "cake"."id" ASC LIMIT 1\n')),(0,a.kt)("h3",{id:"join-with-alias"},"Join with alias"),(0,a.kt)("p",null,"When the same table is joined more than once in the same query, it's necessary to use an alias. You can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"alias")," attribute to select columns from an alias."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct CakeFactory {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Factory>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "bakery::Entity", alias = "factory", from_query_result)]\nstruct Factory {\n    id: i32,\n    #[sea_orm(from_col = "name")]\n    plant: String,\n}\n\nlet cake_factory: CakeFactory = cake::Entity::find()\n    .join_as(\n        JoinType::LeftJoin,\n        cake::Relation::Bakery.def(),\n        Alias::new("factory"),\n    )\n    .order_by_asc(cake::Column::Id)\n    .into_partial_model()\n    .one(db)\n    .await?\n    .unwrap();\n')),(0,a.kt)("p",null,"Results in:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    "cake"."id" AS "id",\n    "cake"."name" AS "name",\n    "factory"."id" AS "bakery_id",\n    "factory"."name" AS "bakery_plant"\nFROM "cake"\nLEFT JOIN "bakery" AS "factory" ON "cake"."bakery_id" = "factory"."id"\nORDER BY "cake"."id" ASC LIMIT 1\n')),(0,a.kt)("h2",{id:"three-way-join"},"Three-way Join"),(0,a.kt)("p",null,"Our join plan starts from Order:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Customer\n      -> LineItem -> Cake\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "order::Entity", from_query_result)]\nstruct Order {\n    id: i32,\n    total: Decimal,\n    #[sea_orm(nested)]\n    customer: Customer,\n    #[sea_orm(nested)]\n    line: LineItem,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "customer::Entity", from_query_result)]\nstruct Customer {\n    name: String,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "lineitem::Entity", from_query_result)]\nstruct LineItem {\n    price: Decimal,\n    quantity: i32,\n    #[sea_orm(nested)]\n    cake: Cake,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    name: String,\n}\n\nlet items: Vec<Order> = order::Entity::find()\n    .left_join(customer::Entity)\n    .left_join(lineitem::Entity)\n    .join(JoinType::LeftJoin, lineitem::Relation::Cake.def())\n    .order_by_asc(order::Column::Id)\n    .order_by_asc(lineitem::Column::Id)\n    .into_partial_model()\n    .all(db)\n    .await?;\n\nassert_eq!(\n    items,\n    [\n        Order {\n            id: 101,\n            total: Decimal::from(10),\n            customer: Customer {\n                name: "Bob".to_owned()\n            },\n            line: LineItem {\n                cake: Cake {\n                    name: "Cheesecake".to_owned()\n                },\n                price: Decimal::from(2),\n                quantity: 2,\n            }\n        },\n        ..\n    ]\n);\n')),(0,a.kt)("p",null,"Since Cake is a related Entity of LineItem, not Order, it does not satisfy the trait bound of ",(0,a.kt)("inlineCode",{parentName:"p"},"left_join"),". It is thus necessary to use the more flexible ",(0,a.kt)("inlineCode",{parentName:"p"},"join")," method."),(0,a.kt)("h3",{id:"alternative-shape"},"Alternative shape"),(0,a.kt)("p",null,"In the above, we make the nested structure resembles the topology of the join plan.\nBut there is no restriction. Indeed, SQL flattens the select into a flat table, so as long as all columns can be found,\nwe can freely arrange the result data structure."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "order::Entity", from_query_result)]\nstruct OrderItem {\n    #[sea_orm(nested)]\n    order: Order,\n    #[sea_orm(nested)]\n    customer: Customer,\n    #[sea_orm(nested)]\n    line: LineItem,\n    #[sea_orm(nested)]\n    cake: Cake,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "order::Entity", from_query_result)]\nstruct Order {\n    #[sea_orm(from_col = "id")]\n    order_id: i32,\n    total: Decimal,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "customer::Entity", from_query_result)]\nstruct Customer {\n    name: String,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "lineitem::Entity", from_query_result)]\nstruct LineItem {\n    price: Decimal,\n    quantity: i32,\n}\n\n#[derive(Debug, DerivePartialModel, PartialEq)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct Cake {\n    name: String,\n}\n\n// the exact same select query\n\nassert_eq!(\n    items,\n    [\n        OrderItem {\n            order: Order {\n                order_id: 101,\n                total: Decimal::from(10),\n            },\n            customer: Customer {\n                name: "Bob".to_owned()\n            },\n            line: LineItem {\n                price: Decimal::from(2),\n                quantity: 2,\n            },\n            cake: Cake {\n                name: "Cheesecake".to_owned()\n            },\n        },\n        ..\n    ]\n);\n')),(0,a.kt)("h2",{id:"three-model-select"},"Three-Model select"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Lineitem -> Cake\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let items: Vec<(order::Model, Option<lineitem::Model>, Option<cake::Model>)> =\n    order::Entity::find()\n        .find_also_related(lineitem::Entity)\n        .and_also_related(cake::Entity)\n        .order_by_asc(order::Column::Id)\n        .order_by_asc(lineitem::Column::Id)\n        .all(db)\n        .await?;\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"find_also_related")," is based on relations of the first entity.\n",(0,a.kt)("inlineCode",{parentName:"p"},"and_also_related")," is based on relations of the second entity."),(0,a.kt)("p",null,"To do this instead, you can write:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"Order -> Customer\n      -> LineItem\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"order::Entity::find()\n    .find_also_related(customer::Entity)\n    .find_also_related(lineitem::Entity)\n")))}u.isMDXComponent=!0}}]);