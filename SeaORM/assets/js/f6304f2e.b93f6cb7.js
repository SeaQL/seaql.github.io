"use strict";(globalThis.webpackChunksea_orm=globalThis.webpackChunksea_orm||[]).push([[61347],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var r=s(96540);const i={},a=r.createContext(i);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:n},e.children)}},37996:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"sea-orm-pro/role-based-access-control","title":"Role Based Access Control","description":"SeaORM 2.0 introduces Role-Based Access Control (RBAC), bringing first-class authorization into your data layer. No more bolting on ad-hoc permission checks or scattering business rules across services - SeaORM lets you define roles and permission rules and enforce access policies directly inside the database connection. It\'s a powerful tool for building multi\u2011faceted applications that demand authorization.","source":"@site/docs/11-sea-orm-pro/03-role-based-access-control.md","sourceDirName":"11-sea-orm-pro","slug":"/sea-orm-pro/role-based-access-control","permalink":"/SeaORM/docs/sea-orm-pro/role-based-access-control","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/11-sea-orm-pro/03-role-based-access-control.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1769549057000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Getting Started","permalink":"/SeaORM/docs/sea-orm-pro/getting-started"},"next":{"title":"Traits and Types","permalink":"/SeaORM/docs/internal-design/trait-and-type"}}');var i=s(74848),a=s(28453);const t={},o="Role Based Access Control",l={},c=[{value:"Overview of SeaORM RBAC",id:"overview-of-seaorm-rbac",level:2},{value:"Why reinventing the wheel?",id:"why-reinventing-the-wheel",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Entities",id:"entities",level:3},{value:"User",id:"user",level:4},{value:"Role",id:"role",level:4},{value:"Permissions",id:"permissions",level:4},{value:"Resources",id:"resources",level:4},{value:"Relations",id:"relations",level:3},{value:"User <code>&lt;-&gt;</code> Role",id:"user---role",level:4},{value:"Role Hierarchy",id:"role-hierarchy",level:4},{value:"Role <code>&lt;-&gt;</code> Permission <code>&lt;-&gt;</code> Resource",id:"role---permission---resource",level:4},{value:"User override",id:"user-override",level:4},{value:"Usage",id:"usage",level:2},{value:"Rules Definition",id:"rules-definition",level:3},{value:"Create RBAC tables",id:"create-rbac-tables",level:4},{value:"Add resources &amp; permissions",id:"add-resources--permissions",level:4},{value:"Define roles",id:"define-roles",level:4},{value:"Add role permissions",id:"add-role-permissions",level:4},{value:"Assign user role",id:"assign-user-role",level:4},{value:"Runtime Authorization",id:"runtime-authorization",level:3},{value:"Initialize RBAC engine",id:"initialize-rbac-engine",level:4},{value:"Authenticate user",id:"authenticate-user",level:4},{value:"Create restricted connection",id:"create-restricted-connection",level:4},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"role-based-access-control",children:"Role Based Access Control"})}),"\n",(0,i.jsx)(n.p,{children:"SeaORM 2.0 introduces Role-Based Access Control (RBAC), bringing first-class authorization into your data layer. No more bolting on ad-hoc permission checks or scattering business rules across services - SeaORM lets you define roles and permission rules and enforce access policies directly inside the database connection. It's a powerful tool for building multi\u2011faceted applications that demand authorization."}),"\n",(0,i.jsx)(n.h2,{id:"overview-of-seaorm-rbac",children:"Overview of SeaORM RBAC"}),"\n",(0,i.jsx)(n.p,{children:"Here is a high level overview of the design and the requirements that shaped them:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Table\u2011level access control"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Different user groups can only read or modify certain tables, e.g. customers can only read invoices, but not modify them."}),"\n",(0,i.jsx)(n.p,{children:"Design: RBAC engine is table\u2011scoped so permissions can be expressed directly in terms of CRUD on tables."}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Simplicity of user assignment"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each user should have a clear, unambiguous role to avoid confusion."}),"\n",(0,i.jsx)(n.p,{children:"Design: one user = one role. This prevents complexity of multiple roles per user."}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Role hierarchy and inheritance"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We want to create roles that inherit from multiple roles like A = B + C where A will have the union of permissions from B and C."}),"\n",(0,i.jsx)(n.p,{children:"We want to avoid duplicating permission sets across roles. For example, a 'Manager' should automatically get all 'Employee' permissions, plus extras."}),"\n",(0,i.jsx)(n.p,{children:"Design: Hierarchical roles with multiple inheritance."}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"Granular, composable permissions"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We need to allow fine\u2011grained control like 'read customers but not update them'. We want permission grant to be easy to reason about."}),"\n",(0,i.jsx)(n.p,{children:"Design: Role can be assigned set of permissions (CRUD) on resources (tables). Permissions are additive, once granted, cannot be taken away (but can be overridden on a per user basis)."}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"Extensibility"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We want to extend beyond tables (e.g. application specific actions, or even non\u2011DB resources)."}),"\n",(0,i.jsx)(n.p,{children:"Design: Engine is generic - resource + permission abstraction can be applied to more than just CRUD operations on SQL tables."}),"\n",(0,i.jsxs)(n.ol,{start:"6",children:["\n",(0,i.jsx)(n.li,{children:"Wildcard for convenience"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Sometimes we need to grant superusers full access without enumerating every resource/permission."}),"\n",(0,i.jsxs)(n.p,{children:["Design: Opt\u2011in ",(0,i.jsx)(n.code,{children:"*"})," wildcard for 'all permissions' or 'all resources.'"]}),"\n",(0,i.jsxs)(n.ol,{start:"7",children:["\n",(0,i.jsx)(n.li,{children:"Per\u2011user overrides"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Occasionally, a single user needs an exception (e.g. a contractor who can only read one table, or a manager who should be denied one sensitive table)."}),"\n",(0,i.jsx)(n.p,{children:"Design: User\u2011level overrides to grant/deny permissions."}),"\n",(0,i.jsx)(n.h2,{id:"why-reinventing-the-wheel",children:"Why reinventing the wheel?"}),"\n",(0,i.jsx)(n.p,{children:"Our first thought is to look into the possibility of integrating an existing open-source RBAC engine, but we developed our own in the end, because we want to integrate it tightly with SeaORM."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Rules and permissions live in the same database as your app"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By storing roles and permissions in the same database as your application data, you keep everything in one place. There's no separate DSL, no external policy files, and no risk of your access rules drifting out of sync with your schema. So you can query and update RBAC rules in migrations, just like other tables. Having a single source of truth simplifies development and deployment."}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"The hard part isn't expressing rules, it's enforcing them"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Most policy engines are great at describing rules in abstract terms, but the real challenge is: how do you actually enforce those rules against SQL queries? With an external library, we still need to analyze raw SQL statements ourselves and match that up with the rule definitions. By embedding RBAC directly into SeaORM, we can analyze all queries and enforce those rules."}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Lightweight and performant"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Because the RBAC engine is part of SeaORM itself, it's lightweight and integrated - no extra runtime or external dependency. The runtime cost is also minimal, and most importantly, you don't pay for what you don't use. This feature can be turned off completely."}),"\n",(0,i.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,i.jsxs)(n.p,{children:["Let's take a look at the ",(0,i.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/src/rbac/entity",children:"RBAC schema"})," and go through the entities."]}),"\n",(0,i.jsx)("img",{src:"/blog/img/sea-orm-rbac-schema.png"}),"\n",(0,i.jsx)(n.h3,{id:"entities",children:"Entities"}),"\n",(0,i.jsx)(n.h4,{id:"user",children:"User"}),"\n",(0,i.jsx)(n.p,{children:"The user table is defined by your application. SeaORM doesn't manage that. However we currently require it to have an integer key."}),"\n",(0,i.jsx)(n.h4,{id:"role",children:"Role"}),"\n",(0,i.jsx)(n.p,{children:"Each role comes with a set of privileges. For example, 'admin', 'sales manager' and 'customer service'."}),"\n",(0,i.jsx)(n.h4,{id:"permissions",children:"Permissions"}),"\n",(0,i.jsxs)(n.p,{children:["The actions we can perform on resources. There are 4 basic permissions, ",(0,i.jsx)(n.code,{children:"select"}),", ",(0,i.jsx)(n.code,{children:"insert"}),", ",(0,i.jsx)(n.code,{children:"update"})," and ",(0,i.jsx)(n.code,{children:"delete"}),". You can define more for your application."]}),"\n",(0,i.jsx)(n.h4,{id:"resources",children:"Resources"}),"\n",(0,i.jsx)(n.p,{children:"The resources being accessed. In our case they are database tables."}),"\n",(0,i.jsx)(n.h3,{id:"relations",children:"Relations"}),"\n",(0,i.jsxs)(n.h4,{id:"user---role",children:["User ",(0,i.jsx)(n.code,{children:"<->"})," Role"]}),"\n",(0,i.jsx)(n.p,{children:"As mentioned in the design above, User has a 1-1 relationship with role, meaning each user can only be assigned at most 1 role."}),"\n",(0,i.jsx)(n.h4,{id:"role-hierarchy",children:"Role Hierarchy"}),"\n",(0,i.jsx)(n.p,{children:"Role has a self-referencing relation, and they form a DAG (Directed Acyclic Graph). Most commonly they form a hierarchy tree that somewhat resembles an organization chart."}),"\n",(0,i.jsx)(n.p,{children:"A simple tree example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"admin <- manager <- sales\n                 <- warehouse\n"})}),"\n",(0,i.jsx)(n.p,{children:"If we add the following to the graph, such that each role can have multiple super roles, then it becomes a DAG."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"admin <- sourcing <- warehouse\n"})}),"\n",(0,i.jsx)(n.p,{children:"Each role has their own set of permissions. On runtime, the engine will walk the role hierarchy and take the union of all permissions of the sub-graph."}),"\n",(0,i.jsxs)(n.h4,{id:"role---permission---resource",children:["Role ",(0,i.jsx)(n.code,{children:"<->"})," Permission ",(0,i.jsx)(n.code,{children:"<->"})," Resource"]}),"\n",(0,i.jsxs)(n.p,{children:["Each role can have many such entries, and permission is set for each resource individually. For example: ",(0,i.jsx)(n.code,{children:"manager - update - order"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"user-override",children:"User override"}),"\n",(0,i.jsxs)(n.p,{children:["The schema is a mirror of above: User ",(0,i.jsx)(n.code,{children:"<->"})," Permission ",(0,i.jsx)(n.code,{children:"<->"})," Resource, with an extra ",(0,i.jsx)(n.code,{children:"grant"})," field, ",(0,i.jsx)(n.code,{children:"false"})," means deny."]}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"There are two stages: rules definiton when the RBAC rules are defined, and runtime authorization when these rules are enforced."}),"\n",(0,i.jsx)(n.h3,{id:"rules-definition",children:"Rules Definition"}),"\n",(0,i.jsxs)(n.p,{children:["You can actually update the rules using the provided ",(0,i.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/src/rbac/entity",children:"SeaORM entities"}),", but we provide a set of utilities to make mutating RBAC rules easier."]}),"\n",(0,i.jsx)(n.p,{children:"These methods are idempotent and can be used in migrations."}),"\n",(0,i.jsx)(n.h4,{id:"create-rbac-tables",children:"Create RBAC tables"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"sea_orm::rbac::schema::create_tables(db, Default::default()).await?;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"add-resources--permissions",children:"Add resources & permissions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let mut context = RbacContext::load(db).await?;\n\nlet tables = [\n    baker::Entity.table_name(),\n    bakery::Entity.table_name(),\n    cake::Entity.table_name(),\n    cakes_bakers::Entity.table_name(),\n    customer::Entity.table_name(),\n    lineitem::Entity.table_name(),\n    order::Entity.table_name(),\n    "*", // WILDCARD\n];\n\ncontext.add_tables(db, &tables).await?;\ncontext.add_crud_permissions(db).await?;\n'})}),"\n",(0,i.jsx)(n.h4,{id:"define-roles",children:"Define roles"}),"\n",(0,i.jsx)(n.p,{children:"First we create the roles."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'context.add_roles(db, &["admin", "manager", "public"]).await?;\n'})}),"\n",(0,i.jsx)(n.p,{children:"Then we can define the role hierarchy."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"admin <- manager <- public\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'context\n    .add_role_hierarchy(\n        db,\n        &[\n            RbacAddRoleHierarchy {\n                super_role: "admin",\n                role: "manager",\n            },\n            RbacAddRoleHierarchy {\n                super_role: "manager",\n                role: "public",\n            },\n        ],\n    )\n    .await?;\n'})}),"\n",(0,i.jsx)(n.h4,{id:"add-role-permissions",children:"Add role permissions"}),"\n",(0,i.jsx)(n.p,{children:"The permission and resource sets will be multiplied, i.e. Cartesian product taken."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// public can select everything, here wildcard is used\ncontext.add_role_permissions(db, "public", &["select"], &["*"]).await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// manager can create / update cake and baker\ncontext\n    .add_role_permissions(\n        db,\n        "manager",\n        &["insert", "update"],\n        &["cake", "baker", "cakes_bakers"],\n    )\n    .await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// admin can CRUD everything\ncontext\n    .add_role_permissions(db, "admin", &["insert", "update", "delete"], &["*"])\n    .await?;\n'})}),"\n",(0,i.jsx)(n.h4,{id:"assign-user-role",children:"Assign user role"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'context\n    .assign_user_role(db, &[\n        // (user_id, role)\n        (1, "admin"),\n        (2, "manager"),\n        (3, "public"),\n    ])\n    .await?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"runtime-authorization",children:"Runtime Authorization"}),"\n",(0,i.jsx)(n.p,{children:"With these rules defined, we can now use them in our application."}),"\n",(0,i.jsx)(n.h4,{id:"initialize-rbac-engine",children:"Initialize RBAC engine"}),"\n",(0,i.jsx)(n.p,{children:"By default, it expects the RBAC tables are in the same database schema as the current connection. They can also be fetched from another database connection."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let db: &DbConn;\n\ndb.load_rbac().await?;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The RBAC rules are cached in memory and shared among all database connections via ",(0,i.jsx)(n.code,{children:"RwLock"}),", so they can be reloaded anytime."]}),"\n",(0,i.jsx)(n.h4,{id:"authenticate-user",children:"Authenticate user"}),"\n",(0,i.jsx)(n.p,{children:"This can be done by a web framework, where the user identity is extracted from a JWT token from HTTP requests. Here we assign them manually."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use sea_orm::rbac::RbacUserId;\nlet admin = RbacUserId(1);\nlet manager = RbacUserId(2);\nlet public = RbacUserId(3);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"create-restricted-connection",children:"Create restricted connection"}),"\n",(0,i.jsxs)(n.p,{children:["This is the key step. Once a ",(0,i.jsx)(n.code,{children:"RestrictedConnection"})," is created, it is bounded to the user for the lifetime of the object. It is cheap to create and destroy them, as they are just ",(0,i.jsx)(n.code,{children:"Arc"})," inside."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"RestrictedConnection"})," implements the standard ",(0,i.jsx)(n.code,{children:"DatabaseConnection"})," API, so it can be used in place of a normal ",(0,i.jsx)(n.code,{children:"DbConn"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["All queries made through SeaORM, including through Entity (",(0,i.jsx)(n.code,{children:"ActiveModel"}),") or lower level APIs (",(0,i.jsx)(n.code,{children:"Insert"}),") are audited. Only queries with matching permissions will be executed. DDL (i.e. ",(0,i.jsx)(n.code,{children:"ALTER"}),") and raw SQL are not supported for now, so they will be rejected."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let db: RestrictedConnection = db.restricted_for(admin)?;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By writing functions only accepting ",(0,i.jsx)(n.code,{children:"RestrictedConnection"}),", you can safeguard all operations within the scope of the function, as there is no way from a type system sense for it to degrade into normal ",(0,i.jsx)(n.code,{children:"DatabaseConnection"}),". (In Rust we normally don't do singleton / global scope, so any operation having global side effects is very obvious.)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// admin can create bakery\noperation(db.restricted_for(admin)?).await?;\n\nfn operation(db: RestrictedConnection) -> Result<(), DbErr> {\n    let seaside_bakery = bakery::ActiveModel {\n        name: Set("SeaSide Bakery".to_owned()),\n        profit_margin: Set(10.2),\n        ..Default::default()\n    };\n\n    let res = Bakery::insert(seaside_bakery).exec(&db).await?;\n    let bakery: Option<bakery::Model> = \n        Bakery::find_by_id(res.last_insert_id).one(&db).await?;\n\n    assert_eq!(bakery.unwrap().name, "SeaSide Bakery");\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// manager can't create bakery\noperation(db.restricted_for(manager)?).await?;\n\nfn operation(db: RestrictedConnection) -> Result<(), DbErr> {\n    assert!(matches!(\n        Bakery::insert(bakery::ActiveModel::default())\n            .exec(db)\n            .await,\n        Err(DbErr::AccessDenied { .. })\n    ));\n    Ok(())\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// manager can create cake & baker\noperation(db.restricted_for(manager)?).await?;\n\nfn operation(db: RestrictedConnection) -> Result<(), DbErr> {\n    cake::Entity::insert(cake::ActiveModel {\n        name: Set("Cheesecake".to_owned()),\n        price: Set(2.into()),\n        bakery_id: Set(Some(1)),\n        gluten_free: Set(false),\n        ..Default::default()\n    })\n    .exec(&db)\n    .await?;\n\n    // transaction is supported: using async closure\n    db.transaction::<_, _, DbErr>(|txn| {\n        Box::pin(async move {\n            cake::Entity::insert(cake::ActiveModel {\n                name: Set("Chocolate".to_owned()),\n                price: Set(3.into()),\n                bakery_id: Set(Some(1)),\n                gluten_free: Set(true),\n                ..Default::default()\n            })\n            .exec(txn)\n            .await?;\n\n            Ok(())\n        })\n    })\n    .await?;\n\n    // transaction using the begin / commit API\n    let txn: RestrictedTransaction = db.begin().await?;\n\n    baker::Entity::insert(baker::ActiveModel {\n        name: Set("Master Baker".to_owned()),\n        contact_details: Set(Default::default()),\n        bakery_id: Set(Some(1)),\n        ..Default::default()\n    })\n    .exec(&txn)\n    .await?;\n\n    txn.commit().await?;\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"That's it! I hope the information above can get you started."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["RBAC is a new feature in SeaORM 2.0. We'd love for you to try it out and help shape the final release by ",(0,i.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/discussions/2548",children:"sharing your feedback"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The RBAC engine is a first class construct in SeaORM, implemented underneath the application layer but above the database layer."}),"\n",(0,i.jsx)(n.p,{children:"We believe this is the most robust approach: if it's implemented on the web framework level, it's easy to forget permission checks or some code paths can accidentally escape. Plus it will work for your application, whether you're building REST, gRPC, or GraphQL servers."}),"\n",(0,i.jsx)(n.p,{children:"In SeaORM, analysis is done on SeaQuery AST, so it's almost free - we already have the AST in memory. Thanks to SeaQuery's feature-rich API, you can construct any complex query, including CTEs!"}),"\n",(0,i.jsx)(n.p,{children:"Compared to using the database engine's native access control capabilities, SeaORM is much easier to setup, reason about, and develop with. Plus it is database generic, so you can use it with SQLite."}),"\n",(0,i.jsx)(n.p,{children:"Everything, including the code and rules is defined in one place, so you have a single source of truth. We believe Rust and SeaQL ecosystem is the best way to build performant, scalable and robust applications!"})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);