"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[88897],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(96540);const a={},l=t.createContext(a);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(l.Provider,{value:n},e.children)}},28752:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"relation/many-to-many","title":"Many to Many","description":"A standout feature of SeaORM is its ability to model many-to-many relationships directly at the Entity level. The intermediate junction table is abstracted away, so traversing an M-N relation feels just like a simple 1-N: a single method call instead of multiple joins.","source":"@site/docs/06-relation/03-many-to-many.md","sourceDirName":"06-relation","slug":"/relation/many-to-many","permalink":"/SeaORM/docs/relation/many-to-many","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/03-many-to-many.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1762984597000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"One to Many","permalink":"/SeaORM/docs/relation/one-to-many"},"next":{"title":"Complex Relations","permalink":"/SeaORM/docs/relation/complex-relations"}}');var a=i(74848),l=i(28453);const r={},o="Many to Many",s={},d=[{value:"Defining the Relation",id:"defining-the-relation",level:2},{value:"Defining the Junction Table",id:"defining-the-junction-table",level:2},{value:"Limitation of Codegen",id:"limitation-of-codegen",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,l.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"many-to-many",children:"Many to Many"})}),"\n",(0,a.jsx)(n.p,{children:"A standout feature of SeaORM is its ability to model many-to-many relationships directly at the Entity level. The intermediate junction table is abstracted away, so traversing an M-N relation feels just like a simple 1-N: a single method call instead of multiple joins."}),"\n",(0,a.jsxs)(n.p,{children:["A many-to-many relation is formed by three tables, where two tables are related via a junction table. As an example, a ",(0,a.jsx)(n.code,{children:"Cake"})," has many ",(0,a.jsx)(n.code,{children:"Filling"})," and ",(0,a.jsx)(n.code,{children:"Filling"})," are shared by many ",(0,a.jsx)(n.code,{children:"Cake"})," via an intermediate entity ",(0,a.jsx)(n.code,{children:"CakeFilling"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"defining-the-relation",children:"Defining the Relation"}),"\n",(0,a.jsxs)(n.p,{children:["On the ",(0,a.jsx)(n.code,{children:"Cake"})," entity, to define the relation:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Add a new field ",(0,a.jsx)(n.code,{children:"filling"})," to the ",(0,a.jsx)(n.code,{children:"Model"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Annotate it with ",(0,a.jsx)(n.code,{children:"has_many"}),", and specify the junction table with ",(0,a.jsx)(n.code,{children:"via"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'{10,11} title="entity/cake.rs"',children:'#[sea_orm::model]\n#[derive(DeriveEntityModel, ..)]\n#[sea_orm(table_name = "cake")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(has_one)]\n    pub fruit: HasOne<super::fruit::Entity>,\n    #[sea_orm(has_many, via = "cake_filling")] // M-N relation with junction\n    pub fillings: HasMany<super::filling::Entity>,\n}\n'})}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsx)("summary",{children:"It's expanded to:"}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Relation"})," in SeaORM is an arrow: it has ",(0,a.jsx)(n.code,{children:"from"})," and ",(0,a.jsx)(n.code,{children:"to"}),". ",(0,a.jsx)(n.code,{children:"cake_filling::Relation::Cake"})," defines ",(0,a.jsx)(n.code,{children:"CakeFilling -> Cake"}),". Calling ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.RelationDef.html#method.rev",children:(0,a.jsx)(n.code,{children:"rev"})})," reverses it into ",(0,a.jsx)(n.code,{children:"Cake -> CakeFilling"}),"."]}),(0,a.jsxs)(n.p,{children:["Chaining this with ",(0,a.jsx)(n.code,{children:"cake_filling::Relation::Filling"})," which defines ",(0,a.jsx)(n.code,{children:"CakeFilling -> Filling"})," resulting in ",(0,a.jsx)(n.code,{children:"Cake -> CakeFilling -> Filling"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'{4,10} title="entity/cake.rs"',children:"impl Related<super::filling::Entity> for Entity {\n    // The final relation is Cake -> CakeFilling -> Filling\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        // The original relation is CakeFilling -> Cake,\n        // after `rev` it becomes Cake -> CakeFilling\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n"})})]}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, on the ",(0,a.jsx)(n.code,{children:"Filling"})," entity:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'{8,9} title="entity/cake.rs"',children:'#[sea_orm::model]\n#[derive(DeriveEntityModel, ..)]\n#[sea_orm(table_name = "filling")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(has_many, via = "cake_filling")]\n    pub cakes: HasMany<super::cake::Entity>,\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"defining-the-junction-table",children:"Defining the Junction Table"}),"\n",(0,a.jsxs)(n.p,{children:["On the ",(0,a.jsx)(n.code,{children:"CakeFilling"})," entity, its ",(0,a.jsx)(n.code,{children:"cake_id"})," attribute is referencing the primary key of ",(0,a.jsx)(n.code,{children:"Cake"})," entity, and its ",(0,a.jsx)(n.code,{children:"filling_id"})," attribute is referencing the primary key of ",(0,a.jsx)(n.code,{children:"Filling"})," entity."]}),"\n",(0,a.jsx)(n.p,{children:"To define the inverse relation:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Add two new fields ",(0,a.jsx)(n.code,{children:"cake"})," and ",(0,a.jsx)(n.code,{children:"filling"})," to the ",(0,a.jsx)(n.code,{children:"Model"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Define both relations with ",(0,a.jsx)(n.code,{children:"belongs_to"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'{9-12} title="entity/cake_filling.rs"',children:'#[sea_orm::model]\n#[derive(DeriveEntityModel, ..)]\n#[sea_orm(table_name = "cake_filling")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub cake_id: i32,\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub filling_id: i32,\n    #[sea_orm(belongs_to, from = "cake_id", to = "id")]\n    pub cake: Option<super::cake::Entity>,\n    #[sea_orm(belongs_to, from = "filling_id", to = "id")]\n    pub filling: Option<super::filling::Entity>,\n}\n'})}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsx)("summary",{children:"It's expanded to:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::cake::Entity",\n        from = "Column::CakeId",\n        to = "super::cake::Column::Id"\n    )]\n    Cake,\n    #[sea_orm(\n        belongs_to = "super::filling::Entity",\n        from = "Column::FillingId",\n        to = "super::filling::Column::Id"\n    )]\n    Filling,\n}\n'})})]}),"\n",(0,a.jsx)(n.h2,{id:"limitation-of-codegen",children:"Limitation of Codegen"}),"\n",(0,a.jsxs)(n.p,{children:["Usually, the ",(0,a.jsx)(n.code,{children:"Related"})," trait implementations are automatically generated. However, they will not be generated if there exists multiple relations to a related Entity."]}),"\n",(0,a.jsx)(n.p,{children:"The relation enum variant will still be generated, so they can be used in joins."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(DeriveEntityModel, ..)]\n#[sea_orm(table_name = "cake_with_many_fruits")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub fruit_id1: i32,\n    pub fruit_id2: i32,\n    #[sea_orm(belongs_to, relation_enum = "Fruit1", from = "fruit_id1", to = "id")]\n    pub fruit_1: HasOne<super::fruit::Entity>,\n    #[sea_orm(belongs_to, relation_enum = "Fruit2", from = "fruit_id2", to = "id")]\n    pub fruit_2: HasOne<super::fruit::Entity>,\n}\n\n// expands to:\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(belongs_to = ..)]\n    Fruit1,\n    #[sea_orm(belongs_to = ..)]\n    Fruit2,\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The solution is to define relations with the ",(0,a.jsx)(n.code,{children:"Linked"})," which will be described in the next chapter."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);