"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[49866],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(96540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},33415:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"basic-crud/insert","title":"Insert","description":"Before diving into SeaORM insert we have to introduce ActiveValue and ActiveModel.","source":"@site/versioned_docs/version-1.0.x/05-basic-crud/03-insert.md","sourceDirName":"05-basic-crud","slug":"/basic-crud/insert","permalink":"/SeaORM/docs/1.0.x/basic-crud/insert","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.0.x/05-basic-crud/03-insert.md","tags":[],"version":"1.0.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1759486910000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Select","permalink":"/SeaORM/docs/1.0.x/basic-crud/select"},"next":{"title":"Update","permalink":"/SeaORM/docs/1.0.x/basic-crud/update"}}');var a=t(74848),r=t(28453);const o={},s="Insert",l={},d=[{value:"ActiveValue",id:"activevalue",level:2},{value:"Model &amp; ActiveModel",id:"model--activemodel",level:2},{value:"Set ActiveModel from JSON Value",id:"set-activemodel-from-json-value",level:3},{value:"Checking if an ActiveModel is changed",id:"checking-if-an-activemodel-is-changed",level:3},{value:"Convert ActiveModel back to Model",id:"convert-activemodel-back-to-model",level:3},{value:"Insert One",id:"insert-one",level:2},{value:"Insert Many",id:"insert-many",level:2},{value:"On Conflict",id:"on-conflict",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"insert",children:"Insert"})}),"\n",(0,a.jsxs)(n.p,{children:["Before diving into SeaORM insert we have to introduce ",(0,a.jsx)(n.code,{children:"ActiveValue"})," and ",(0,a.jsx)(n.code,{children:"ActiveModel"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"activevalue",children:"ActiveValue"}),"\n",(0,a.jsxs)(n.p,{children:["A wrapper struct to capture the changes made to ",(0,a.jsx)(n.code,{children:"ActiveModel"})," attributes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use sea_orm::ActiveValue::{Set, NotSet, Unchanged};\n\n// Set value\nlet _: ActiveValue<i32> = Set(10);\n\n// NotSet value\nlet _: ActiveValue<i32> = NotSet;\n\n// An `Unchanged` value\nlet v: ActiveValue<i32> = Unchanged(10);\n\n// Convert `Unchanged` active value as `Set`\nassert!(v.reset(), Set(10));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"model--activemodel",children:"Model & ActiveModel"}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.code,{children:"ActiveModel"})," has all the attributes of ",(0,a.jsx)(n.code,{children:"Model"})," wrapped in ",(0,a.jsx)(n.code,{children:"ActiveValue"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["You can use ",(0,a.jsx)(n.code,{children:"ActiveModel"})," to insert a row with a subset of columns set."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let cheese: Option<cake::Model> = Cake::find_by_id(1).one(db).await?;\n\n// Get Model\nlet model: cake::Model = cheese.unwrap();\nassert_eq!(model.name, "Cheese Cake".to_owned());\n\n// Into ActiveModel\nlet active_model: cake::ActiveModel = model.into();\nassert_eq!(active_model.name, ActiveValue::unchanged("Cheese Cake".to_owned()));\n'})}),"\n",(0,a.jsx)(n.h3,{id:"set-activemodel-from-json-value",children:"Set ActiveModel from JSON Value"}),"\n",(0,a.jsxs)(n.p,{children:["If you want to save user input into the database you can easily convert JSON value into ",(0,a.jsx)(n.code,{children:"ActiveModel"}),". Note that you might want to ",(0,a.jsx)(n.a,{href:"https://serde.rs/attr-skip-serializing.html",children:"skip deserializing"})," JSON's primary key attribute, you can config that as shown below."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]\n#[sea_orm(table_name = "fruit")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[serde(skip_deserializing)] // Skip deserializing\n    pub id: i32,\n    pub name: String,\n    pub cake_id: Option<i32>,\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Set the attributes in ",(0,a.jsx)(n.code,{children:"ActiveModel"})," with ",(0,a.jsx)(n.code,{children:"set_from_json"})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// A ActiveModel with primary key set\nlet mut fruit = fruit::ActiveModel {\n    id: ActiveValue::Set(1),\n    name: ActiveValue::NotSet,\n    cake_id: ActiveValue::NotSet,\n};\n\n// Note that this method will not alter the primary key values in ActiveModel\nfruit.set_from_json(json!({\n    "id": 8,\n    "name": "Apple",\n    "cake_id": 1,\n}))?;\n\nassert_eq!(\n    fruit,\n    fruit::ActiveModel {\n        id: ActiveValue::Set(1),\n        name: ActiveValue::Set("Apple".to_owned()),\n        cake_id: ActiveValue::Set(Some(1)),\n    }\n);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Create a new ",(0,a.jsx)(n.code,{children:"ActiveModel"})," from JSON value with the ",(0,a.jsx)(n.code,{children:"from_json"})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let fruit = fruit::ActiveModel::from_json(json!({\n    "name": "Apple",\n}))?;\n\nassert_eq!(\n    fruit,\n    fruit::ActiveModel {\n        id: ActiveValue::NotSet,\n        name: ActiveValue::Set("Apple".to_owned()),\n        cake_id: ActiveValue::NotSet,\n    }\n);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"checking-if-an-activemodel-is-changed",children:"Checking if an ActiveModel is changed"}),"\n",(0,a.jsxs)(n.p,{children:["You can check whether any field in an ",(0,a.jsx)(n.code,{children:"ActiveModel"})," is ",(0,a.jsx)(n.code,{children:"Set"})," with the ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/trait.ActiveModelTrait.html#method.is_changed",children:(0,a.jsx)(n.code,{children:"is_changed"})})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let mut fruit: fruit::ActiveModel = Default::default();\nassert!(!fruit.is_changed());\n\nfruit.set(fruit::Column::Name, "apple".into());\nassert!(fruit.is_changed());\n'})}),"\n",(0,a.jsx)(n.h3,{id:"convert-activemodel-back-to-model",children:"Convert ActiveModel back to Model"}),"\n",(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.TryIntoModel.html#tymethod.try_into_model",children:"try_into_model"})," method you can convert ActiveModel back to Model."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    ActiveModel {\n        id: Set(2),\n        name: Set("Apple".to_owned()),\n        cake_id: Set(Some(1)),\n    }\n    .try_into_model()\n    .unwrap(),\n    Model {\n        id: 2,\n        name: "Apple".to_owned(),\n        cake_id: Some(1),\n    }\n);\n\nassert_eq!(\n    ActiveModel {\n        id: Set(1),\n        name: NotSet,\n        cake_id: Set(None),\n    }\n    .try_into_model(),\n    Err(DbErr::AttrNotSet(String::from("name")))\n);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"insert-one",children:"Insert One"}),"\n",(0,a.jsxs)(n.p,{children:["Insert an active model and get back a fresh ",(0,a.jsx)(n.code,{children:"Model"}),". Its value is retrieved from database, so any auto-generated fields will be populated."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let pear = fruit::ActiveModel {\n    name: Set("Pear".to_owned()),\n    ..Default::default() // all other attributes are `NotSet`\n};\n\nlet pear: fruit::Model = pear.insert(db).await?;\n'})}),"\n",(0,a.jsx)(n.p,{children:"Insert an active model and get back the last insert id. Its type matches the model's primary key type, so it could be a tuple if the model has a composite primary key."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let pear = fruit::ActiveModel {\n    name: Set("Pear".to_owned()),\n    ..Default::default() // all other attributes are `NotSet`\n};\n\nlet res: InsertResult = fruit::Entity::insert(pear).exec(db).await?;\nassert_eq!(res.last_insert_id, 28)\n'})}),"\n",(0,a.jsx)(n.admonition,{title:"SQL Server (MSSQL) backend",type:"tip",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"IDENTITY INSERT"})," of MSSQL is documented ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM-X/docs/basic-crud/insert/",children:"here"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"insert-many",children:"Insert Many"}),"\n",(0,a.jsx)(n.p,{children:"Insert many active models and get back the last insert id."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let apple = fruit::ActiveModel {\n    name: Set("Apple".to_owned()),\n    ..Default::default()\n};\n\nlet orange = fruit::ActiveModel {\n    name: Set("Orange".to_owned()),\n    ..Default::default()\n};\n\nlet res: InsertResult = Fruit::insert_many([apple, orange]).exec(db).await?;\nassert_eq!(res.last_insert_id, 30)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Supplying an empty set to ",(0,a.jsx)(n.code,{children:"insert_many"})," method will result in an error. However, you can change the behaviour with ",(0,a.jsx)(n.code,{children:"on_empty_do_nothing"})," which wraps the ",(0,a.jsx)(n.code,{children:"InsertResult"})," with a ",(0,a.jsx)(n.code,{children:"TryInsertResult"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let res = Bakery::insert_many(std::iter::empty())\n    .on_empty_do_nothing()\n    .exec(db)\n    .await;\n\nassert!(matches!(res, Ok(TryInsertResult::Empty)));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"on-conflict",children:"On Conflict"}),"\n",(0,a.jsx)(n.p,{children:"Insert active model with on conflict behaviour."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let orange = cake::ActiveModel {\n    id: ActiveValue::set(2),\n    name: ActiveValue::set("Orange".to_owned()),\n};\n\nassert_eq!(\n    cake::Entity::insert(orange.clone())\n        .on_conflict(\n            // on conflict do nothing\n            sea_query::OnConflict::column(cake::Column::Name)\n                .do_nothing()\n                .to_owned()\n        )\n        .build(DbBackend::Postgres)\n        .to_string(),\n    r#"INSERT INTO "cake" ("id", "name") VALUES (2, \'Orange\') ON CONFLICT ("name") DO NOTHING"#,\n);\n\nassert_eq!(\n    cake::Entity::insert(orange)\n        .on_conflict(\n            // on conflict do update\n            sea_query::OnConflict::column(cake::Column::Name)\n                .update_column(cake::Column::Name)\n                .to_owned()\n        )\n        .build(DbBackend::Postgres)\n        .to_string(),\n    r#"INSERT INTO "cake" ("id", "name") VALUES (2, \'Orange\') ON CONFLICT ("name") DO UPDATE SET "name" = "excluded"."name""#,\n);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Performing an upsert statement without inserting or updating any of the row will result in a ",(0,a.jsx)(n.code,{children:"DbErr::RecordNotInserted"})," error."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// When `id` column have conflicting value, do nothing\nlet on_conflict = OnConflict::column(Column::Id).do_nothing().to_owned();\n\n// Insert `1`, `2`, `3` into the table\nlet res = Entity::insert_many([\n    ActiveModel { id: Set(1) },\n    ActiveModel { id: Set(2) },\n    ActiveModel { id: Set(3) },\n])\n.on_conflict(on_conflict.clone())\n.exec(db)\n.await;\n\nassert_eq!(res?.last_insert_id, 3);\n\n// Insert `4` into the table together with the previous 3 rows\nlet res = Entity::insert_many([\n    ActiveModel { id: Set(1) },\n    ActiveModel { id: Set(2) },\n    ActiveModel { id: Set(3) },\n    ActiveModel { id: Set(4) },\n])\n.on_conflict(on_conflict.clone())\n.exec(db)\n.await;\n\nassert_eq!(res?.last_insert_id, 4);\n\n// Repeat last insert. Since all 4 rows already exist, this essentially did nothing.\n// A `DbErr::RecordNotInserted` error will be thrown.\nlet res = Entity::insert_many([\n    ActiveModel { id: Set(1) },\n    ActiveModel { id: Set(2) },\n    ActiveModel { id: Set(3) },\n    ActiveModel { id: Set(4) },\n])\n.on_conflict(on_conflict)\n.exec(db)\n.await;\n\nassert_eq!(res.err(), Some(DbErr::RecordNotInserted));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you want ",(0,a.jsx)(n.code,{children:"RecordNotInserted"})," to be an ",(0,a.jsx)(n.code,{children:"Ok"})," instead of an error, call ",(0,a.jsx)(n.code,{children:".do_nothing()"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let res = Entity::insert_many([..])\n    .on_conflict(on_conflict)\n    .do_nothing()\n    .exec(db)\n    .await;\n\nassert!(matches!(res, Ok(TryInsertResult::Conflicted)));\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);