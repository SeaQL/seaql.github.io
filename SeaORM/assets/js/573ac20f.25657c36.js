"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[34378],{17879:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"advanced-query/transaction","title":"Transaction","description":"A transaction is a group of SQL statements executed with ACID guarantee. There are two transaction APIs.","source":"@site/versioned_docs/version-0.12.x/08-advanced-query/06-transaction.md","sourceDirName":"08-advanced-query","slug":"/advanced-query/transaction","permalink":"/SeaORM/docs/0.12.x/advanced-query/transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-0.12.x/08-advanced-query/06-transaction.md","tags":[],"version":"0.12.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1764679430000,"sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Sub Query","permalink":"/SeaORM/docs/0.12.x/advanced-query/subquery"},"next":{"title":"Streaming","permalink":"/SeaORM/docs/0.12.x/advanced-query/streaming"}}');var s=t(74848),r=t(28453);const i={},o="Transaction",c={},d=[{value:"With a Closure",id:"with-a-closure",level:2},{value:"<code>begin</code> &amp; <code>commit</code> / <code>rollback</code>",id:"begin--commit--rollback",level:2},{value:"Nested transaction",id:"nested-transaction",level:2},{value:"Isolation Level and Access Mode",id:"isolation-level-and-access-mode",level:2},{value:"IsolationLevel",id:"isolationlevel",level:3},{value:"AccessMode",id:"accessmode",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"transaction",children:"Transaction"})}),"\n",(0,s.jsx)(n.p,{children:"A transaction is a group of SQL statements executed with ACID guarantee. There are two transaction APIs."}),"\n",(0,s.jsx)(n.h2,{id:"with-a-closure",children:"With a Closure"}),"\n",(0,s.jsxs)(n.p,{children:["Perform a ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/trait.TransactionTrait.html#tymethod.transaction",children:"transaction with a closure"}),". The transaction will be committed if the closure returned ",(0,s.jsx)(n.code,{children:"Ok"}),", rollbacked if returned ",(0,s.jsx)(n.code,{children:"Err"}),". The 2nd and 3rd type parameters are the Ok and Err types respectively. Since ",(0,s.jsx)(n.code,{children:"async_closure"})," is not yet stabilized, you have to ",(0,s.jsx)(n.code,{children:"Pin<Box<_>>"})," it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use sea_orm::TransactionTrait;\n\n// <Fn, A, B> -> Result<A, B>\ndb.transaction::<_, (), DbErr>(|txn| {\n    Box::pin(async move {\n        bakery::ActiveModel {\n            name: Set("SeaSide Bakery".to_owned()),\n            profit_margin: Set(10.4),\n            ..Default::default()\n        }\n        .save(txn)\n        .await?;\n\n        bakery::ActiveModel {\n            name: Set("Top Bakery".to_owned()),\n            profit_margin: Set(15.0),\n            ..Default::default()\n        }\n        .save(txn)\n        .await?;\n\n        Ok(())\n    })\n})\n.await;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is the preferred way for most cases. However, if you happen to run into an ",(0,s.jsx)(n.em,{children:"impossible lifetime"})," while trying to capture a reference in the async block, then the following API is the solution."]}),"\n",(0,s.jsxs)(n.h2,{id:"begin--commit--rollback",children:[(0,s.jsx)(n.code,{children:"begin"})," & ",(0,s.jsx)(n.code,{children:"commit"})," / ",(0,s.jsx)(n.code,{children:"rollback"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/trait.TransactionTrait.html#tymethod.begin",children:(0,s.jsx)(n.code,{children:"begin"})})," the transaction followed by a ",(0,s.jsx)(n.code,{children:"commit"})," or ",(0,s.jsx)(n.code,{children:"rollback"}),". If ",(0,s.jsx)(n.code,{children:"txn"})," goes out of scope, the transaction is automatically rollbacked."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let txn = db.begin().await?;\n\nbakery::ActiveModel {\n    name: Set("SeaSide Bakery".to_owned()),\n    profit_margin: Set(10.4),\n    ..Default::default()\n}\n.save(&txn)\n.await?;\n\nbakery::ActiveModel {\n    name: Set("Top Bakery".to_owned()),\n    profit_margin: Set(15.0),\n    ..Default::default()\n}\n.save(&txn)\n.await?;\n\ntxn.commit().await?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"nested-transaction",children:"Nested transaction"}),"\n",(0,s.jsxs)(n.p,{children:["Nested transaction is implemented with database's ",(0,s.jsx)(n.code,{children:"SAVEPOINT"}),". The example below illustrates the behavior with the closure API."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'assert_eq!(Bakery::find().all(txn).await?.len(), 0);\n\nctx.db.transaction::<_, _, DbErr>(|txn| {\n    Box::pin(async move {\n        let _ = bakery::ActiveModel {..}.save(txn).await?;\n        let _ = bakery::ActiveModel {..}.save(txn).await?;\n        assert_eq!(Bakery::find().all(txn).await?.len(), 2);\n\n        // Try nested transaction committed\n        txn.transaction::<_, _, DbErr>(|txn| {\n            Box::pin(async move {\n                let _ = bakery::ActiveModel {..}.save(txn).await?;\n                assert_eq!(Bakery::find().all(txn).await?.len(), 3);\n\n                // Try nested-nested transaction rollbacked\n                assert!(txn.transaction::<_, _, DbErr>(|txn| {\n                        Box::pin(async move {\n                            let _ = bakery::ActiveModel {..}.save(txn).await?;\n                            assert_eq!(Bakery::find().all(txn).await?.len(), 4);\n\n                            Err(DbErr::Query(RuntimeErr::Internal(\n                                "Force Rollback!".to_owned(),\n                            )))\n                        })\n                    })\n                    .await\n                    .is_err()\n                );\n\n                assert_eq!(Bakery::find().all(txn).await?.len(), 3);\n\n                // Try nested-nested transaction committed\n                txn.transaction::<_, _, DbErr>(|txn| {\n                    Box::pin(async move {\n                        let _ = bakery::ActiveModel {..}.save(txn).await?;\n                        assert_eq!(Bakery::find().all(txn).await?.len(), 4);\n\n                        Ok(())\n                    })\n                })\n                .await;\n\n                assert_eq!(Bakery::find().all(txn).await?.len(), 4);\n\n                Ok(())\n            })\n        })\n        .await;\n\n        Ok(())\n    })\n})\n.await;\n\nassert_eq!(Bakery::find().all(txn).await?.len(), 4);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"isolation-level-and-access-mode",children:"Isolation Level and Access Mode"}),"\n",(0,s.jsxs)(n.p,{children:["Introduced in ",(0,s.jsx)(n.code,{children:"0.10.5"}),", ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/trait.TransactionTrait.html#tymethod.transaction_with_config",children:(0,s.jsx)(n.code,{children:"transaction_with_config"})})," and ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/trait.TransactionTrait.html#tymethod.begin_with_config",children:(0,s.jsx)(n.code,{children:"begin_with_config"})})," allows you to specify the ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/enum.IsolationLevel.html",children:"IsolationLevel"})," and ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/enum.AccessMode.html",children:"AccessMode"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For now, they are only implemented for MySQL and Postgres. In order to align their semantic difference, MySQL will execute ",(0,s.jsx)(n.code,{children:"SET TRANSACTION"})," commands before begin transaction, while Postgres will execute ",(0,s.jsx)(n.code,{children:"SET TRANSACTION"})," commands after begin transaction."]}),"\n",(0,s.jsx)(n.h3,{id:"isolationlevel",children:"IsolationLevel"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RepeatableRead"}),": Consistent reads within the same transaction read the snapshot established by the first read."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ReadCommitted"}),": Each consistent read, even within the same transaction, sets and reads its own fresh snapshot."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ReadUncommitted"}),": SELECT statements are performed in a nonlocking fashion, but a possible earlier version of a row might be used."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Serializable"}),": All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction."]}),"\n",(0,s.jsx)(n.h3,{id:"accessmode",children:"AccessMode"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ReadOnly"}),": Data can\u2019t be modified in this transaction"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ReadWrite"}),": Data can be modified in this transaction (default)"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(96540);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);