"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[43196],{20047:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"generate-entity/expanded-entity-structure","title":"Expanded Entity Structure","description":"SeaORM is dynamic, which means you have the flexibility to configure things on runtime. If you are curious what DeriveEntityModel expands into, read along. Otherwise, you can skip this for now.","source":"@site/versioned_docs/version-0.8.x/03-generate-entity/03-expanded-entity-structure.md","sourceDirName":"03-generate-entity","slug":"/generate-entity/expanded-entity-structure","permalink":"/SeaORM/docs/0.8.x/generate-entity/expanded-entity-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-0.8.x/03-generate-entity/03-expanded-entity-structure.md","tags":[],"version":"0.8.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1759959585000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Entity Structure","permalink":"/SeaORM/docs/0.8.x/generate-entity/entity-structure"},"next":{"title":"Enumeration","permalink":"/SeaORM/docs/0.8.x/generate-entity/enumeration"}}');var r=t(74848),l=t(28453);const a={},s="Expanded Entity Structure",o={},d=[{value:"Entity",id:"entity",level:2},{value:"Column",id:"column",level:2},{value:"Additional properties",id:"additional-properties",level:3},{value:"Primary Key",id:"primary-key",level:2},{value:"Model",id:"model",level:2},{value:"Nullable Attribute",id:"nullable-attribute",level:3},{value:"Active Model",id:"active-model",level:2},{value:"Active Model Behavior",id:"active-model-behavior",level:3},{value:"Relation",id:"relation",level:2},{value:"Related",id:"related",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"expanded-entity-structure",children:"Expanded Entity Structure"})}),"\n",(0,r.jsxs)(n.p,{children:["SeaORM is dynamic, which means you have the flexibility to configure things on runtime. If you are curious what ",(0,r.jsx)(n.code,{children:"DeriveEntityModel"})," expands into, read along. Otherwise, you can skip this for now."]}),"\n",(0,r.jsxs)(n.p,{children:["The expanded entity format can be generated by ",(0,r.jsx)(n.code,{children:"sea-orm-cli"})," with the ",(0,r.jsx)(n.code,{children:"--expanded-format"})," option."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's go through the sections of the expanded ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/cake_expanded.rs",children:"Cake"})," entity."]}),"\n",(0,r.jsx)(n.h2,{id:"entity",children:"Entity"}),"\n",(0,r.jsxs)(n.p,{children:["By implementing the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.8/sea_orm/entity/trait.EntityTrait.html",children:(0,r.jsx)(n.code,{children:"EntityTrait"})}),", you can perform CRUD operations on the given table."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn schema_name(&self) -> Option<&str> {\n        None\n    }\n\n    fn table_name(&self) -> &str {\n        "cake"\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"column",children:"Column"}),"\n",(0,r.jsx)(n.p,{children:"An enum representing all columns in this table."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Name,\n}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Name => ColumnType::String(None).def(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["All column names are assumed to be in snake-case. You can override the column name by specifying the ",(0,r.jsx)(n.code,{children:"column_name"})," attribute."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub enum Column {\n    Id,      // maps to "id" in SQL\n    Name,    // maps to "name" in SQL\n    #[sea_orm(column_name = "create_at")]\n    CreateAt // maps to "create_at" in SQL\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To specify the datatype of each column, the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.8/sea_orm/entity/enum.ColumnType.html",children:(0,r.jsx)(n.code,{children:"ColumnType"})})," enum can be used."]}),"\n",(0,r.jsx)(n.h3,{id:"additional-properties",children:"Additional properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Default Value"}),"\n",(0,r.jsx)(n.li,{children:"Unique"}),"\n",(0,r.jsx)(n.li,{children:"Indexed"}),"\n",(0,r.jsx)(n.li,{children:"Nullable"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'ColumnType::String(None).def().default_value("Sam").unique().indexed().nullable()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"primary-key",children:"Primary Key"}),"\n",(0,r.jsx)(n.p,{children:"An enum representing the primary key of this table. A composite key is represented by an enum with multiple variants."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ValueType"})," defines the type of last_insert_id in ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.8/sea_orm/struct.InsertResult.html",children:(0,r.jsx)(n.code,{children:"InsertResult"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"auto_increment"})," defines whether the primary key has an auto-generated value."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    #[sea_orm(column_name = "id")] // Override the default column name\n    Id,  // maps to "id" in SQL\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n\n    fn auto_increment() -> bool {\n        true\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Example composite key"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub enum PrimaryKey {\n    CakeId,\n    FruitId,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = (i32, i32);\n\n    fn auto_increment() -> bool {\n        false\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"model",children:"Model"}),"\n",(0,r.jsx)(n.p,{children:"The Rust struct for storing query results."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel)]\npub struct Model {\n    pub id: i32,\n    pub name: String,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"nullable-attribute",children:"Nullable Attribute"}),"\n",(0,r.jsxs)(n.p,{children:["If the table column is nullable, wrap it with an ",(0,r.jsx)(n.code,{children:"Option"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"{3}",children:"pub struct Model {\n    pub id: i32,\n    pub name: Option<String>,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"active-model",children:"Active Model"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"ActiveModel"})," has all the attributes of its corresponding ",(0,r.jsx)(n.code,{children:"Model"})," but all attributes are wrapped in an ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.8/sea_orm/entity/enum.ActiveValue.html",children:(0,r.jsx)(n.code,{children:"ActiveValue"})}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq)]\npub struct ActiveModel {\n    pub id: ActiveValue<i32>,\n    pub name: ActiveValue<Option<String>>,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"active-model-behavior",children:"Active Model Behavior"}),"\n",(0,r.jsxs)(n.p,{children:["Handlers for different triggered actions on an ",(0,r.jsx)(n.code,{children:"ActiveModel"}),". For example, you can perform custom validation logic, preventing a model from saving into database. You can abort an action even after it is done, if you are inside a transaction."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'impl ActiveModelBehavior for ActiveModel {\n    /// Create a new ActiveModel with default values. Also used by `Default::default()`.\n    fn new() -> Self {\n        Self {\n            uuid: Set(Uuid::new_v4()),\n            ..ActiveModelTrait::default()\n        }\n    }\n\n    /// Will be triggered before insert / update\n    fn before_save(self, insert: bool) -> Result<Self, DbErr> {\n        if self.price.as_ref() <= &0.0 {\n            Err(DbErr::Custom(format!(\n                "[before_save] Invalid Price, insert: {}",\n                insert\n            )))\n        } else {\n            Ok(self)\n        }\n    }\n\n    /// Will be triggered after insert / update\n    fn after_save(model: Model, insert: bool) -> Result<Model, DbErr> {\n        Ok(model)\n    }\n\n    /// Will be triggered before delete\n    fn before_delete(self) -> Result<Self, DbErr> {\n        Ok(self)\n    }\n\n    /// Will be triggered after delete\n    fn after_delete(self) -> Result<Self, DbErr> {\n        Ok(self)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"If no customization is needed, simply write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl ActiveModelBehavior for ActiveModel {}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"relation",children:"Relation"}),"\n",(0,r.jsx)(n.p,{children:"Specifying the relations with other entities."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Fruit,\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,r.jsx)(n.p,{children:"Defining trait bounds to help you query related entities together, especially helpful in many-to-many relations."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl Related<super::fruit::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Fruit.def()\n    }\n}\n\nimpl Related<super::filling::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(96540);const r={},l=i.createContext(r);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);