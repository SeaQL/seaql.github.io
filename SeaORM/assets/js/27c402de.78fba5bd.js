"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[79040],{902:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"migration/writing-migration","title":"Writing Migration","description":"In this chapter we will illustrate a schema first approach: you write migrations first and then generate entities from a live database.","source":"@site/docs/03-migration/02-writing-migration.md","sourceDirName":"03-migration","slug":"/migration/writing-migration","permalink":"/SeaORM/docs/migration/writing-migration","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/03-migration/02-writing-migration.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1760805209000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Setting Up Migration","permalink":"/SeaORM/docs/migration/setting-up-migration"},"next":{"title":"Running Migration","permalink":"/SeaORM/docs/migration/running-migration"}}');var t=a(74848),r=a(28453);const s={},o="Writing Migration",l={},c=[{value:"Schema first vs Entity first",id:"schema-first-vs-entity-first",level:2},{value:"The basics of Migrations",id:"the-basics-of-migrations",level:2},{value:"Creating Migrations",id:"creating-migrations",level:2},{value:"Defining Migration",id:"defining-migration",level:2},{value:"Using SeaQuery",id:"using-seaquery",level:3},{value:"Schema Creation Methods",id:"schema-creation-methods",level:4},{value:"Schema Mutation Methods",id:"schema-mutation-methods",level:4},{value:"Schema Inspection Methods",id:"schema-inspection-methods",level:4},{value:"Using raw SQL",id:"using-raw-sql",level:3},{value:"Tip 1: combining multiple schema changes in one migration",id:"tip-1-combining-multiple-schema-changes-in-one-migration",level:2},{value:"Tip 2: <code>ADD COLUMN IF NOT EXISTS</code>",id:"tip-2-add-column-if-not-exists",level:2},{value:"Tip 3: Seed data with Entity",id:"tip-3-seed-data-with-entity",level:2},{value:"Atomic Migration",id:"atomic-migration",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"writing-migration",children:"Writing Migration"})}),"\n",(0,t.jsx)(n.p,{children:"In this chapter we will illustrate a schema first approach: you write migrations first and then generate entities from a live database."}),"\n",(0,t.jsx)(n.h2,{id:"schema-first-vs-entity-first",children:"Schema first vs Entity first"}),"\n",(0,t.jsx)(n.p,{children:"SeaORM also supports an Entity first approach: your entities are the source of truth, and you run run DDL on the database to match your entity definition."}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["Since ",(0,t.jsx)(n.code,{children:"2.0.0"})]}),(0,t.jsxs)(n.p,{children:["The following requires the ",(0,t.jsx)(n.code,{children:"schema-sync"})," feature flag."]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// it doesn't matter which order you register entities.\n// SeaORM figures out the foreign key dependencies and\n// creates the tables in the right order along with foreign keys\ndb.get_schema_builder()\n    .register(cake::Entity)\n    .register(cake_filling::Entity)\n    .register(filling::Entity)\n    .sync(db) // synchronize the schema with database, \n              // will create missing tables, columns, indexes, foreign keys.\n              // this operation is addition only, will not drop anything.\n    .await?;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"the-basics-of-migrations",children:"The basics of Migrations"}),"\n",(0,t.jsxs)(n.p,{children:["Each migration contains two methods: ",(0,t.jsx)(n.code,{children:"up"})," and ",(0,t.jsx)(n.code,{children:"down"}),". The ",(0,t.jsx)(n.code,{children:"up"})," method is used to alter the database schema, such as adding new tables, columns or indexes, while the ",(0,t.jsx)(n.code,{children:"down"})," method revert the actions performed in the ",(0,t.jsx)(n.code,{children:"up"})," method."]}),"\n",(0,t.jsx)(n.p,{children:"The SeaORM migration system has the following advantages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Write DDL statements with SeaQuery or SQL"}),"\n",(0,t.jsx)(n.li,{children:"Execute multiple DDL (with conditions)"}),"\n",(0,t.jsx)(n.li,{children:"Seed data using the SeaORM API"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-migrations",children:"Creating Migrations"}),"\n",(0,t.jsxs)(n.p,{children:["Generate a new migration file by executing ",(0,t.jsx)(n.code,{children:"sea-orm-cli migrate generate"})," command."]}),"\n",(0,t.jsx)(n.p,{children:"If you name the file with spaces, it will be converted according to the convention automatically."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:'sea-orm-cli migrate generate NAME_OF_MIGRATION [--local-time]\n\n# E.g. to generate `migration/src/m20220101_000001_create_table.rs` shown below\nsea-orm-cli migrate generate create_table\n\n# This create the same migration file as above command\nsea-orm-cli migrate generate "create table"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Or you can create a migration file using the template below. Name the file according to the naming convention ",(0,t.jsx)(n.code,{children:"mYYYYMMDD_HHMMSS_migration_name.rs"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="migration/src/m20220101_000001_create_table.rs"',children:"use sea_orm_migration::prelude::*;\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait]\nimpl MigrationTrait for Migration {\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        manager\n            .create_table( ... )\n            .await\n    }\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        manager\n            .drop_table( ... )\n            .await\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, you have to include the new migration in the ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm-migration/*/sea_orm_migration/migrator/trait.MigratorTrait.html#tymethod.migrations",children:(0,t.jsx)(n.code,{children:"MigratorTrait::migrations"})})," method. Note that the migrations should be sorted in chronological order."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="migration/src/lib.rs"',children:"pub use sea_orm_migration::*;\n\nmod m20220101_000001_create_table;\n\npub struct Migrator;\n\n#[async_trait]\nimpl MigratorTrait for Migrator {\n    fn migrations() -> Vec<Box<dyn MigrationTrait>> {\n        vec![\n            Box::new(m20220101_000001_create_table::Migration),\n        ]\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"defining-migration",children:"Defining Migration"}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm-migration/*/sea_orm_migration/manager/struct.SchemaManager.html",children:(0,t.jsx)(n.code,{children:"SchemaManager"})})," for API reference."]}),"\n",(0,t.jsx)(n.h3,{id:"using-seaquery",children:"Using SeaQuery"}),"\n",(0,t.jsxs)(n.p,{children:["Click ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query#table-create",children:"here"})," to take a quick tour of SeaQuery's DDL statements."]}),"\n",(0,t.jsx)(n.p,{children:"Here are some common DDL snippets you may find useful."}),"\n",(0,t.jsx)(n.h4,{id:"schema-creation-methods",children:"Schema Creation Methods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Create Table","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Remember to import `sea_orm_migration::schema::*` schema helpers into scope\nuse sea_orm_migration::{prelude::*, schema::*};\n\n// Defining the table schema\nmanager\n    .create_table(\n        Table::create()\n            .table("post")\n            .if_not_exists()\n            .col(pk_auto("id"))\n            .col(string("title"))\n            .col(string("text"))\n            .col(enumeration_null("category", "category", ["Feed", "Store"]))\n    )\n    .await\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Create Index","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.create_index(sea_query::Index::create()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Create Foreign Key","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.create_foreign_key(sea_query::ForeignKey::create()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Create Data Type (PostgreSQL only)","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use sea_orm_migration::prelude::extension::postgres::Type;\n\nmanager\n    .create_type(\n        Type::create()\n            .as_enum(CategoryEnum)\n            .values(["feed", "story"])\n            .to_owned()\n    )\n    .await?;\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"schema-mutation-methods",children:"Schema Mutation Methods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Drop Table","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use entity::post;\n\nmanager.drop_table(sea_query::Table::drop()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Alter Table","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.alter_table(sea_query::Table::alter()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Rename Table","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.rename_table(sea_query::Table::rename()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Truncate Table","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.truncate_table(sea_query::Table::truncate()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Drop Index","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.drop_index(sea_query::Index::drop()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Drop Foreign Key","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.drop_foreign_key(sea_query::ForeignKey::drop()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Alter Data Type (PostgreSQL only)","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.alter_type(sea_query::Type::alter()..)\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Drop Data Type (PostgreSQL only)","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"manager.drop_type(sea_query::extension::postgres::Type()..)\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"schema-inspection-methods",children:"Schema Inspection Methods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Has Table","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'manager.has_table("table_name")\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Has Column","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'manager.has_column("table_name", "column_name")\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Has Index","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'manager.has_index("table_name", "index_name")\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"using-raw-sql",children:"Using raw SQL"}),"\n",(0,t.jsx)(n.p,{children:"You can write migration files in raw SQL, but then you lost the multi-backend compatibility SeaQuery offers."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="migration/src/m20220101_000001_create_table.rs"',children:'use sea_orm::Statement;\nuse sea_orm_migration::prelude::*;\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait]\nimpl MigrationTrait for Migration {\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        let db = manager.get_connection();\n\n        // Use `execute_unprepared` if the SQL statement doesn\'t have value bindings\n        db.execute_unprepared(\n            "CREATE TABLE `cake` (\n                `id` int NOT NULL AUTO_INCREMENT PRIMARY KEY,\n                `name` varchar(255) NOT NULL\n            )"\n        )\n        .await?;\n\n        // Construct a `Statement` if the SQL contains value bindings\n        db.execute_raw(Statement::from_sql_and_values(\n            manager.get_database_backend(),\n            r#"INSERT INTO `cake` (`name`) VALUES (?)"#,\n            ["Cheese Cake".into()]\n        )).await?;\n\n        Ok(())\n    }\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        manager\n            .get_connection()\n            .execute_unprepared("DROP TABLE `cake`")\n            .await?;\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"tip-1-combining-multiple-schema-changes-in-one-migration",children:"Tip 1: combining multiple schema changes in one migration"}),"\n",(0,t.jsx)(n.p,{children:"You can combine multiple changes within both up and down migration functions. Here is a complete example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Remember to import `sea_orm_migration::schema::*` schema helpers into scope\nuse sea_orm_migration::{prelude::*, schema::*};\n\nasync fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n\n    manager\n        .create_table(\n            sea_query::Table::create()\n                .table(Post::Table)\n                .if_not_exists()\n                .col(pk_auto(Post::Id))\n                .col(string(Post::Title))\n                .col(string(Post::Text))\n        )\n        .await?;\n    \n    manager\n        .create_index(\n            Index::create()\n                .if_not_exists()\n                .name("idx-post_title")\n                .table(Post::Table)\n                .col(Post::Title)                        \n        )\n        .await?;\n    \n    Ok(()) // All good!\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"and here we have the matching down function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n    \n    manager.drop_index(Index::drop().name("idx-post-title"))\n    .await?;\n    \n    manager.drop_table(Table::drop().table(Post::Table))\n    .await?;\n\n    Ok(()) // All good!\n}\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"tip-2-add-column-if-not-exists",children:["Tip 2: ",(0,t.jsx)(n.code,{children:"ADD COLUMN IF NOT EXISTS"})]}),"\n",(0,t.jsx)(n.p,{children:"Since this syntax is not available on MySQL, you can:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n    if !manager.has_column("my_table", "col_to_add").await? {\n        // ALTER TABLE `my_table` ADD COLUMN `col_to_add` ..\n    }\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"tip-3-seed-data-with-entity",children:"Tip 3: Seed data with Entity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n    let db = manager.get_connection();\n\n    cake::ActiveModel {\n        name: Set("Cheesecake".to_owned()),\n        ..Default::default()\n    }\n    .insert(db)\n    .await?;\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/examples/seaography_example/migration/src/m20230102_000001_seed_bakery_data.rs",children:"Full example"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"atomic-migration",children:"Atomic Migration"}),"\n",(0,t.jsx)(n.p,{children:"Migration will be executed in Postgres atomically that means migration scripts will be executed inside a transaction. Changes done to the database will be rolled back if the migration failed. However, atomic migration is not supported in MySQL and SQLite."}),"\n",(0,t.jsxs)(n.p,{children:["You can start a transaction inside each migration to perform operations like ",(0,t.jsx)(n.a,{href:"/SeaORM/docs/migration/seeding-data#seeding-data-transactionally",children:"seeding sample data"})," for a newly created table."]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var i=a(96540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);