"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[43238],{6395:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"generate-entity/newtype","title":"New Type","description":"You can define a New Type (T) and use it as model field. The following traits have to be implemented.","source":"@site/versioned_docs/version-1.1.x/04-generate-entity/05-newtype.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/newtype","permalink":"/SeaORM/docs/generate-entity/newtype","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/04-generate-entity/05-newtype.md","tags":[],"version":"1.1.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1749025680000,"sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ActiveEnum","permalink":"/SeaORM/docs/generate-entity/enumeration"},"next":{"title":"Basic Schema","permalink":"/SeaORM/docs/basic-crud/basic-schema"}}');var t=n(88790),a=n(77162);const l={},o="New Type",i={},u=[{value:"Wrapper Type",id:"wrapper-type",level:2},{value:"Wrapping <code>Vec&lt;T&gt;</code> (Postgres only)",id:"wrapping-vect-postgres-only",level:2},{value:"Wrapping <code>Vec&lt;T&gt;</code> (backend generic)",id:"wrapping-vect-backend-generic",level:2},{value:"Enum String",id:"enum-string",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components},{Details:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"new-type",children:"New Type"})}),"\n",(0,t.jsxs)(r.p,{children:["You can define a New Type (",(0,t.jsx)(r.code,{children:"T"}),") and use it as model field. The following traits have to be implemented."]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.code,{children:"From<T>"})," for ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-query/*/sea_query/value/enum.Value.html",children:(0,t.jsx)(r.code,{children:"sea_query::Value"})})]}),"\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-orm/*/sea_orm/trait.TryGetable.html",children:(0,t.jsx)(r.code,{children:"sea_orm::TryGetable"})})," for ",(0,t.jsx)(r.code,{children:"T"})]}),"\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-query/*/sea_query/value/trait.ValueType.html",children:(0,t.jsx)(r.code,{children:"sea_query::ValueType"})})," for ",(0,t.jsx)(r.code,{children:"T"})]}),"\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-query/*/sea_query/value/trait.Nullable.html",children:(0,t.jsx)(r.code,{children:"sea_query::Nullable"})})," for ",(0,t.jsx)(r.code,{children:"T"})]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"wrapper-type",children:"Wrapper Type"}),"\n",(0,t.jsx)(r.p,{children:"You can create new types wrapping any type supported by SeaORM."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "custom_value_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub number: Integer,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveValueType)]\npub struct Integer(i32);\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"Integer"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"#[automatically_derived]\nimpl std::convert::From<Integer> for sea_orm::Value {\n    fn from(source: Integer) -> Self {\n        source.0.into()\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::TryGetable for Integer {\n    fn try_get_by<I: sea_orm::ColIdx>(res: &sea_orm::QueryResult, idx: I)\n        -> std::result::Result<Self, sea_orm::TryGetError> {\n        <i32 as sea_orm::TryGetable>::try_get_by(res, idx).map(|v| Integer(v))\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::ValueType for Integer {\n    fn try_from(v: sea_orm::Value) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        <i32 as sea_orm::sea_query::ValueType>::try_from(v).map(|v| Integer(v))\n    }\n\n    fn type_name() -> std::string::String {\n        stringify!(Integer).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::Int\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::Integer\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::Nullable for Integer {\n    fn null() -> sea_orm::Value {\n        <i32 as sea_orm::sea_query::Nullable>::null()\n    }\n}\n"})})]}),"\n",(0,t.jsxs)(r.h2,{id:"wrapping-vect-postgres-only",children:["Wrapping ",(0,t.jsx)(r.code,{children:"Vec<T>"})," (Postgres only)"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "custom_vec_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub str_vec: StringVec,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveValueType)]\npub struct StringVec(pub Vec<String>);\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"StringVec"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"#[automatically_derived]\nimpl std::convert::From<StringVec> for Value {\n    fn from(source: StringVec) -> Self {\n        source.0.into()\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::TryGetable for StringVec {\n    fn try_get_by<I: sea_orm::ColIdx>(res: &QueryResult, idx: I) -> Result<Self, sea_orm::TryGetError> {\n        <Vec<String> as sea_orm::TryGetable>::try_get_by(res, idx).map(|v| StringVec(v))\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::ValueType for StringVec {\n    fn try_from(v: Value) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        <Vec<String> as sea_orm::sea_query::ValueType>::try_from(v).map(|v| StringVec(v))\n    }\n\n    fn type_name() -> String {\n        stringify!(StringVec).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::String\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::String(StringLen::None)\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::Nullable for Integer {\n    fn null() -> sea_orm::Value {\n        <Vec<String> as sea_orm::sea_query::Nullable>::null()\n    }\n}\n"})})]}),"\n",(0,t.jsxs)(r.h2,{id:"wrapping-vect-backend-generic",children:["Wrapping ",(0,t.jsx)(r.code,{children:"Vec<T>"})," (backend generic)"]}),"\n",(0,t.jsxs)(r.p,{children:["You can also define a backend-generic ",(0,t.jsx)(r.code,{children:"Vec<T>"})," field by serialize / deserialize the object to / from JSON:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_vec_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub json_vec: ObjectVec,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct ObjectVec(pub Vec<MyObject>);\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct MyObject {\n    ..\n}\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"ObjectVec"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"impl sea_orm::TryGetableFromJson for ObjectVec {}\n\nimpl std::convert::From<ObjectVec> for sea_orm::Value {\n    fn from(source: ObjectVec) -> Self {\n        sea_orm::Value::Json(serde_json::to_value(&source).ok().map(|s| std::boxed::Box::new(s)))\n    }\n}\n\nimpl sea_orm::sea_query::ValueType for ObjectVec {\n    fn try_from(v: sea_orm::Value) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        match v {\n            sea_orm::Value::Json(Some(json)) => Ok(\n                serde_json::from_value(*json).map_err(|_| sea_orm::sea_query::ValueTypeErr)?,\n            ),\n            _ => Err(sea_orm::sea_query::ValueTypeErr),\n        }\n    }\n\n    fn type_name() -> String {\n        stringify!(ObjectVec).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::Json\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::Json\n    }\n}\n\nimpl sea_orm::sea_query::Nullable for ObjectVec {\n    fn null() -> sea_orm::Value {\n        sea_orm::Value::Json(None)\n    }\n}\n"})})]}),"\n",(0,t.jsx)(r.h2,{id:"enum-string",children:"Enum String"}),"\n",(0,t.jsxs)(r.p,{children:["Since ",(0,t.jsx)(r.code,{children:"1.1.8"}),", ",(0,t.jsx)(r.code,{children:"DeriveValueType"})," also supports ",(0,t.jsx)(r.code,{children:"enum"})," types. It offers a simpler alternative to ",(0,t.jsx)(r.code,{children:"DeriveActiveEnum"})," for client-side enums backed by string database types."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[derive(DeriveValueType)]\n#[sea_orm(value_type = "String")]\npub enum Tag {\n    Hard,\n    Soft,\n}\n\n// `from_str` defaults to `std::str::FromStr::from_str`\nimpl std::str::FromStr for Tag {\n    type Err = sea_orm::sea_query::ValueTypeErr;\n    fn from_str(s: &str) -> Result<Self, Self::Err> { .. }\n}\n\n// `to_str` defaults to `std::string::ToString::to_string`.\nimpl std::fmt::Display for Tag {\n    fn fmt(&self, f: &mut std::fmt::Formatter<\'_>) -> std::fmt::Result { .. }\n}\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"Tag"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[automatically_derived]\nimpl std::convert::From<Tag> for sea_orm::Value {\n    fn from(source: Tag) -> Self {\n        std::string::ToString::to_string(&source).into()\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::TryGetable for Tag {\n    fn try_get_by<I: sea_orm::ColIdx>(res: &sea_orm::QueryResult, idx: I)\n        -> std::result::Result<Self, sea_orm::TryGetError> {\n        let string = String::try_get_by(res, idx)?;\n        std::str::FromStr::from_str(&string).map_err(|err| sea_orm::TryGetError::DbErr(sea_orm::DbErr::Type(format!("{err:?}"))))\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::ValueType for Tag {\n    fn try_from(v: sea_orm::Value) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        let string = <String as sea_orm::sea_query::ValueType>::try_from(v)?;\n        std::str::FromStr::from_str(&string).map_err(|_| sea_orm::sea_query::ValueTypeErr)\n    }\n\n    fn type_name() -> std::string::String {\n        stringify!(Tag).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::String\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::String(sea_orm::sea_query::StringLen::None)\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::Nullable for Tag {\n    fn null() -> sea_orm::Value {\n        sea_orm::Value::String(None)\n    }\n}\n'})})]}),"\n",(0,t.jsxs)(r.p,{children:["You can override ",(0,t.jsx)(r.code,{children:"from_str"})," and ",(0,t.jsx)(r.code,{children:"to_str"})," with custom functions, which is especially useful if you're using ",(0,t.jsx)(r.a,{href:"https://docs.rs/strum/latest/strum/derive.Display.html",children:(0,t.jsx)(r.code,{children:"strum::Display"})})," and ",(0,t.jsx)(r.a,{href:"https://docs.rs/strum/latest/strum/derive.EnumString.html",children:(0,t.jsx)(r.code,{children:"strum::EnumString"})}),", or manually implemented methods:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[derive(DeriveValueType)]\n#[sea_orm(value_type = "String", from_str = "Tag::from_str", to_str = "Tag::to_str")]\npub enum Tag {\n    Color,\n    Grey,\n}\n\nimpl Tag {\n    fn from_str(s: &str) -> Result<Self, ValueTypeErr> { .. }\n\n    fn to_str(&self) -> &\'static str { .. }\n}\n'})})]})}function d(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},77162:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>o});var s=n(22374);const t={},a=s.createContext(t);function l(e){const r=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);