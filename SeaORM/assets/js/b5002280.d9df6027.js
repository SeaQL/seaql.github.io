"use strict";(globalThis.webpackChunksea_orm=globalThis.webpackChunksea_orm||[]).push([[70924],{3110:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"relation/model-loader","title":"Model Loader","description":"The LoaderTrait provides an API to load related entities in batches.","source":"@site/docs/06-relation/06-model-loader.md","sourceDirName":"06-relation","slug":"/relation/model-loader","permalink":"/SeaORM/docs/relation/model-loader","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/06-model-loader.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1769549057000,"sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Complex Relations","permalink":"/SeaORM/docs/relation/complex-relations"},"next":{"title":"Entity Loader","permalink":"/SeaORM/docs/relation/entity-loader"}}');var n=a(74848),r=a(28453);const d={},l="Model Loader",o={},s=[{value:"Load related entity with additional filter condition",id:"load-related-entity-with-additional-filter-condition",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"model-loader",children:"Model Loader"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/query/trait.LoaderTrait.html",children:"LoaderTrait"})," provides an API to load related entities in batches."]}),"\n",(0,n.jsx)(t.p,{children:"Consider this one to many relation:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"let cake_with_fruits: Vec<(cake::Model, Vec<fruit::Model>)> = Cake::find()\n    .find_with_related(Fruit)\n    .all(db)\n    .await?;\n"})}),"\n",(0,n.jsx)(t.p,{children:"The SQL query generated is:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:'SELECT\n    "cake"."id" AS "A_id", "cake"."name" AS "A_name",\n    "fruit"."id" AS "B_id", "fruit"."name" AS "B_name", "fruit"."cake_id" AS "B_cake_id"\nFROM "cake"\nLEFT JOIN "fruit" ON "cake"."id" = "fruit"."cake_id"\nORDER BY "cake"."id" ASC\n'})}),"\n",(0,n.jsx)(t.p,{children:"This is great, but if the N is a large number, the 1 side's (Cake) data will be duplicated a lot. This results in more data being transferred over the wire. In the many to many case, both sides may duplicate. Using the Loader would ensure each model is transferred only once."}),"\n",(0,n.jsx)(t.p,{children:"The following loads the same data as above, but with two queries:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"let cakes: Vec<cake::Model> = Cake::find().all(db).await?;\nlet fruits: Vec<Vec<fruit::Model>> = cakes.load_many(Fruit, db).await?;\n\nfor (cake, fruits) in cakes.into_iter().zip(fruits.into_iter()) {\n    // cake and its associated fruits\n}\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:'SELECT "cake"."id", "cake"."name" FROM "cake"\nSELECT "fruit"."id", "fruit"."name", "fruit"."cake_id" FROM "fruit" WHERE "fruit"."cake_id" IN (..)\n'})}),"\n",(0,n.jsx)(t.p,{children:"You can stack these up:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"let cakes: Vec<cake::Model> = Cake::find().all(db).await?;\nlet fruits: Vec<Vec<fruit::Model>> = cakes.load_many(Fruit, db).await?;\nlet fillings: Vec<Vec<filling::Model>> = cakes.load_many(Filling, db).await?;\n"})}),"\n",(0,n.jsx)(t.h2,{id:"load-related-entity-with-additional-filter-condition",children:"Load related entity with additional filter condition"}),"\n",(0,n.jsx)(t.p,{children:"In an advanced use case, you can apply filters on the related entity:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"let fruits_in_stock: Vec<Vec<fruit::Model>> = cakes.load_many(\n    fruit::Entity::find().filter(fruit::Column::Stock.gt(0i32)),\n    db\n).await?;\n"})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>d,x:()=>l});var i=a(96540);const n={},r=i.createContext(n);function d(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);