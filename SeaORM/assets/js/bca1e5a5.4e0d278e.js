"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[48352],{14827:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"generate-entity/newtype","title":"New Type","description":"You can define a New Type (T) and use it as model field. The following traits have to be implemented.","source":"@site/docs/04-generate-entity/05-newtype.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/newtype","permalink":"/SeaORM/docs/generate-entity/newtype","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/04-generate-entity/05-newtype.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1762544003000,"sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ActiveEnum","permalink":"/SeaORM/docs/generate-entity/enumeration"},"next":{"title":"Entity First Workflow","permalink":"/SeaORM/docs/generate-entity/entity-first"}}');var t=n(74848),a=n(28453);const i={},l="New Type",o={},d=[{value:"Wrapping scalar types",id:"wrapping-scalar-types",level:2},{value:"Using wrapped types as primary keys",id:"using-wrapped-types-as-primary-keys",level:3},{value:"Wrapping <code>Vec&lt;T&gt;</code> (Postgres only)",id:"wrapping-vect-postgres-only",level:2},{value:"Wrapping <code>Vec&lt;T&gt;</code> (backend generic)",id:"wrapping-vect-backend-generic",level:2},{value:"Treat any type as JSON",id:"treat-any-type-as-json",level:2},{value:"Enum String",id:"enum-string",level:2}];function u(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components},{Details:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"new-type",children:"New Type"})}),"\n",(0,t.jsxs)(r.p,{children:["You can define a New Type (",(0,t.jsx)(r.code,{children:"T"}),") and use it as model field. The following traits have to be implemented."]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.code,{children:"From<T>"})," for ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-query/*/sea_query/value/enum.Value.html",children:(0,t.jsx)(r.code,{children:"sea_query::Value"})})]}),"\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-orm/*/sea_orm/trait.TryGetable.html",children:(0,t.jsx)(r.code,{children:"sea_orm::TryGetable"})})," for ",(0,t.jsx)(r.code,{children:"T"})]}),"\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-query/*/sea_query/value/trait.ValueType.html",children:(0,t.jsx)(r.code,{children:"sea_query::ValueType"})})," for ",(0,t.jsx)(r.code,{children:"T"})]}),"\n",(0,t.jsxs)(r.li,{children:["Implement ",(0,t.jsx)(r.a,{href:"https://docs.rs/sea-query/*/sea_query/value/trait.Nullable.html",children:(0,t.jsx)(r.code,{children:"sea_query::Nullable"})})," for ",(0,t.jsx)(r.code,{children:"T"})]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"wrapping-scalar-types",children:"Wrapping scalar types"}),"\n",(0,t.jsx)(r.p,{children:"You can create new types wrapping any type supported by SeaORM."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "custom_value_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub number: Integer,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveValueType)]\npub struct Integer(i32);\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"Integer"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"#[automatically_derived]\nimpl std::convert::From<Integer> for sea_orm::Value {\n    fn from(source: Integer) -> Self {\n        source.0.into()\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::TryGetable for Integer {\n    fn try_get_by<I: sea_orm::ColIdx>(res: &sea_orm::QueryResult, idx: I)\n        -> std::result::Result<Self, sea_orm::TryGetError> {\n        <i32 as sea_orm::TryGetable>::try_get_by(res, idx).map(|v| Integer(v))\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::ValueType for Integer {\n    fn try_from(v: sea_orm::Value) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        <i32 as sea_orm::sea_query::ValueType>::try_from(v).map(|v| Integer(v))\n    }\n\n    fn type_name() -> std::string::String {\n        stringify!(Integer).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::Int\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::Integer\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::Nullable for Integer {\n    fn null() -> sea_orm::Value {\n        <i32 as sea_orm::sea_query::Nullable>::null()\n    }\n}\n"})})]}),"\n",(0,t.jsx)(r.h3,{id:"using-wrapped-types-as-primary-keys",children:"Using wrapped types as primary keys"}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsxs)(r.mdxAdmonitionTitle,{children:["Since ",(0,t.jsx)(r.code,{children:"2.0.0"})]})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "custom_value_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: Integer,\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Only for ",(0,t.jsx)(r.code,{children:"i8"})," / ",(0,t.jsx)(r.code,{children:"i16"})," / ",(0,t.jsx)(r.code,{children:"i32"})," / ",(0,t.jsx)(r.code,{children:"i64"})," / ",(0,t.jsx)(r.code,{children:"u8"})," / ",(0,t.jsx)(r.code,{children:"u16"})," / ",(0,t.jsx)(r.code,{children:"u32"})," / ",(0,t.jsx)(r.code,{children:"u64"}),"."]}),"\n",(0,t.jsxs)(r.h2,{id:"wrapping-vect-postgres-only",children:["Wrapping ",(0,t.jsx)(r.code,{children:"Vec<T>"})," (Postgres only)"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "custom_vec_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub str_vec: StringVec,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveValueType)]\npub struct StringVec(pub Vec<String>);\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"StringVec"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"#[automatically_derived]\nimpl std::convert::From<StringVec> for Value {\n    fn from(source: StringVec) -> Self {\n        source.0.into()\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::TryGetable for StringVec {\n    fn try_get_by<I: sea_orm::ColIdx>(res: &QueryResult, idx: I) -> Result<Self, sea_orm::TryGetError> {\n        <Vec<String> as sea_orm::TryGetable>::try_get_by(res, idx).map(|v| StringVec(v))\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::ValueType for StringVec {\n    fn try_from(v: Value) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        <Vec<String> as sea_orm::sea_query::ValueType>::try_from(v).map(|v| StringVec(v))\n    }\n\n    fn type_name() -> String {\n        stringify!(StringVec).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::String\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::String(StringLen::None)\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::Nullable for Integer {\n    fn null() -> sea_orm::Value {\n        <Vec<String> as sea_orm::sea_query::Nullable>::null()\n    }\n}\n"})})]}),"\n",(0,t.jsxs)(r.h2,{id:"wrapping-vect-backend-generic",children:["Wrapping ",(0,t.jsx)(r.code,{children:"Vec<T>"})," (backend generic)"]}),"\n",(0,t.jsxs)(r.p,{children:["You can also wrap a ",(0,t.jsx)(r.code,{children:"Vec<T>"})," field by serialize / deserialize the object to / from JSON. This is a backend-generic way of supporting array types across databases."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_vec_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub json_vec: ObjectVec,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct ObjectVec(pub Vec<MyObject>);\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct MyObject {\n    ..\n}\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"ObjectVec"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"impl sea_orm::TryGetableFromJson for ObjectVec {}\n\nimpl std::convert::From<ObjectVec> for sea_orm::Value {\n    fn from(source: ObjectVec) -> Self {\n        sea_orm::Value::Json(serde_json::to_value(&source).ok().map(|s| std::boxed::Box::new(s)))\n    }\n}\n\nimpl sea_orm::sea_query::ValueType for ObjectVec {\n    fn try_from(v: sea_orm::Value) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        match v {\n            sea_orm::Value::Json(Some(json)) => Ok(\n                serde_json::from_value(*json).map_err(|_| sea_orm::sea_query::ValueTypeErr)?,\n            ),\n            _ => Err(sea_orm::sea_query::ValueTypeErr),\n        }\n    }\n\n    fn type_name() -> String {\n        stringify!(ObjectVec).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::Json\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::Json\n    }\n}\n\nimpl sea_orm::sea_query::Nullable for ObjectVec {\n    fn null() -> sea_orm::Value {\n        sea_orm::Value::Json(None)\n    }\n}\n"})})]}),"\n",(0,t.jsx)(r.h2,{id:"treat-any-type-as-json",children:"Treat any type as JSON"}),"\n",(0,t.jsxs)(r.p,{children:["In addition to wrapping ",(0,t.jsx)(r.code,{children:"Vec<T>"}),", the ",(0,t.jsx)(r.code,{children:"FromJsonQueryResult"})," macro can be used on any type that implements ",(0,t.jsx)(r.code,{children:"serde"}),"'s ",(0,t.jsx)(r.code,{children:"Serialize"})," and ",(0,t.jsx)(r.code,{children:"Deserialize"}),", and they will be converted to/from JSON when interacting with databases."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use sea_orm::FromJsonQueryResult;\nuse sea_orm::entity::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_struct")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub json_value: Metadata,\n    pub json_value_opt: Option<Metadata>,\n}\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct Metadata {\n    pub id: i32,\n    pub name: String,\n    pub price: f32,\n    pub notes: Option<String>,\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"enum-string",children:"Enum String"}),"\n",(0,t.jsxs)(r.p,{children:["Since ",(0,t.jsx)(r.code,{children:"1.1.8"}),", ",(0,t.jsx)(r.code,{children:"DeriveValueType"})," also supports ",(0,t.jsx)(r.code,{children:"enum"})," types. It offers a simpler alternative to ",(0,t.jsx)(r.code,{children:"DeriveActiveEnum"})," for client-side enums backed by string database types."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[derive(DeriveValueType)]\n#[sea_orm(value_type = "String")]\npub enum Tag {\n    Hard,\n    Soft,\n}\n\n// `from_str` defaults to `std::str::FromStr::from_str`\nimpl std::str::FromStr for Tag {\n    type Err = sea_orm::sea_query::ValueTypeErr;\n    fn from_str(s: &str) -> Result<Self, Self::Err> { .. }\n}\n\n// `to_str` defaults to `std::string::ToString::to_string`.\nimpl std::fmt::Display for Tag {\n    fn fmt(&self, f: &mut std::fmt::Formatter<\'_>) -> std::fmt::Result { .. }\n}\n'})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsxs)("summary",{children:["Which ",(0,t.jsx)(r.code,{children:"Tag"})," expands to:"]}),(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[automatically_derived]\nimpl std::convert::From<Tag> for sea_orm::Value {\n    fn from(source: Tag) -> Self {\n        std::string::ToString::to_string(&source).into()\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::TryGetable for Tag {\n    fn try_get_by<I: sea_orm::ColIdx>(res: &sea_orm::QueryResult, idx: I)\n        -> std::result::Result<Self, sea_orm::TryGetError> {\n        let string = String::try_get_by(res, idx)?;\n        std::str::FromStr::from_str(&string).map_err(|err| sea_orm::TryGetError::DbErr(sea_orm::DbErr::Type(format!("{err:?}"))))\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::ValueType for Tag {\n    fn try_from(v: sea_orm::Value) -> std::result::Result<Self, sea_orm::sea_query::ValueTypeErr> {\n        let string = <String as sea_orm::sea_query::ValueType>::try_from(v)?;\n        std::str::FromStr::from_str(&string).map_err(|_| sea_orm::sea_query::ValueTypeErr)\n    }\n\n    fn type_name() -> std::string::String {\n        stringify!(Tag).to_owned()\n    }\n\n    fn array_type() -> sea_orm::sea_query::ArrayType {\n        sea_orm::sea_query::ArrayType::String\n    }\n\n    fn column_type() -> sea_orm::sea_query::ColumnType {\n        sea_orm::sea_query::ColumnType::String(sea_orm::sea_query::StringLen::None)\n    }\n}\n\n#[automatically_derived]\nimpl sea_orm::sea_query::Nullable for Tag {\n    fn null() -> sea_orm::Value {\n        sea_orm::Value::String(None)\n    }\n}\n'})})]}),"\n",(0,t.jsxs)(r.p,{children:["You can override ",(0,t.jsx)(r.code,{children:"from_str"})," and ",(0,t.jsx)(r.code,{children:"to_str"})," with custom functions, which is especially useful if you're using ",(0,t.jsx)(r.a,{href:"https://docs.rs/strum/latest/strum/derive.Display.html",children:(0,t.jsx)(r.code,{children:"strum::Display"})})," and ",(0,t.jsx)(r.a,{href:"https://docs.rs/strum/latest/strum/derive.EnumString.html",children:(0,t.jsx)(r.code,{children:"strum::EnumString"})}),", or manually implemented methods:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'#[derive(DeriveValueType)]\n#[sea_orm(value_type = "String", from_str = "Tag::from_str", to_str = "Tag::to_str")]\npub enum Tag {\n    Color,\n    Grey,\n}\n\nimpl Tag {\n    fn from_str(s: &str) -> Result<Self, ValueTypeErr> { .. }\n\n    fn to_str(&self) -> &\'static str { .. }\n}\n'})})]})}function c(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>l});var s=n(96540);const t={},a=s.createContext(t);function i(e){const r=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);