"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[86070],{77162:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var t=i(22374);const l={},a=t.createContext(l);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},95023:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"relation/chained-relations","title":"Chained Relations","description":"If you have multiple join paths between two entities or have complex joins that chain through multiple entities, you can define it with Linked. Take this as a simple example, where we join cake and filling via an intermediate cake_filling table.","source":"@site/versioned_docs/version-0.5.x/06-relation/04-chained-relations.md","sourceDirName":"06-relation","slug":"/relation/chained-relations","permalink":"/SeaORM/docs/0.5.x/relation/chained-relations","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-0.5.x/06-relation/04-chained-relations.md","tags":[],"version":"0.5.x","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1754392772000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Many to Many","permalink":"/SeaORM/docs/0.5.x/relation/many-to-many"},"next":{"title":"Self Referencing","permalink":"/SeaORM/docs/0.5.x/relation/self-referencing"}}');var l=i(88790),a=i(77162);const o={},r="Chained Relations",s={},d=[{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Eager Loading",id:"eager-loading",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"chained-relations",children:"Chained Relations"})}),"\n",(0,l.jsxs)(n.p,{children:["If you have multiple join paths between two entities or have complex joins that chain through multiple entities, you can define it with ",(0,l.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.5/sea_orm/entity/trait.Linked.html",children:(0,l.jsx)(n.code,{children:"Linked"})}),". Take ",(0,l.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/cake.rs",children:"this"})," as a simple example, where we join cake and filling via an intermediate cake_filling table."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug)]\npub struct CakeToFilling;\n\nimpl Linked for CakeToFilling {\n    type FromEntity = cake::Entity;\n\n    type ToEntity = filling::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            cake_filling::Relation::Cake.def().rev(),\n            cake_filling::Relation::Filling.def(),\n        ]\n    }\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Alternatively, the ",(0,l.jsx)(n.code,{children:"RelationDef"})," can be defined on the fly, where the following is equivalent to the above:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug)]\npub struct CakeToFilling;\n\nimpl Linked for CakeToFilling {\n    type FromEntity = cake::Entity;\n\n    type ToEntity = filling::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            cake_filling::Relation::Cake.def().rev(),\n            cake_filling::Entity::belongs_to(filling::Entity)\n                .from(cake_filling::Column::FillingId)\n                .to(filling::Column::Id)\n                .into(),\n        ]\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,l.jsxs)(n.p,{children:["Find fillings that can be filled into a cake with the ",(0,l.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.5/sea_orm/entity/prelude/trait.ModelTrait.html#method.find_linked",children:(0,l.jsx)(n.code,{children:"find_linked"})})," method."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'let cake_model = cake::Model {\n    id: 12,\n    name: "".to_owned(),\n};\n\nassert_eq!(\n    cake_model\n        .find_linked(cake::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        r#"SELECT `filling`.`id`, `filling`.`name`"#,\n        r#"FROM `filling`"#,\n        r#"INNER JOIN `cake_filling` ON `cake_filling`.`filling_id` = `filling`.`id`"#,\n        r#"INNER JOIN `cake` ON `cake`.`id` = `cake_filling`.`cake_id`"#,\n        r#"WHERE `cake`.`id` = 12"#,\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,l.jsxs)(n.p,{children:["Find all pairs of cake and filling together in a single select with the ",(0,l.jsx)(n.a,{href:"https://docs.rs/sea-orm/0.5/sea_orm/entity/prelude/struct.Select.html#method.find_also_linked",children:(0,l.jsx)(n.code,{children:"find_also_linked"})})," method."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .find_also_linked(cake::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id` AS `A_id`, `cake`.`name` AS `A_name`,",\n        "`filling`.`id` AS `B_id`, `filling`.`name` AS `B_name`",\n        "FROM `cake`",\n        "LEFT JOIN `cake_filling` ON `cake`.`id` = `cake_filling`.`cake_id`",\n        "LEFT JOIN `filling` ON `cake_filling`.`filling_id` = `filling`.`id`",\n    ]\n    .join(" ")\n);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);