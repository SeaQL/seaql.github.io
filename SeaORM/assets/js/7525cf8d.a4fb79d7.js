"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[64295],{28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>l});var i=n(96540);const s={},r=i.createContext(s);function d(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(r.Provider,{value:t},e.children)}},89628:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"generate-entity/column-types","title":"Column Types","description":"Type mappings","source":"@site/versioned_docs/version-1.1.x/04-generate-entity/03-column-types.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/column-types","permalink":"/SeaORM/docs/1.1.x/generate-entity/column-types","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/04-generate-entity/03-column-types.md","tags":[],"version":"1.1.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1759959585000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Entity Structure","permalink":"/SeaORM/docs/1.1.x/generate-entity/entity-structure"},"next":{"title":"Expanded Entity Structure","permalink":"/SeaORM/docs/1.1.x/generate-entity/expanded-entity-structure"}}');var s=n(74848),r=n(28453);const d={},l="Column Types",c={},a=[{value:"Type mappings",id:"type-mappings",level:2},{value:"JSON column",id:"json-column",level:2},{value:"Postgres Array",id:"postgres-array",level:2},{value:"Postgres Vector",id:"postgres-vector",level:2}];function o(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"column-types",children:"Column Types"})}),"\n",(0,s.jsx)(t.h2,{id:"type-mappings",children:"Type mappings"}),"\n",(0,s.jsx)(t.p,{children:"The column type will be derived automatically with the following mapping."}),"\n",(0,s.jsx)(t.admonition,{title:"SQL Server (MSSQL) backend",type:"tip",children:(0,s.jsxs)(t.p,{children:["The type mappings of MSSQL can be found ",(0,s.jsx)(t.a,{href:"https://www.sea-ql.org/SeaORM-X/docs/generate-entity/entity-structure/",children:"here"}),"."]})}),"\n",(0,s.jsx)(t.p,{children:"For the mappings of Rust primitive data types:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Rust type"}),(0,s.jsxs)(t.th,{children:["Database Type ",(0,s.jsx)("br",{})," (",(0,s.jsx)(t.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/enum.ColumnType.html",children:(0,s.jsx)(t.code,{children:"ColumnType"})}),")"]}),(0,s.jsxs)(t.th,{children:["SQLite ",(0,s.jsx)("br",{})," datatype"]}),(0,s.jsxs)(t.th,{children:["MySQL ",(0,s.jsx)("br",{})," datatype"]}),(0,s.jsxs)(t.th,{children:["PostgreSQL ",(0,s.jsx)("br",{})," datatype"]})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"String"})}),(0,s.jsx)(t.td,{children:"Char"}),(0,s.jsx)(t.td,{children:"char"}),(0,s.jsx)(t.td,{children:"char"}),(0,s.jsx)(t.td,{children:"char"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"String"})}),(0,s.jsx)(t.td,{children:"String"}),(0,s.jsx)(t.td,{children:"varchar"}),(0,s.jsx)(t.td,{children:"varchar"}),(0,s.jsx)(t.td,{children:"varchar"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"i8"})}),(0,s.jsx)(t.td,{children:"TinyInteger"}),(0,s.jsx)(t.td,{children:"tinyint"}),(0,s.jsx)(t.td,{children:"tinyint"}),(0,s.jsx)(t.td,{children:"char"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"u8"})}),(0,s.jsx)(t.td,{children:"TinyUnsigned"}),(0,s.jsx)(t.td,{children:"tinyint"}),(0,s.jsx)(t.td,{children:"tinyint unsigned"}),(0,s.jsx)(t.td,{children:"N/A"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"i16"})}),(0,s.jsx)(t.td,{children:"SmallInteger"}),(0,s.jsx)(t.td,{children:"smallint"}),(0,s.jsx)(t.td,{children:"smallint"}),(0,s.jsx)(t.td,{children:"smallint"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"u16"})}),(0,s.jsx)(t.td,{children:"SmallUnsigned"}),(0,s.jsx)(t.td,{children:"smallint"}),(0,s.jsx)(t.td,{children:"smallint unsigned"}),(0,s.jsx)(t.td,{children:"N/A"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"i32"})}),(0,s.jsx)(t.td,{children:"Integer"}),(0,s.jsx)(t.td,{children:"integer"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"integer"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"u32"})}),(0,s.jsx)(t.td,{children:"Unsigned"}),(0,s.jsx)(t.td,{children:"integer"}),(0,s.jsx)(t.td,{children:"int unsigned"}),(0,s.jsx)(t.td,{children:"N/A"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"i64"})}),(0,s.jsx)(t.td,{children:"BigInteger"}),(0,s.jsx)(t.td,{children:"bigint"}),(0,s.jsx)(t.td,{children:"bigint"}),(0,s.jsx)(t.td,{children:"bigint"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"u64"})}),(0,s.jsx)(t.td,{children:"BigUnsigned"}),(0,s.jsx)(t.td,{children:"bigint"}),(0,s.jsx)(t.td,{children:"bigint unsigned"}),(0,s.jsx)(t.td,{children:"N/A"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"f32"})}),(0,s.jsx)(t.td,{children:"Float"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"real"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"f64"})}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"double"}),(0,s.jsx)(t.td,{children:"double"}),(0,s.jsx)(t.td,{children:"double precision"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"bool"})}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"bool"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"Vec<u8>"})}),(0,s.jsx)(t.td,{children:"Binary"}),(0,s.jsx)(t.td,{children:"blob"}),(0,s.jsx)(t.td,{children:"blob"}),(0,s.jsx)(t.td,{children:"bytea"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["For the mappings of Rust non-primitive data types. You can check ",(0,s.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/entity/prelude.rs",children:(0,s.jsx)(t.code,{children:"entity/prelude.rs"})})," for all of the reexported types."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Rust type"}),(0,s.jsxs)(t.th,{children:["Database Type ",(0,s.jsx)("br",{})," (",(0,s.jsx)(t.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/enum.ColumnType.html",children:(0,s.jsx)(t.code,{children:"ColumnType"})}),")"]}),(0,s.jsxs)(t.th,{children:["SQLite ",(0,s.jsx)("br",{})," datatype"]}),(0,s.jsxs)(t.th,{children:["MySQL ",(0,s.jsx)("br",{})," datatype"]}),(0,s.jsxs)(t.th,{children:["PostgreSQL ",(0,s.jsx)("br",{})," datatype"]})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Date"}),": chrono::NaiveDate ",(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"TimeDate"}),": time::Date"]}),(0,s.jsx)(t.td,{children:"Date"}),(0,s.jsx)(t.td,{children:"date_text"}),(0,s.jsx)(t.td,{children:"date"}),(0,s.jsx)(t.td,{children:"date"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Time"}),": chrono::NaiveTime ",(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"TimeTime"}),": time::Time"]}),(0,s.jsx)(t.td,{children:"Time"}),(0,s.jsx)(t.td,{children:"time_text"}),(0,s.jsx)(t.td,{children:"time"}),(0,s.jsx)(t.td,{children:"time"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"DateTime"}),": chrono::NaiveDateTime ",(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"TimeDateTime"}),": time::PrimitiveDateTime"]}),(0,s.jsx)(t.td,{children:"DateTime"}),(0,s.jsx)(t.td,{children:"datetime_text"}),(0,s.jsx)(t.td,{children:"datetime"}),(0,s.jsx)(t.td,{children:"timestamp"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"DateTimeLocal"}),": chrono::DateTime<Local> ",(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"DateTimeUtc"}),": chrono::DateTime<Utc>"]}),(0,s.jsx)(t.td,{children:"Timestamp"}),(0,s.jsx)(t.td,{children:"timestamp_text"}),(0,s.jsx)(t.td,{children:"timestamp"}),(0,s.jsx)(t.td,{children:"N/A"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"DateTimeWithTimeZone"}),": chrono::DateTime<FixedOffset> ",(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"TimeDateTimeWithTimeZone"}),": time::OffsetDateTime"]}),(0,s.jsx)(t.td,{children:"TimestampWithTimeZone"}),(0,s.jsx)(t.td,{children:"timestamp_with_timezone_text"}),(0,s.jsx)(t.td,{children:"timestamp"}),(0,s.jsx)(t.td,{children:"timestamp with time zone"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Uuid"}),": uuid::Uuid, uuid::fmt::Braced, uuid::fmt::Hyphenated, uuid::fmt::Simple, uuid::fmt::Urn"]}),(0,s.jsx)(t.td,{children:"Uuid"}),(0,s.jsx)(t.td,{children:"uuid_text"}),(0,s.jsx)(t.td,{children:"binary(16)"}),(0,s.jsx)(t.td,{children:"uuid"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Json"}),": serde_json::Value"]}),(0,s.jsx)(t.td,{children:"Json"}),(0,s.jsx)(t.td,{children:"json_text"}),(0,s.jsx)(t.td,{children:"json"}),(0,s.jsx)(t.td,{children:"json"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Decimal"}),": rust_decimal::Decimal"]}),(0,s.jsx)(t.td,{children:"Decimal"}),(0,s.jsx)(t.td,{children:"real"}),(0,s.jsx)(t.td,{children:"decimal"}),(0,s.jsx)(t.td,{children:"decimal"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["You can override the default mappings between a Rust type and ",(0,s.jsx)(t.code,{children:"ColumnType"})," with the ",(0,s.jsx)(t.code,{children:"column_type"})," attribute."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[sea_orm(column_type = "Text")]\npub name: String\n'})}),"\n",(0,s.jsx)(t.h2,{id:"json-column",children:"JSON column"}),"\n",(0,s.jsxs)(t.p,{children:["If you need your JSON field to be deserialized into a struct. You would need to derive ",(0,s.jsx)(t.code,{children:"FromJsonQueryResult"})," for it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_struct")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // JSON column as `serde_json::Value`\n    pub json: Json,\n    // JSON column as custom struct\n    pub json_value: KeyValue,\n    // nullable JSON column as custom struct, backed by jsonb (Postgres only)\n    #[sea_orm(column_type = "JsonBinary")]\n    pub json_value_opt: Option<KeyValue>,\n    // JSON column storing a vector of objects\n    pub json_value_vec: Vec<KeyValue>,\n}\n\n// The custom struct must derive `FromJsonQueryResult`, `Serialize` and `Deserialize`\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct KeyValue {\n    pub id: i32,\n    pub name: String,\n    pub price: f32,\n    pub notes: Option<String>,\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"If you want a cross-database way of implementing array column, you can wrap it with a wrapper type."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_string_vec")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // nullable JSON column storing a vector of string\n    pub str_vec: Option<StringVec>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct StringVec(pub Vec<String>);\n'})}),"\n",(0,s.jsx)(t.p,{children:"More details and examples in the next chapter."}),"\n",(0,s.jsx)(t.h2,{id:"postgres-array",children:"Postgres Array"}),"\n",(0,s.jsx)(t.p,{children:"Array datatype is a Postgres-only feature. You can define a vector of primitive types that is already supported by SeaORM."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "collection")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub integers: Vec<i32>,\n    pub integers_opt: Option<Vec<i32>>,\n    pub floats: Vec<f32>,\n    pub doubles: Vec<f64>,\n    pub strings: Vec<String>,\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"postgres-vector",children:"Postgres Vector"}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsxs)(t.mdxAdmonitionTitle,{children:["Since ",(0,s.jsx)(t.code,{children:"1.1.6"})]}),(0,s.jsxs)(t.p,{children:["PgVector support is added. Requires ",(0,s.jsx)(t.code,{children:"postgres-vector"})," feature flag."]})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "image_model")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub id: i32,\n    pub embedding: PgVector,\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["For a complete example, see ",(0,s.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/1.1.x/tests/embedding_tests.rs",children:"embedding_tests"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);