"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[21818],{17154:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"basic-crud/custom-active-model","title":"Custom Active Model","description":"Creating your own struct with partial fields of a model, which implements IntoActiveModel that can be converted into an ActiveModel with the method intoactivemodel. For example, it can be used as a form submission in a REST API.","source":"@site/docs/05-basic-crud/10-custom-active-model.md","sourceDirName":"05-basic-crud","slug":"/basic-crud/custom-active-model","permalink":"/SeaORM/docs/basic-crud/custom-active-model","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/05-basic-crud/10-custom-active-model.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1772311927000,"sidebarPosition":10,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Raw SQL","permalink":"/SeaORM/docs/basic-crud/raw-sql"},"next":{"title":"One to One","permalink":"/SeaORM/docs/relation/one-to-one"}}');var d=n(74848),o=n(28453);const s={},c="Custom Active Model",r={},l=[{value:"Advanced Attributes",id:"advanced-attributes",level:2},{value:"Computed Defaults and Auto-Set Fields",id:"computed-defaults-and-auto-set-fields",level:3},{value:"Ignoring Fields",id:"ignoring-fields",level:3},{value:"Exhaustive Mode",id:"exhaustive-mode",level:3},{value:"Summary",id:"summary",level:3},{value:"PartialModel to ActiveModel",id:"partialmodel-to-activemodel",level:2}];function a(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.header,{children:(0,d.jsx)(t.h1,{id:"custom-active-model",children:"Custom Active Model"})}),"\n",(0,d.jsxs)(t.p,{children:["Creating your own struct with partial fields of a model, which implements ",(0,d.jsx)(t.code,{children:"IntoActiveModel"})," that can be converted into an ",(0,d.jsx)(t.code,{children:"ActiveModel"})," with the method ",(0,d.jsx)(t.code,{children:"into_active_model"}),". For example, it can be used as a form submission in a REST API."]}),"\n",(0,d.jsxs)(t.p,{children:[(0,d.jsx)(t.code,{children:"IntoActiveValue"})," trait allows converting ",(0,d.jsx)(t.code,{children:"Option<T>"})," into ",(0,d.jsx)(t.code,{children:"ActiveValue<T>"})," with the method ",(0,d.jsx)(t.code,{children:"into_active_value"}),"."]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:'// Define regular model as usual\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "fruit")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    pub cake_id: Option<i32>,\n}\n'})}),"\n",(0,d.jsx)(t.p,{children:"Create a new struct with some fields omitted."}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:'use sea_orm::ActiveValue::NotSet;\n\n#[derive(DeriveIntoActiveModel)]\npub struct NewFruit {\n    // id is omitted\n    pub name: String,\n    // it is required as opposed to optional in Model\n    pub cake_id: i32,\n}\n\nassert_eq!(\n    NewFruit {\n        name: "Apple".to_owned(),\n        cake_id: 1,\n    }\n    .into_active_model(),\n    fruit::ActiveModel {\n        id: NotSet,\n        name: Set("Apple".to_owned()),\n        cake_id: Set(Some(1)),\n    }\n);\n'})}),"\n",(0,d.jsxs)(t.p,{children:[(0,d.jsx)(t.code,{children:"Option<Option<T>>"})," allows for ",(0,d.jsx)(t.code,{children:"Some(None)"})," to update the column to be NULL."]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:"use sea_orm::ActiveValue::NotSet;\n\n#[derive(DeriveIntoActiveModel)]\npub struct UpdateFruit {\n    pub cake_id: Option<Option<i32>>,\n}\n\nassert_eq!(\n    UpdateFruit { cake_id: Some(Some(1)) }.into_active_model(),\n    fruit::ActiveModel { id: NotSet, name: NotSet, cake_id: Set(Some(1)) }\n);\n\nassert_eq!(\n    UpdateFruit { cake_id: Some(None) }.into_active_model(),\n    fruit::ActiveModel { id: NotSet, name: NotSet, cake_id: Set(None) }\n);\n\nassert_eq!(\n    UpdateFruit { cake_id: None }.into_active_model(),\n    fruit::ActiveModel { id: NotSet, name: NotSet, cake_id: NotSet }\n);\n"})}),"\n",(0,d.jsx)(t.h2,{id:"advanced-attributes",children:"Advanced Attributes"}),"\n",(0,d.jsx)(t.admonition,{type:"tip",children:(0,d.jsxs)(t.mdxAdmonitionTitle,{children:["Since ",(0,d.jsx)(t.code,{children:"2.0.0"})]})}),"\n",(0,d.jsx)(t.h3,{id:"computed-defaults-and-auto-set-fields",children:"Computed Defaults and Auto-Set Fields"}),"\n",(0,d.jsxs)(t.p,{children:["Use ",(0,d.jsx)(t.code,{children:'set(field = "expr")'})," at the container level to inject fields that aren't part of the struct, and ",(0,d.jsx)(t.code,{children:'#[sea_orm(default = "expr")]'})," on ",(0,d.jsx)(t.code,{children:"Option<T>"})," fields to provide a fallback when ",(0,d.jsx)(t.code,{children:"None"}),":"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:'const SYSTEM_USER_ID: i32 = 0;\n\n#[derive(DeriveIntoActiveModel)]\n#[sea_orm(\n    active_model = "post::ActiveModel",\n    set(updated_at = "chrono::Utc::now()"),\n    set(version = "1")\n)]\nstruct CreatePost {\n    title: String,\n    content: String,\n    #[sea_orm(default = "chrono::Utc::now()")]\n    published_at: Option<chrono::DateTime<chrono::Utc>>,\n    #[sea_orm(default = "SYSTEM_USER_ID")]\n    author_id: Option<i32>,\n}\n'})}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:'set(field = "expr")'})," accepts arbitrary Rust expressions: functions, constants, literals. Multiple ",(0,d.jsx)(t.code,{children:"set"})," attributes are merged."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:'#[sea_orm(default = "expr")]'})," provides a fallback for ",(0,d.jsx)(t.code,{children:"Option<T>"})," fields: ",(0,d.jsx)(t.code,{children:"Some(v)"})," becomes ",(0,d.jsx)(t.code,{children:"Set(v)"}),", ",(0,d.jsx)(t.code,{children:"None"})," becomes ",(0,d.jsx)(t.code,{children:"Set(expr)"}),"."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:"#[sea_orm(default)]"})," (bare) uses ",(0,d.jsx)(t.code,{children:"Default::default()"})," as the fallback."]}),"\n",(0,d.jsxs)(t.li,{children:[(0,d.jsx)(t.code,{children:'active_model = "..."'})," specifies the target ActiveModel type explicitly."]}),"\n"]}),"\n",(0,d.jsx)(t.h3,{id:"ignoring-fields",children:"Ignoring Fields"}),"\n",(0,d.jsxs)(t.p,{children:["Use ",(0,d.jsx)(t.code,{children:"#[sea_orm(ignore)]"})," to exclude DTO-only fields that have no corresponding column:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:'#[derive(DeriveIntoActiveModel)]\n#[sea_orm(active_model = "account::ActiveModel")]\nstruct UpdateAccount {\n    id: i32,\n    name: String,\n    #[sea_orm(ignore)]\n    audit_log: String,\n}\n'})}),"\n",(0,d.jsx)(t.h3,{id:"exhaustive-mode",children:"Exhaustive Mode"}),"\n",(0,d.jsxs)(t.p,{children:["Add ",(0,d.jsx)(t.code,{children:"exhaustive"})," to remove the ",(0,d.jsx)(t.code,{children:"..Default::default()"})," spread, forcing every ActiveModel field to be explicitly covered by the struct, ",(0,d.jsx)(t.code,{children:"set"}),", or ",(0,d.jsx)(t.code,{children:"default"}),":"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:'#[derive(DeriveIntoActiveModel)]\n#[sea_orm(\n    active_model = "account::ActiveModel",\n    exhaustive,\n    set(updated_at = "chrono::Utc::now()")\n)]\nstruct UpdateAccount {\n    id: i32,\n    #[sea_orm(default = "false")]\n    disabled: Option<bool>,\n    #[sea_orm(ignore)]\n    audit_log: String,\n}\n'})}),"\n",(0,d.jsxs)(t.p,{children:["This gives you a compile-time guarantee that no field is accidentally left as ",(0,d.jsx)(t.code,{children:"NotSet"}),"."]}),"\n",(0,d.jsx)(t.h3,{id:"summary",children:"Summary"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Scenario"}),(0,d.jsx)(t.th,{children:"Attribute"}),(0,d.jsx)(t.th,{children:"Result in ActiveModel"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Field provided directly"}),(0,d.jsx)(t.td,{children:"Declare field normally"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Set(value)"})})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Field not in struct but must be set"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:'set(field = "expr")'})}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"Set(expr)"})})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Optional field with fallback"}),(0,d.jsxs)(t.td,{children:[(0,d.jsx)(t.code,{children:"Option<T>"})," + ",(0,d.jsx)(t.code,{children:'#[sea_orm(default = "expr")]'})]}),(0,d.jsxs)(t.td,{children:[(0,d.jsx)(t.code,{children:"Some(v)"})," \u2192 ",(0,d.jsx)(t.code,{children:"Set(v)"}),", ",(0,d.jsx)(t.code,{children:"None"})," \u2192 ",(0,d.jsx)(t.code,{children:"Set(expr)"})]})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"DTO-only field, no column"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"#[sea_orm(ignore)]"})}),(0,d.jsx)(t.td,{children:"Excluded"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Field not declared, no default"}),(0,d.jsx)(t.td,{children:"Omit field"}),(0,d.jsx)(t.td,{children:(0,d.jsx)(t.code,{children:"NotSet"})})]})]})]}),"\n",(0,d.jsx)(t.h2,{id:"partialmodel-to-activemodel",children:"PartialModel to ActiveModel"}),"\n",(0,d.jsx)(t.admonition,{type:"tip",children:(0,d.jsxs)(t.mdxAdmonitionTitle,{children:["Since ",(0,d.jsx)(t.code,{children:"1.1.0"})]})}),"\n",(0,d.jsxs)(t.p,{children:[(0,d.jsx)(t.code,{children:"DerivePartialModel"})," can also derive ",(0,d.jsx)(t.code,{children:"IntoActiveModel"})," with the ",(0,d.jsx)(t.code,{children:"into_active_model"})," attribute. This reuses your partial select struct for writes: absent fields become ",(0,d.jsx)(t.code,{children:"NotSet"}),"."]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-rust",children:'#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity", into_active_model)]\nstruct PartialCake {\n    id: i32,\n    name: String,\n}\n\nlet partial_cake = PartialCake {\n    id: 12,\n    name: "Lemon Drizzle".to_owned(),\n};\n\nassert_eq!(\n    cake::ActiveModel {\n        ..partial_cake.into_active_model()\n    },\n    cake::ActiveModel {\n        id: Set(12),\n        name: Set("Lemon Drizzle".to_owned()),\n        ..Default::default()\n    }\n);\n'})}),"\n",(0,d.jsx)(t.p,{children:"This is useful when an API endpoint receives a subset of fields and you want to both query and update with the same struct."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var i=n(96540);const d={},o=i.createContext(d);function s(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);