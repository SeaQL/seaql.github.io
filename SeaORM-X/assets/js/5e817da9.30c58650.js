"use strict";(self.webpackChunksea_orm_x=self.webpackChunksea_orm_x||[]).push([[979],{2204:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var a=s(2374);const i={},t=a.createContext(i);function r(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(t.Provider,{value:n},e.children)}},9319:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"mssql-features/mssql-features","title":"MSSQL-Specific Features","description":"This page documents behaviors and features specific to the SQL Server backend in SeaORM X.","source":"@site/docs/06-mssql-features/01-mssql-features.md","sourceDirName":"06-mssql-features","slug":"/mssql-features/mssql-features","permalink":"/SeaORM-X/docs/mssql-features/mssql-features","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM-X/docs/06-mssql-features/01-mssql-features.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1772312761000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Insert","permalink":"/SeaORM-X/docs/basic-crud/insert"}}');var i=s(8790),t=s(2204);const r={},l="MSSQL-Specific Features",c={},d=[{value:"Nested Transactions via Savepoints",id:"nested-transactions-via-savepoints",level:2},{value:"Automatic Schema Rewriting",id:"automatic-schema-rewriting",level:2},{value:"Tuple <code>IN</code> Fallback",id:"tuple-in-fallback",level:2},{value:"i64 / i32 Type Coercion",id:"i64--i32-type-coercion",level:2},{value:"<code>execute_unprepared</code> via Raw TDS Batch",id:"execute_unprepared-via-raw-tds-batch",level:2},{value:"Entity-First Workflow",id:"entity-first-workflow",level:2},{value:"Schema-First Codegen",id:"schema-first-codegen",level:2},{value:"Query Builder with <code>MsSqlQueryBuilder</code>",id:"query-builder-with-mssqlquerybuilder",level:2},{value:"Schema Discovery",id:"schema-discovery",level:2},{value:"API Documentation",id:"api-documentation",level:2},{value:"Limitations",id:"limitations",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mssql-specific-features",children:"MSSQL-Specific Features"})}),"\n",(0,i.jsx)(n.p,{children:"This page documents behaviors and features specific to the SQL Server backend in SeaORM X."}),"\n",(0,i.jsx)(n.h2,{id:"nested-transactions-via-savepoints",children:"Nested Transactions via Savepoints"}),"\n",(0,i.jsx)(n.p,{children:"SQLz tracks transaction depth and maps it to MSSQL's savepoint syntax transparently:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Depth"}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"begin"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"commit"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"rollback"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0 \u2192 1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BEGIN TRAN"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"COMMIT TRAN"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ROLLBACK TRAN"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"n \u2192 n+1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SAVE TRAN _sqlz_savepoint_n"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.em,{children:"(no-op: SQL Server releases savepoints implicitly)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ROLLBACK TRAN _sqlz_savepoint_n"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Rolling back an inner block unwinds only to the savepoint, leaving the outer transaction intact:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let txn = db.begin().await?;\n\n{\n    let txn = txn.begin().await?;\n    let _ = bakery::ActiveModel {\n        name: Set("Nested Bakery".to_owned()), ..\n    }.save(&txn).await?;\n    assert_eq!(Bakery::find().all(&txn).await?.len(), 3);\n\n    {\n        let txn = txn.begin().await?;\n        let _ = bakery::ActiveModel {\n            name: Set("Rock n Roll Bakery".to_owned()), ..\n        }.save(&txn).await?;\n        assert_eq!(Bakery::find().all(&txn).await?.len(), 4);\n        // txn dropped here without commit: rolls back to savepoint\n    }\n    assert_eq!(Bakery::find().all(&txn).await?.len(), 3);\n\n    {\n        let txn = txn.begin().await?;\n        let _ = bakery::ActiveModel {\n            name: Set("Rock n Roll Bakery".to_owned()), ..\n        }.save(&txn).await?;\n        txn.commit().await?;\n    }\n    txn.commit().await?;\n}\n\nassert_eq!(Bakery::find().all(&txn).await?.len(), 4);\ntxn.commit().await?;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(n.code,{children:"Transaction"})," is dropped without an explicit commit, SQLz spawns a local async task to execute ",(0,i.jsx)(n.code,{children:"ROLLBACK"})," immediately and marks the connection as ",(0,i.jsx)(n.code,{children:"RollingBack"}),". Any subsequent use of that connection awaits the rollback task before proceeding."]}),"\n",(0,i.jsx)(n.h2,{id:"automatic-schema-rewriting",children:"Automatic Schema Rewriting"}),"\n",(0,i.jsxs)(n.p,{children:["When a connection is configured with a non-default schema (e.g. ",(0,i.jsx)(n.code,{children:"currentSchema=my_schema"}),"), SeaORM X automatically prefixes every outgoing statement with that schema. No manual ",(0,i.jsx)(n.code,{children:"[schema].[table]"})," boilerplate needed."]}),"\n",(0,i.jsx)(n.p,{children:"The rewriting propagates recursively into subqueries, JOINs, and CTE branches."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let db = Database::connect(\n    "mssql://user:pass@localhost:1433/my_db?currentSchema=my_schema"\n).await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let related = cake::Entity::find()\n    .has_related(filling::Entity, filling::Column::Name.eq("Marmalade"))\n    .all(db)\n    .await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT [cake].[id], [cake].[name] FROM [my_schema].[cake]\nWHERE EXISTS(SELECT 1 FROM [my_schema].[filling]\n  INNER JOIN [my_schema].[cake_filling]\n    ON [cake_filling].[filling_id] = [filling].[id]\n  WHERE [filling].[name] = 'Marmalade'\n  AND [cake].[id] = [cake_filling].[cake_id])\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"tuple-in-fallback",children:["Tuple ",(0,i.jsx)(n.code,{children:"IN"})," Fallback"]}),"\n",(0,i.jsxs)(n.p,{children:["MSSQL does not support tuple value syntax (",(0,i.jsx)(n.code,{children:"(c1, c2) IN ((v1, v2), ...)"}),"). SeaORM X provides ",(0,i.jsx)(n.code,{children:"EntityTrait::column_tuple_in()"}),", which expands to ",(0,i.jsx)(n.code,{children:"(c1 = v1 AND c2 = v2) OR ..."})," when targeting MSSQL:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'cake::Entity::find()\n    .filter(cake::Entity::column_tuple_in(\n        [cake::Column::Id, cake::Column::Name],\n        &[(1i32, "a").into_value_tuple(), (2i32, "b").into_value_tuple()],\n        DbBackend::MsSql,\n    ).unwrap())\n    .build(DbBackend::MsSql)\n    .to_string();\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- MSSQL: automatically expands to AND/OR\nSELECT [cake].[id], [cake].[name] FROM [cake]\nWHERE ([cake].[id] = 1 AND [cake].[name] = 'a')\n   OR ([cake].[id] = 2 AND [cake].[name] = 'b')\n"})}),"\n",(0,i.jsx)(n.p,{children:"On MySQL or PostgreSQL, the same method generates native tuple syntax."}),"\n",(0,i.jsx)(n.h2,{id:"i64--i32-type-coercion",children:"i64 / i32 Type Coercion"}),"\n",(0,i.jsxs)(n.p,{children:["MSSQL returns ",(0,i.jsx)(n.code,{children:"INT"})," columns as ",(0,i.jsx)(n.code,{children:"i32"})," at the wire level. SeaORM X handles the coercion to ",(0,i.jsx)(n.code,{children:"i64"})," transparently: no schema changes or manual casting required."]}),"\n",(0,i.jsxs)(n.h2,{id:"execute_unprepared-via-raw-tds-batch",children:[(0,i.jsx)(n.code,{children:"execute_unprepared"})," via Raw TDS Batch"]}),"\n",(0,i.jsxs)(n.p,{children:["For DDL and migration scenarios, ",(0,i.jsx)(n.code,{children:"execute_unprepared"})," uses the raw TDS ",(0,i.jsx)(n.code,{children:"execute_batch"})," path rather than prepared statements. This preserves temp-table visibility across statement batches, which is a common requirement for MSSQL migration and stored-procedure patterns that break under prepared statement isolation."]}),"\n",(0,i.jsx)(n.h2,{id:"entity-first-workflow",children:"Entity-First Workflow"}),"\n",(0,i.jsx)(n.p,{children:"Define entities in Rust and let SeaORM sync the schema to MSSQL. Tables, columns, unique keys, and foreign keys are created in topological order:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"db.get_schema_builder()\n    .register(order::Entity)\n    .register(store::Entity)\n    .sync(db)\n    .await?;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This requires the ",(0,i.jsx)(n.code,{children:"schema-sync"})," feature flag."]}),"\n",(0,i.jsx)(n.h2,{id:"schema-first-codegen",children:"Schema-First Codegen"}),"\n",(0,i.jsxs)(n.p,{children:["Point ",(0,i.jsx)(n.code,{children:"sea-orm-cli"})," at an existing MSSQL database to generate entity files:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:'sea-orm-cli generate entity \\\n  --database-url "mssql://sa:pass@localhost/AdventureWorksLT2016" \\\n  --database-schema "SalesLT" \\\n  --entity-format dense\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[sea_orm(schema_name = "SalesLT", table_name = "Address")]\npub struct Model {\n    #[sea_orm(column_name = "AddressID", primary_key)]\n    pub address_id: i32,\n    #[sea_orm(column_name = "AddressLine1")]\n    pub address_line1: String,\n    pub rowguid: Uuid,\n    // ...\n}\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"query-builder-with-mssqlquerybuilder",children:["Query Builder with ",(0,i.jsx)(n.code,{children:"MsSqlQueryBuilder"})]}),"\n",(0,i.jsxs)(n.p,{children:["SeaQuery X generates MSSQL-native syntax with bracket quoting and ",(0,i.jsx)(n.code,{children:"@P"})," parameter binding:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    Query::select()\n        .column(Glyph::Image)\n        .from(Glyph::Table)\n        .and_where(Expr::col(Glyph::Image).like("A"))\n        .and_where(Expr::col(Glyph::Id).is_in([1, 2, 3]))\n        .build(MsSqlQueryBuilder),\n    (\n        "SELECT [image] FROM [glyph] WHERE [image] LIKE @P1 AND [id] IN (@P2, @P3, @P4)"\n            .to_owned(),\n        Values(vec![\n            Value::String(Some(Box::new("A".to_owned()))),\n            Value::Int(Some(1)),\n            Value::Int(Some(2)),\n            Value::Int(Some(3))\n        ])\n    )\n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["DDL uses MSSQL-native types (",(0,i.jsx)(n.code,{children:"IDENTITY"}),", ",(0,i.jsx)(n.code,{children:"nvarchar"}),", etc.):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let table = Table::create()\n    .table(Glyph::Table)\n    .col(\n        ColumnDef::new(Glyph::Id)\n            .integer()\n            .not_null()\n            .auto_increment()\n            .primary_key(),\n    )\n    .col(ColumnDef::new(Glyph::Image).string().not_null())\n    .to_owned();\n\nassert_eq!(\n    table.to_string(MsSqlQueryBuilder),\n    [\n        r#"CREATE TABLE [glyph] ("#,\n        r#"[id] int NOT NULL IDENTITY PRIMARY KEY,"#,\n        r#"[image] nvarchar(255) NOT NULL"#,\n        r#")"#,\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"schema-discovery",children:"Schema Discovery"}),"\n",(0,i.jsx)(n.p,{children:"SeaSchema X discovers MSSQL schemas programmatically, including columns, data types, identity columns, indexes, foreign keys, collations, and default expressions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let options: MsSqlConnectOptions =\n    "mssql://sa:password@localhost/AdventureWorksLT2016".parse()?;\nlet connection = MsSqlPool::connect_with(options).await?;\nlet schema_discovery = SchemaDiscovery::new(connection, Some("SalesLT"));\n\nlet schema = schema_discovery.discover().await?;\n// schema.tables contains full table definitions with columns, indexes, and foreign keys\n'})}),"\n",(0,i.jsx)(n.h2,{id:"api-documentation",children:"API Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/docs/sea-orm-x/sea_orm/",children:"sea-orm-x"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/docs/sea-orm-x/sea_query/",children:"sea-query-x"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/docs/sea-orm-x/sea_schema/",children:"sea-schema-x"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/docs/sea-orm-x/sqlz/",children:"sqlz"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsx)(n.p,{children:"SQLz is a purpose-built SQL Server driver, not a full SQLx port. Known gaps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No compile-time query checking."})," SQLx's ",(0,i.jsx)(n.code,{children:"sqlx::query!"})," macro verifies SQL against a live database at compile time. SQLz has no equivalent; queries are checked at runtime only."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No custom type encoding/decoding."})," SQLx supports user-defined ",(0,i.jsx)(n.code,{children:"Encode"}),"/",(0,i.jsx)(n.code,{children:"Decode"})," implementations for arbitrary Rust types. SQLz ships a fixed set of supported types (primitives, ",(0,i.jsx)(n.code,{children:"uuid"}),", ",(0,i.jsx)(n.code,{children:"Decimal"}),", ",(0,i.jsx)(n.code,{children:"BigDecimal"}),", ",(0,i.jsx)(n.code,{children:"chrono"}),", ",(0,i.jsx)(n.code,{children:"time"}),", ",(0,i.jsx)(n.code,{children:"serde_json"}),") behind feature flags. Adding a new wire type requires changes inside SQLz itself."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);