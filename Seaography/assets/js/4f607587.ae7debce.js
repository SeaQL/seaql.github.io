"use strict";(self.webpackChunkseaography=self.webpackChunkseaography||[]).push([[928],{7373:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"custom-endpoints/custom-query","title":"Custom Query","description":"Define a new struct and apply the CustomFields macro.","source":"@site/docs/04-custom-endpoints/02-custom-query.md","sourceDirName":"04-custom-endpoints","slug":"/custom-endpoints/custom-query","permalink":"/Seaography/docs/custom-endpoints/custom-query","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Seaography/docs/04-custom-endpoints/02-custom-query.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1761178810000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Project Structure","permalink":"/Seaography/docs/custom-endpoints/project-structure"},"next":{"title":"Custom Mutation","permalink":"/Seaography/docs/custom-endpoints/custom-mutation"}}');var o=t(8790),r=t(8032);const i={},a="Custom Query",u={},c=[{value:"Custom query with Custom Ouput",id:"custom-query-with-custom-ouput",level:2},{value:"Custom query with SeaORM Models",id:"custom-query-with-seaorm-models",level:2},{value:"Custom query with pagination",id:"custom-query-with-pagination",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"custom-query",children:"Custom Query"})}),"\n",(0,o.jsxs)(n.p,{children:["Define a new struct and apply the ",(0,o.jsx)(n.code,{children:"CustomFields"})," macro."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="queries.rs"',children:"use async_graphql::Context;\nuse seaography::{CustomFields};\n\npub struct Operations;\n\n#[CustomFields]\nimpl Operations {\n    // this will become the name of the field\n    async my_query(\n        ctx: &Context<'_>, // GraphQL context\n        // parameters can be Seaography structs or structs derived by CustomInputType\n    ) -> async_graphql::Result<()>\n        // return value must be async_graphql::Result<T>\n        // can return SeaORM Models or structs derived by CustomOutputType\n    {\n        // function body\n        Ok(())\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"custom-query-with-custom-ouput",children:"Custom query with Custom Ouput"}),"\n",(0,o.jsx)(n.p,{children:"You can define nested data structures as custom output objects:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, CustomOutputType)]\npub struct PurchaseOrder {\n    pub po_number: String,\n    pub lineitems: Vec<Lineitem>, // \u2b05 nested list\n}\n\n#[derive(Clone, CustomOutputType)]\npub struct Lineitem {\n    pub product: String,\n    pub quantity: Decimal,         // \u2b05 non-built-in type\n    pub size: Option<ProductSize>, // \u2b05 nested object\n}\n\n#[derive(Clone, CustomOutputType)]\npub struct ProductSize {\n    pub size: i32,\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can use them in custom query endpoints:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'#[CustomFields]\nimpl Operations {\n    async fn purchase_order(\n        _ctx: &Context<\'_>,\n        po_number: String, // \u2b05 named parameter\n    ) -> async_graphql::Result<PurchaseOrder> {\n        // here we simply hard code the object, but you can totally make a REST API call\n        // and deserialize the JSON result with serde!\n\n        Ok(PurchaseOrder {\n            po_number: "AB1234".into(),\n            lineitems: vec![\n                Lineitem {\n                    product: "Towel".into(),\n                    quantity: "2".parse().unwrap(),\n                    size: Some(ProductSize { size: 4 }),\n                },\n                Lineitem {\n                    product: "Soap".into(),\n                    quantity: "2.5".parse().unwrap(),\n                    size: None,\n                },\n            ],\n        })\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"custom-query-with-seaorm-models",children:"Custom query with SeaORM Models"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"#[CustomFields]\nimpl Operations {\n    async fn find_film_by(\n        ctx: &Context<'_>,\n        title: String, // \u2b05 named parameter\n    ) -> async_graphql::Result<Vec<film::Model>> {\n        let db = ctx.data::<DatabaseConnection>()?;\n        //  \u2b06 this is a normal SeaORM db connection\n\n        //  \u2b07 your business logic, of course will be more complicated\n        let models = film::Entity::find()\n            .filter(film::Column::Title.contains(title))\n            .all(db)\n            .await?;\n\n        Ok(models)\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"custom-query-with-pagination",children:"Custom query with pagination"}),"\n",(0,o.jsx)(n.p,{children:"Let's say we have a Customer entity. We want to create a custom endpoint, like the one Seaography already provides, but with an additional requirement: only return customers of the current store from which the user makes request from."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="customer.rs"',children:'//! This is an entity from the sakila schema, generated by sea-orm-cli\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "customer")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub customer_id: i32,\n    pub store_id: i32,\n    pub first_name: String,\n    pub last_name: String,\n    ..\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",metastring:'title="queries.rs"',children:"use seaography::{apply_pagination, Connection, CustomFields, PaginationInput};\n\n#[CustomFields]\nimpl Operations {\n    async fn customer_of_current_store(\n        ctx: &Context<'_>,\n        pagination: PaginationInput,\n        //          \u2b06 this input struct is provided by Seaography\n    ) -> async_graphql::Result<Connection<customer::Entity>> {\n        //  this output struct \u2b06 is provided by Seaography\n        let db = ctx.data::<DatabaseConnection>()?;\n        //  \u2b06 this is a normal SeaORM db connection\n        let session = ctx.data::<Session>()?;\n        //  \u2b06 this session is inject by the HTTP handler\n        let query = customer::Entity::find()\n        //          \u2b06 this is the same old SeaORM API\n            .filter(customer::Column::StoreId.eq(session.store_id));\n        //  \u2b06 here we implement our custom logic\n        // note that here, we haven't execute the query yet ..\n        // instead, we pass it to Seaography to handle the rest!\n        let connection = apply_pagination(&CONTEXT, db, query, pagination).await?;\n        //                                         now the query executes \u2b06 \n\n        Ok(connection)\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This would expose the following query endpoint:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"customer_of_current_store(\n  pagination: PaginationInput\n): CustomerConnection!\n"})}),"\n",(0,o.jsx)(n.p,{children:"Query it like the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"{\n  customer_of_current_store(pagination: { page: { page: 0, limit: 10 } }) {\n    nodes {\n      storeId\n      customerId\n      firstName\n      lastName\n      email\n    }\n    paginationInfo {\n      pages\n      current\n    }\n  }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8032:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(2374);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);