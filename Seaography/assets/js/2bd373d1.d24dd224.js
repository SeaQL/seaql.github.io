"use strict";(self.webpackChunkseaography=self.webpackChunkseaography||[]).push([[7643],{3260:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"access-control/considerations","title":"Considerations","description":"Authorization is a broad topic, and there is no single \\"right\\" way to implement it.","source":"@site/docs/06-access-control/06-considerations.md","sourceDirName":"06-access-control","slug":"/access-control/considerations","permalink":"/Seaography/docs/access-control/considerations","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Seaography/docs/06-access-control/06-considerations.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1761251444000,"sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Role Based Access Control","permalink":"/Seaography/docs/access-control/RBAC"}}');var i=n(8790),t=n(8032);const o={},a="Considerations",c={},l=[{value:"Schema\u2011level restrictions",id:"schemalevel-restrictions",level:2},{value:"Role\u2011based access control (RBAC)",id:"rolebased-access-control-rbac",level:2},{value:"Ownership\u2011based access",id:"ownershipbased-access",level:2},{value:"Service\u2011level separation",id:"servicelevel-separation",level:2},{value:"Layering strategies",id:"layering-strategies",level:2}];function d(e){const s={br:"br",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"considerations",children:"Considerations"})}),"\n",(0,i.jsx)(s.p,{children:'Authorization is a broad topic, and there is no single "right" way to implement it.'}),"\n",(0,i.jsx)(s.p,{children:"The best approach depends on the needs of your application, the sensitivity of the data you expose, and the types of users you serve.\nSeaography gives you the flexibility to apply different strategies, individually or in combination, to achieve the level of control you require."}),"\n",(0,i.jsx)(s.h2,{id:"schemalevel-restrictions",children:"Schema\u2011level restrictions"}),"\n",(0,i.jsx)(s.p,{children:"If certain data should never be exposed, the simplest and strongest option is to remove it from the GraphQL schema entirely.\nBy omitting entities, fields, or mutations, you ensure that clients cannot query them at all.\nThis is the most secure approach when access is not needed under any circumstance."}),"\n",(0,i.jsx)(s.h2,{id:"rolebased-access-control-rbac",children:"Role\u2011based access control (RBAC)"}),"\n",(0,i.jsxs)(s.p,{children:["For applications such as ",(0,i.jsx)(s.strong,{children:"admin portals or back\u2011office tools"}),", access is often determined by user roles (e.g. ",(0,i.jsx)(s.em,{children:"admin"}),", ",(0,i.jsx)(s.em,{children:"editor"}),", ",(0,i.jsx)(s.em,{children:"viewer"}),")."]}),"\n",(0,i.jsx)(s.p,{children:"At runtime, Seaography can evaluate these policies before resolving queries or mutations."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Deny by default"})," - only explicitly granted actions are allowed."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Role assignments"})," - attach roles to principals (users, API keys, tenants)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Role hierarhy"})," - roles can be inherited."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:'Combining RBAC with Entity Filters, it lets you implement rules such as "admins can update any post", "viewer is read-only", "users can only update their own posts".'}),"\n",(0,i.jsx)(s.h2,{id:"ownershipbased-access",children:"Ownership\u2011based access"}),"\n",(0,i.jsxs)(s.p,{children:["For ",(0,i.jsx)(s.strong,{children:"end\u2011user facing applications"}),", resources often have an ",(0,i.jsx)(s.em,{children:"owner"})," (e.g. a user's own posts, orders, or profile).",(0,i.jsx)(s.br,{}),"\n","In these cases, you can enforce access by:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Adding ",(0,i.jsx)(s.strong,{children:"Filters"})," to queries so users only see their own data."]}),"\n",(0,i.jsxs)(s.li,{children:["Using ",(0,i.jsx)(s.strong,{children:"Guards"})," on mutations to ensure a user can only read, update or delete resources they own."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This pattern is common in SaaS where each user should only interact with their own records."}),"\n",(0,i.jsx)(s.h2,{id:"servicelevel-separation",children:"Service\u2011level separation"}),"\n",(0,i.jsxs)(s.p,{children:["In more complex systems, you may choose to split responsibilities across ",(0,i.jsx)(s.strong,{children:"multiple microservices"}),".",(0,i.jsx)(s.br,{}),"\n","For example:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A dedicated service for public, read\u2011only queries."}),"\n",(0,i.jsx)(s.li,{children:"A separate service for administrative operations."}),"\n",(0,i.jsx)(s.li,{children:"Another service for sensitive, user\u2011owned data."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This separation can simplify reasoning about access rules and reduce the blast radius of misconfiguration."}),"\n",(0,i.jsx)(s.h2,{id:"layering-strategies",children:"Layering strategies"}),"\n",(0,i.jsx)(s.p,{children:"These strategies are not mutually exclusive. In fact, combining them often yields the strongest security setup:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Schema restrictions"})," to hide what should never be exposed."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"RBAC"})," to differentiate between classes of users."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Filters"})," to ensure ownership."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Guards"})," to double check / enforce rules."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"By layering these approaches, you can tailor Seaography's authorization model to match both your security requirements and your application's complexity."})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8032:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var r=n(2374);const i={},t=r.createContext(i);function o(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);