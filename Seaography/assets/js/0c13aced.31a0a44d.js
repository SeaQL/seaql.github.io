"use strict";(self.webpackChunkseaography=self.webpackChunkseaography||[]).push([[7823],{8032:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var a=n(2374);const r={},s=a.createContext(r);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:t},e.children)}},9353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"access-control/authentication","title":"Authentication","description":"No matter which web framework you are using, authentication should be well-supported. You can follow their documentation for instructions.","source":"@site/docs/06-access-control/01-authentication.md","sourceDirName":"06-access-control","slug":"/access-control/authentication","permalink":"/Seaography/docs/access-control/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Seaography/docs/06-access-control/01-authentication.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1761482611000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Pagination","permalink":"/Seaography/docs/customizations/pagination"},"next":{"title":"Schema Restrictions","permalink":"/Seaography/docs/access-control/schema-restrictions"}}');var r=n(8790),s=n(8032);const o={},c="Authentication",i={},h=[{value:"Axum",id:"axum",level:4},{value:"Poem",id:"poem",level:4},{value:"Actix",id:"actix",level:4},{value:"Loco",id:"loco",level:4},{value:"Resolver Context",id:"resolver-context",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"authentication",children:"Authentication"})}),"\n",(0,r.jsx)(t.p,{children:"No matter which web framework you are using, authentication should be well-supported. You can follow their documentation for instructions."}),"\n",(0,r.jsx)(t.p,{children:"The relevant function is the graphql handler, in which you can add JWT handling:"}),"\n",(0,r.jsx)(t.h4,{id:"axum",children:"Axum"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"async fn graphql_handler(State(schema): State<Schema>, req: GraphQLRequest) -> GraphQLResponse {\n    let req = req.into_inner();\n    schema.execute(req).await.into()\n}\n"})}),"\n",(0,r.jsx)(t.h4,{id:"poem",children:"Poem"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[handler]\nasync fn graphql_handler(schema: Data<&Schema>, req: GraphQLRequest) -> GraphQLResponse {\n    let req = req.0;\n    schema.execute(req).await.into()\n}\n"})}),"\n",(0,r.jsx)(t.h4,{id:"actix",children:"Actix"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"async fn graphql_handler(schema: web::Data<Schema>, req: GraphQLRequest) -> GraphQLResponse {\n    schema.execute(req.into_inner()).await.into()\n}\n"})}),"\n",(0,r.jsx)(t.h4,{id:"loco",children:"Loco"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"async fn graphql_handler(State(ctx): State<AppContext>, req: GraphQLRequest)\n    -> Result<async_graphql_axum::GraphQLResponse, (axum::http::StatusCode, &'static str)> {\n    let schema: Schema = ctx.shared_store.get()?;\n    schema.execute(req.into_inner()).await.into()\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"resolver-context",children:"Resolver Context"}),"\n",(0,r.jsx)(t.p,{children:"After verifying the user's identity, you should inject it to the resolver context:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"async fn graphql_handler(token: Jwt, ..) -> Result<..> {\n    let user_id = verify_jwt_and_get_user_id(token);\n\n    let mut req = req.into_inner();\n    req = req.data(seaography::UserContext { user_id });\n\n    schema.execute(req).await.into()\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"This session context can then be used in the resolver, including your custom queries / mutations."})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);