"use strict";(self.webpackChunkseaography=self.webpackChunkseaography||[]).push([[104],{8032:(e,a,t)=>{t.d(a,{R:()=>r,x:()=>o});var s=t(2374);const i={},n=s.createContext(i);function r(e){const a=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(n.Provider,{value:a},e.children)}},9551:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"introduction/seaography","title":"Why Seaography","description":"What is GraphQL","source":"@site/docs/01-introduction/01-seaography.md","sourceDirName":"01-introduction","slug":"/introduction/seaography","permalink":"/Seaography/docs/introduction/seaography","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Seaography/docs/01-introduction/01-seaography.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1761178810000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Index","permalink":"/Seaography/docs/index"},"next":{"title":"Bootstrap Project","permalink":"/Seaography/docs/getting-started/bootstrap"}}');var i=t(8790),n=t(8032);const r={},o="Why Seaography",l={},d=[{value:"What is GraphQL",id:"what-is-graphql",level:2},{value:"Benefits of GraphQL",id:"benefits-of-graphql",level:3},{value:"Precise data fetching",id:"precise-data-fetching",level:4},{value:"Strongly typed schema",id:"strongly-typed-schema",level:4},{value:"Unified data access",id:"unified-data-access",level:4},{value:"Async-GraphQL",id:"async-graphql",level:2},{value:"Concurrent field resolution",id:"concurrent-field-resolution",level:4},{value:"Complexity &amp; depth limits",id:"complexity--depth-limits",level:4},{value:"Strongly-typed schema",id:"strongly-typed-schema-1",level:4},{value:"Seaography",id:"seaography",level:2},{value:"Derive macros &amp; faster builds",id:"derive-macros--faster-builds",level:4},{value:"Seamless SeaORM integration",id:"seamless-seaorm-integration",level:4},{value:"Full\u2011stack solution",id:"fullstack-solution",level:4}];function c(e){const a={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"why-seaography",children:"Why Seaography"})}),"\n",(0,i.jsx)(a.h2,{id:"what-is-graphql",children:"What is GraphQL"}),"\n",(0,i.jsx)(a.p,{children:"GraphQL, originally open-sourced by Facebook, is both a query language and a runtime for APIs. Instead of exposing multiple endpoints like REST, GraphQL provides a single endpoint where clients can specify the exact fields and relationships they want. This makes responses predictable and shaped exactly like the request."}),"\n",(0,i.jsx)(a.h3,{id:"benefits-of-graphql",children:"Benefits of GraphQL"}),"\n",(0,i.jsx)(a.h4,{id:"precise-data-fetching",children:"Precise data fetching"}),"\n",(0,i.jsx)(a.p,{children:"Clients avoid over-fetching or under-fetching by requesting only the fields they need."}),"\n",(0,i.jsx)(a.h4,{id:"strongly-typed-schema",children:"Strongly typed schema"}),"\n",(0,i.jsx)(a.p,{children:"The schema acts as a contract between client and server, improving validation, documentation, and developer experience."}),"\n",(0,i.jsx)(a.h4,{id:"unified-data-access",children:"Unified data access"}),"\n",(0,i.jsx)(a.p,{children:"GraphQL can aggregate data from multiple sources into one query, reducing round-trips. All API requests go through a single POST endpoint."}),"\n",(0,i.jsx)(a.h2,{id:"async-graphql",children:"Async-GraphQL"}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.a,{href:"https://docs.rs/async-graphql/latest/async_graphql/",children:"async-graphql"})," is a Rust library that implements the GraphQL specification with a asynchronous execution model, strong type safety, and dynamic schema definition. It offers:"]}),"\n",(0,i.jsx)(a.h4,{id:"concurrent-field-resolution",children:"Concurrent field resolution"}),"\n",(0,i.jsx)(a.p,{children:"If a query requests multiple independent fields, async\u2011graphql can fetch them in parallel."}),"\n",(0,i.jsx)(a.h4,{id:"complexity--depth-limits",children:"Complexity & depth limits"}),"\n",(0,i.jsx)(a.p,{children:"Built\u2011in guards to prevent denial\u2011of\u2011service via overly complex queries."}),"\n",(0,i.jsx)(a.h4,{id:"strongly-typed-schema-1",children:"Strongly-typed schema"}),"\n",(0,i.jsx)(a.p,{children:"Automatic validation ensures schema and resolvers remain consistent."}),"\n",(0,i.jsx)(a.h2,{id:"seaography",children:"Seaography"}),"\n",(0,i.jsx)(a.p,{children:"Seaography is built on top of async\u2011graphql, offering a set of derive macros, seamless integration with SeaORM, and advanced query capabilities out of the box."}),"\n",(0,i.jsx)(a.h4,{id:"derive-macros--faster-builds",children:"Derive macros & faster builds"}),"\n",(0,i.jsx)(a.p,{children:"Seaography provides a set of derive macros for dynamic schema that mirror those used for static schemas in async\u2011graphql. This makes defining custom GraphQL endpoints easy but also addresses the problem of slow compilation as schema complexity grows."}),"\n",(0,i.jsx)(a.h4,{id:"seamless-seaorm-integration",children:"Seamless SeaORM integration"}),"\n",(0,i.jsx)(a.p,{children:"Seaography integrates directly with SeaORM, adding minimal overhead while offering advanced relational query capabilities."}),"\n",(0,i.jsx)(a.h4,{id:"fullstack-solution",children:"Full\u2011stack solution"}),"\n",(0,i.jsxs)(a.p,{children:["Seaography covers all the needs of building complex applications - from data access, backend API, access control to frontend integration (",(0,i.jsx)(a.a,{href:"https://www.sea-ql.org/sea-orm-pro",children:"SeaORM Pro"}),")."]})]})}function h(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);