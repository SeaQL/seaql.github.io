"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[3277],{2538:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"streamer/consumer","title":"Consumer","description":"The Consumer trait defines the common interface of stream consumers.","source":"@site/versioned_docs/version-0.2.x/03-streamer/03-consumer.md","sourceDirName":"03-streamer","slug":"/streamer/consumer","permalink":"/preview/pr-150/SeaStreamer/docs/0.2.x/streamer/consumer","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.2.x/03-streamer/03-consumer.md","tags":[],"version":"0.2.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1755628065000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Producer","permalink":"/preview/pr-150/SeaStreamer/docs/0.2.x/streamer/producer"},"next":{"title":"Inter Process","permalink":"/preview/pr-150/SeaStreamer/docs/0.2.x/processors/inter-process"}}');var a=n(8790),r=n(6484);const t={},o="Consumer",d={},c=[{value:"<code>ConsumerOptions</code>",id:"consumeroptions",level:2},{value:"<code>ConsumerMode</code>",id:"consumermode",level:3},{value:"<code>RealTime</code>",id:"realtime",level:4},{value:"<code>Resumable</code>",id:"resumable",level:4},{value:"Redis / Kafka semantics",id:"redis--kafka-semantics",level:4},{value:"Redis semantics",id:"redis-semantics",level:4},{value:"<code>LoadBalanced</code>",id:"loadbalanced",level:4},{value:"<code>ConsumerGroup</code>",id:"consumergroup",level:3},{value:"Kafka semantics",id:"kafka-semantics",level:4},{value:"Redis semantics",id:"redis-semantics-1",level:4},{value:"Stdio semantics",id:"stdio-semantics",level:4},{value:"<code>next</code>",id:"next",level:2},{value:"<code>stream</code>",id:"stream",level:2},{value:"<code>assign</code>",id:"assign",level:2},{value:"<code>unassign</code>",id:"unassign",level:2},{value:"<code>rewind</code>",id:"rewind",level:2},{value:"Kafka semantics",id:"kafka-semantics-1",level:4},{value:"Redis semantics",id:"redis-semantics-2",level:4},{value:"Stdio semantics",id:"stdio-semantics-1",level:4},{value:"<code>seek</code>",id:"seek",level:2},{value:"Kafka semantics",id:"kafka-semantics-2",level:4},{value:"Redis semantics",id:"redis-semantics-3",level:4},{value:"Stdio semantics",id:"stdio-semantics-2",level:4}];function l(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"consumer",children:"Consumer"})}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.a,{href:"https://docs.rs/sea-streamer/*/sea_streamer/trait.Consumer.html",children:(0,a.jsx)(s.code,{children:"Consumer"})})," trait defines the common interface of stream consumers."]}),"\n",(0,a.jsx)(s.p,{children:"Implemented by:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"https://docs.rs/sea-streamer-kafka/*/sea_streamer_kafka/struct.KafkaConsumer.html",children:(0,a.jsx)(s.code,{children:"KafkaConsumer"})})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"https://docs.rs/sea-streamer-redis/*/sea_streamer_redis/struct.RedisConsumer.html",children:(0,a.jsx)(s.code,{children:"RedisConsumer"})})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"https://docs.rs/sea-streamer-stdio/*/sea_streamer_stdio/struct.StdioConsumer.html",children:(0,a.jsx)(s.code,{children:"StdioConsumer"})})}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"consumeroptions",children:(0,a.jsx)(s.code,{children:"ConsumerOptions"})}),"\n",(0,a.jsx)(s.h3,{id:"consumermode",children:(0,a.jsx)(s.code,{children:"ConsumerMode"})}),"\n",(0,a.jsx)(s.p,{children:"There are 3 modes:"}),"\n",(0,a.jsx)(s.h4,{id:"realtime",children:(0,a.jsx)(s.code,{children:"RealTime"})}),"\n",(0,a.jsx)(s.p,{children:"This is the 'vanilla' stream consumer. It does not auto-commit, and thus only consumes messages from now on."}),"\n",(0,a.jsx)(s.h4,{id:"resumable",children:(0,a.jsx)(s.code,{children:"Resumable"})}),"\n",(0,a.jsx)(s.p,{children:"When the process restarts, it will resume the stream from the previous committed sequence."}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"redis--kafka-semantics",children:"Redis / Kafka semantics"}),(0,a.jsx)(s.p,{children:"It will use a group id unique to this host: on a physical machine, it will use the mac address.\nInside a docker container, it will use the container id."})]}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"redis-semantics",children:"Redis semantics"}),(0,a.jsxs)(s.p,{children:["Redis requires consumers to self-assign consumer IDs. If unset, SeaStreamer uses a combination of ",(0,a.jsx)(s.code,{children:"host id"})," + ",(0,a.jsx)(s.code,{children:"process id"})," + ",(0,a.jsx)(s.code,{children:"thread id"})," + ",(0,a.jsx)(s.code,{children:"timestamp"}),"."]})]}),"\n",(0,a.jsx)(s.h4,{id:"loadbalanced",children:(0,a.jsx)(s.code,{children:"LoadBalanced"})}),"\n",(0,a.jsx)(s.p,{children:"You should assign a consumer group manually. The load-balancing mechanism is implementation-specific."}),"\n",(0,a.jsx)(s.h3,{id:"consumergroup",children:(0,a.jsx)(s.code,{children:"ConsumerGroup"})}),"\n",(0,a.jsx)(s.p,{children:"A consumer group is a string for clients to identify themselves to the streaming server. So that when you reconnect, the states can be downloaded from the server. From the broker's point of view, it is all that matters. The client can connect from any host or network."}),"\n",(0,a.jsx)(s.p,{children:"Multiple consumers can share the same consumer group, and remain connected to the server at the same time. Usually, the intention is to achieve load-balancing. The precise semantics is backend-specific."}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"kafka-semantics",children:"Kafka semantics"}),(0,a.jsx)(s.p,{children:"If multiple consumers shares the same group, only one consumer in the group will receive a message, i.e. it is load-balanced."}),(0,a.jsx)(s.p,{children:"However, the load-balancing mechanism is what makes Kafka different:"}),(0,a.jsx)(s.p,{children:"Each stream is divided into multiple shards (known as partition), and each partition will be assigned to only one consumer in a group."}),(0,a.jsx)(s.p,{children:"Say there are 2 consumers (in the group) and 2 partitions, then each consumer will receive messages from one partition, and they are thus load-balanced."}),(0,a.jsx)(s.p,{children:"If there are 2 consumers and 3 partitions, then one consumer will be assigned 2 partitions, and the other will be assigned only 1."}),(0,a.jsx)(s.p,{children:"However if the stream has only 1 partition, even if there are many consumers, these messages will only be received by the assigned consumer, and other consumers will be in stand-by mode, resulting in a hot-failover setup."})]}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"redis-semantics-1",children:"Redis semantics"}),(0,a.jsx)(s.p,{children:"Multiple consumers in the same group share the same stream. This is load-balanced in a first-ask-first-served manner. This can be considered dynamic load-balancing: faster consumers will consume more messages."}),(0,a.jsxs)(s.p,{children:["As a consequence, ",(0,a.jsx)(s.code,{children:"ack"})," has to be done per message. It becomes two steps in SeaStreamer, ack and commit: ",(0,a.jsx)(s.code,{children:"ack"})," is non-blocking, it will buffer acks internally and ",(0,a.jsx)(s.code,{children:"commit"})," to Redis at a regular interval, or upon your request. There are multiple ",(0,a.jsx)(s.a,{href:"https://docs.rs/sea-streamer-redis/*/sea_streamer_redis/enum.AutoCommit.html",children:"auto ack / commit mechanisms"})," to choose from: ",(0,a.jsx)(s.code,{children:"Immediate"}),", ",(0,a.jsx)(s.code,{children:"Delayed"}),", ",(0,a.jsx)(s.code,{children:"Rolling"}),", and ",(0,a.jsx)(s.code,{children:"Disabled"}),"."]}),(0,a.jsxs)(s.p,{children:["SeaStreamer also implements automatic failover, where leftover messages for other consumers can be 'claimed' after a set period of time, assuming they are dead. This can be configured via the ",(0,a.jsx)(s.a,{href:"https://docs.rs/sea-streamer-redis/*/sea_streamer_redis/struct.RedisConsumerOptions.html#method.set_auto_claim_interval",children:"auto claim"})," options."]})]}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"stdio-semantics",children:"Stdio semantics"}),(0,a.jsx)(s.p,{children:"If multiple consumers share the same group, only one in the group will receive a message.\nThis is load-balanced in a round-robin fashion."})]}),"\n",(0,a.jsx)(s.h2,{id:"next",children:(0,a.jsx)(s.code,{children:"next"})}),"\n",(0,a.jsx)(s.p,{children:"Poll and receive one message: it awaits until there are new messages.\nThis method can be called from multiple threads."}),"\n",(0,a.jsx)(s.h2,{id:"stream",children:(0,a.jsx)(s.code,{children:"stream"})}),"\n",(0,a.jsxs)(s.p,{children:["Returns an async stream which implements the ",(0,a.jsx)(s.a,{href:"https://docs.rs/futures-core/*/futures_core/stream/trait.Stream.html",children:"Stream Trait"}),". You cannot create multiple streams from the same consumer, nor perform any operation while streaming."]}),"\n",(0,a.jsx)(s.p,{children:"It allows you to do neat things:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-rust",children:"let items = consumer\n    .stream()\n    .take(num)\n    .map(process_message)\n    .collect::<Vec<_>>()\n    .await\n"})}),"\n",(0,a.jsx)(s.h2,{id:"assign",children:(0,a.jsx)(s.code,{children:"assign"})}),"\n",(0,a.jsx)(s.p,{children:"Assign this consumer to a particular shard. Can be called multiple times to assign\nto multiple shards. You cannot assign streams that has not been subscribed."}),"\n",(0,a.jsxs)(s.p,{children:["It will only take effect on the next ",(0,a.jsx)(s.code,{children:"Consumer::seek"})," or ",(0,a.jsx)(s.code,{children:"Consumer::rewind"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"unassign",children:(0,a.jsx)(s.code,{children:"unassign"})}),"\n",(0,a.jsxs)(s.p,{children:["Unassign a shard. Returns ",(0,a.jsx)(s.code,{children:"ConsumerNotAssigned"})," if this consumer has not been assigned to this stream or shard."]}),"\n",(0,a.jsx)(s.h2,{id:"rewind",children:(0,a.jsx)(s.code,{children:"rewind"})}),"\n",(0,a.jsx)(s.p,{children:"Rewind the stream to a particular sequence number."}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"kafka-semantics-1",children:"Kafka semantics"}),(0,a.jsx)(s.p,{children:"If the consumer is not already assigned, shard ZERO will be used. This async method is not cancel safe. You must await this future, and this Consumer will be unusable for any operations until it finishes."})]}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"redis-semantics-2",children:"Redis semantics"}),(0,a.jsx)(s.p,{children:"In Redis a sequence number comprises a timestamp, so rewind is nearly the same as seek, but more precise: you can rewind to a particular point within a millisecond."})]}),"\n",(0,a.jsxs)(s.admonition,{type:"caution",children:[(0,a.jsx)(s.h4,{id:"stdio-semantics-1",children:"Stdio semantics"}),(0,a.jsx)(s.p,{children:"This is not implemented by the Stdio backend."})]}),"\n",(0,a.jsx)(s.h2,{id:"seek",children:(0,a.jsx)(s.code,{children:"seek"})}),"\n",(0,a.jsxs)(s.p,{children:["Seek all streams to the given point in time. It will start consuming from the earliest message with a timestamp later than ",(0,a.jsx)(s.code,{children:"to"}),"."]}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"kafka-semantics-2",children:"Kafka semantics"}),(0,a.jsx)(s.p,{children:"This will self-assign all shards. This async method is not cancel safe. You must await this future, and this Consumer will be unusable for any operations until it finishes."})]}),"\n",(0,a.jsxs)(s.admonition,{type:"info",children:[(0,a.jsx)(s.h4,{id:"redis-semantics-3",children:"Redis semantics"}),(0,a.jsx)(s.p,{children:"Seeking a Consumer will detach it from the Consumer Group, if it has been assigned one. It effectively makes it a RealTime Consumer."})]}),"\n",(0,a.jsxs)(s.admonition,{type:"caution",children:[(0,a.jsx)(s.h4,{id:"stdio-semantics-2",children:"Stdio semantics"}),(0,a.jsx)(s.p,{children:"This is not implemented by the Stdio backend."})]})]})}function m(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},6484:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>o});var i=n(2374);const a={},r=i.createContext(a);function t(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);