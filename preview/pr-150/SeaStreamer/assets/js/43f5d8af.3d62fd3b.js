"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[838],{6290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"whats-next/vision","title":"The Vision","description":"We want to make Rust the best data engineering platform, with tools that span from development to production.","source":"@site/versioned_docs/version-0.3.x/05-whats-next/02-vision.md","sourceDirName":"05-whats-next","slug":"/whats-next/vision","permalink":"/preview/pr-150/SeaStreamer/docs/whats-next/vision","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.3.x/05-whats-next/02-vision.md","tags":[],"version":"0.3.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756074242000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"The Roadmap","permalink":"/preview/pr-150/SeaStreamer/docs/whats-next/roadmap"}}');var o=n(8790),i=n(6484);const r={},a="The Vision",c={},d=[{value:"The <code>sed</code> for streams",id:"the-sed-for-streams",level:2},{value:"Inter Process Communication",id:"inter-process-communication",level:2},{value:"Inter Host Communication",id:"inter-host-communication",level:2},{value:"Your idea",id:"your-idea",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"the-vision",children:"The Vision"})}),"\n",(0,o.jsx)(t.p,{children:"We want to make Rust the best data engineering platform, with tools that span from development to production."}),"\n",(0,o.jsxs)(t.p,{children:["Below is just part of my imagination, hopefully we will be able to realize them ",(0,o.jsx)(t.em,{children:"some day"}),"!"]}),"\n",(0,o.jsxs)(t.h2,{id:"the-sed-for-streams",children:["The ",(0,o.jsx)(t.code,{children:"sed"})," for streams"]}),"\n",(0,o.jsxs)(t.p,{children:["Since we've talked about shells a lot, it will be great if we have an equivalent to ",(0,o.jsx)(t.code,{children:"sed"})," that allow us to filter, transform and combine structured messages with a scripting language."]}),"\n",(0,o.jsx)(t.h2,{id:"inter-process-communication",children:"Inter Process Communication"}),"\n",(0,o.jsx)(t.p,{children:"Right now pipe is the only mechanism for connecting processors together, which is copy-heavy. For some high-throughput scenario, sharded memory could fair better."}),"\n",(0,o.jsx)(t.h2,{id:"inter-host-communication",children:"Inter Host Communication"}),"\n",(0,o.jsx)(t.p,{children:"Right now the only way to connect across host is to rely on a streaming server. In a containerized environment, it might make sense to allow processors to communicate privately via TCP streams."}),"\n",(0,o.jsx)(t.h2,{id:"your-idea",children:"Your idea"}),"\n",(0,o.jsxs)(t.p,{children:["We welcome you to join our ",(0,o.jsx)(t.a,{href:"https://github.com/SeaQL/sea-streamer/discussions",children:"Discussions"})," if you have ideas or insights!"]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},6484:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(2374);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);