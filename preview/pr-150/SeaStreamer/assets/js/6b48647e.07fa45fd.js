"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[5677],{2843:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"introduction/async-programming","title":"Async Programming in Rust","description":"Async programming in Rust is a recent development, only having been stabilized in Rust 1.39. The async ecosystem is rapidly evolving, and SeaStreamer is an async-only library.","source":"@site/docs/01-introduction/02-async-programming.md","sourceDirName":"01-introduction","slug":"/introduction/async-programming","permalink":"/preview/pr-150/SeaStreamer/docs/next/introduction/async-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/docs/01-introduction/02-async-programming.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756199656000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Intro to Stream Processing","permalink":"/preview/pr-150/SeaStreamer/docs/next/introduction/intro-to-streams"},"next":{"title":"SeaStreamer Concepts","permalink":"/preview/pr-150/SeaStreamer/docs/next/introduction/sea-streamer"}}');var s=n(8790),a=n(6484);const i={},o="Async Programming in Rust",c={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"async-programming-in-rust",children:"Async Programming in Rust"})}),"\n",(0,s.jsxs)(t.p,{children:["Async programming in Rust is a recent development, only having been stabilized in Rust ",(0,s.jsx)(t.a,{href:"https://github.com/rust-lang/rust/releases/tag/1.39.0",children:(0,s.jsx)(t.code,{children:"1.39"})}),". The async ecosystem is rapidly evolving, and SeaStreamer is an async-only library."]}),"\n",(0,s.jsxs)(t.p,{children:["The first concept to learn is the ",(0,s.jsx)(t.a,{href:"https://rust-lang.github.io/async-book/02_execution/02_future.html",children:(0,s.jsx)(t.code,{children:"Future"})})," trait. ",(0,s.jsx)(t.code,{children:"Future"})," allows us to achieve concurrency with little programming effort, e.g. ",(0,s.jsx)(t.a,{href:"https://docs.rs/futures/latest/futures/future/fn.join_all.html",children:(0,s.jsx)(t.code,{children:"future::join_all"})})," to execute multiple tasks in parallel."]}),"\n",(0,s.jsxs)(t.p,{children:["The second concept to learn is the ",(0,s.jsx)(t.a,{href:"https://docs.rs/futures-core/latest/futures_core/stream/trait.Stream.html",children:(0,s.jsx)(t.code,{children:"Stream"})})," trait. It's like ",(0,s.jsx)(t.a,{href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html",children:(0,s.jsx)(t.code,{children:"Iterator"})}),", but async. It is very powerful, and allows us to manipulate streams ergonomically by composing ",(0,s.jsx)(t.code,{children:"Map"}),", ",(0,s.jsx)(t.code,{children:"Filter"})," and ",(0,s.jsx)(t.code,{children:"Fold"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Third, there are multiple async runtimes in Rust. ",(0,s.jsx)(t.a,{href:"https://crates.io/crates/async-std",children:(0,s.jsx)(t.code,{children:"async-std"})})," and ",(0,s.jsx)(t.a,{href:"https://crates.io/crates/tokio",children:(0,s.jsx)(t.code,{children:"tokio"})})," are the two most widely used in production, and SeaStreamer supports both of them. These async runtimes are multi-threaded, meaning that a Future may be moved between threads, but it can only happen at ",(0,s.jsx)(t.code,{children:".await"})," points. There is true parallelism - so race condition and contention can and do happen."]}),"\n",(0,s.jsx)(t.p,{children:"Understanding these concepts is essential to get your hands on real-time async programming in Rust."})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},6484:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(2374);const s={},a=r.createContext(s);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);