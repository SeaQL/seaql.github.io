"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[7592],{3367:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"streamer/streamer","title":"Streamer","description":"The Streamer trait defines the common interface of streaming clients.","source":"@site/versioned_docs/version-0.3.x/03-streamer/01-streamer.md","sourceDirName":"03-streamer","slug":"/streamer/streamer","permalink":"/preview/pr-150/SeaStreamer/docs/streamer/streamer","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.3.x/03-streamer/01-streamer.md","tags":[],"version":"0.3.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756120076000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Example Processors","permalink":"/preview/pr-150/SeaStreamer/docs/getting-started/examples"},"next":{"title":"Producer","permalink":"/preview/pr-150/SeaStreamer/docs/streamer/producer"}}');var n=s(8790),i=s(6484);const a={},c="Streamer",d={},o=[{value:"Kafka semantics",id:"kafka-semantics",level:4},{value:"Redis semantics",id:"redis-semantics",level:4},{value:"Stdio semantics",id:"stdio-semantics",level:4},{value:"File semantics",id:"file-semantics",level:4},{value:"<code>ConnectOptions</code>",id:"connectoptions",level:2},{value:"<code>timeout</code>",id:"timeout",level:3},{value:"<code>connect</code>",id:"connect",level:2},{value:"<code>disconnect</code>",id:"disconnect",level:2},{value:"<code>create_producer</code>",id:"create_producer",level:2},{value:"<code>create_generic_producer</code>",id:"create_generic_producer",level:2},{value:"<code>create_consumer</code>",id:"create_consumer",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"streamer",children:"Streamer"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://docs.rs/sea-streamer/*/sea_streamer/trait.Streamer.html",children:(0,n.jsx)(t.code,{children:"Streamer"})})," trait defines the common interface of streaming clients."]}),"\n",(0,n.jsx)(t.p,{children:"Implemented by:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.rs/sea-streamer-kafka/*/sea_streamer_kafka/struct.KafkaStreamer.html",children:(0,n.jsx)(t.code,{children:"KafkaStreamer"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.rs/sea-streamer-redis/*/sea_streamer_redis/struct.RedisStreamer.html",children:(0,n.jsx)(t.code,{children:"RedisStreamer"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.rs/sea-streamer-stdio/*/sea_streamer_stdio/struct.StdioStreamer.html",children:(0,n.jsx)(t.code,{children:"StdioStreamer"})})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://docs.rs/sea-streamer-file/*/sea_streamer_file/struct.FileStreamer.html",children:(0,n.jsx)(t.code,{children:"FileStreamer"})})}),"\n"]}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsx)(t.h4,{id:"kafka-semantics",children:"Kafka semantics"}),(0,n.jsxs)(t.p,{children:["Consult ",(0,n.jsx)(t.a,{href:"https://kafka.apache.org/documentation/#intro_concepts_and_terms",children:"https://kafka.apache.org/documentation/#intro_concepts_and_terms"})," for a gentle introduction."]})]}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsx)(t.h4,{id:"redis-semantics",children:"Redis semantics"}),(0,n.jsx)(t.p,{children:"SeaStreamer Redis aims to provide a Kafka-like client experience, but there are some fundamental differences between Redis and Kafka:"}),(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"In Redis sequence numbers are not contiguous"}),"\n",(0,n.jsx)(t.li,{children:"In Redis messages are dispatched to consumers among group members in a first-ask-first-served manner, which leads to the next point"}),"\n",(0,n.jsx)(t.li,{children:"In Redis ACK has to be done per message"}),"\n"]})]}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsx)(t.h4,{id:"stdio-semantics",children:"Stdio semantics"}),(0,n.jsxs)(t.p,{children:["The Stdio backend spawn two dedicated threads to handle stdin and stdout respectively. The host part of the Streamer URI is always empty, i.e. in ",(0,n.jsx)(t.code,{children:"stdio://"}),", the host is ",(0,n.jsx)(t.code,{children:" "}),". There is only shard ",(0,n.jsx)(t.code,{children:"ZERO"}),"."]})]}),"\n",(0,n.jsxs)(t.admonition,{type:"info",children:[(0,n.jsx)(t.h4,{id:"file-semantics",children:"File semantics"}),(0,n.jsx)(t.p,{children:"In File, unlike Stdio, there can be multiple independent Streamers in the same process."}),(0,n.jsxs)(t.p,{children:["In File, unlike other backends, it is possible to signify end of stream with a ",(0,n.jsx)(t.code,{children:"EOS"})," message. See the ",(0,n.jsx)(t.a,{href:"https://docs.rs/sea-streamer-file/latest/sea_streamer_file/struct.FileConnectOptions.html#method.set_end_with_eos",children:(0,n.jsx)(t.code,{children:"end_with_eos"})})," option."]}),(0,n.jsxs)(t.p,{children:["Currently it only streams to Shard ",(0,n.jsx)(t.code,{children:"ZERO"}),"."]}),(0,n.jsx)(t.p,{children:"If the file is removed from the file system, the streamer would stop."})]}),"\n",(0,n.jsx)(t.h2,{id:"connectoptions",children:(0,n.jsx)(t.code,{children:"ConnectOptions"})}),"\n",(0,n.jsx)(t.h3,{id:"timeout",children:(0,n.jsx)(t.code,{children:"timeout"})}),"\n",(0,n.jsx)(t.p,{children:"Set the default network timeout for all connections."}),"\n",(0,n.jsx)(t.h2,{id:"connect",children:(0,n.jsx)(t.code,{children:"connect"})}),"\n",(0,n.jsxs)(t.p,{children:["Establish a connection to the streaming server. The ",(0,n.jsx)(t.code,{children:"Streamer"})," implementation does not have to maintain an open connection to the server."]}),"\n",(0,n.jsx)(t.h2,{id:"disconnect",children:(0,n.jsx)(t.code,{children:"disconnect"})}),"\n",(0,n.jsxs)(t.p,{children:["Disconnect from the streaming server. The intention is to flush remaining messages and exit gracefully. You have to ",(0,n.jsx)(t.code,{children:"await"})," this operation until it completes. Once you called this method, all producers and consumers created will become unusable."]}),"\n",(0,n.jsx)(t.h2,{id:"create_producer",children:(0,n.jsx)(t.code,{children:"create_producer"})}),"\n",(0,n.jsx)(t.p,{children:"Create a producer that streams to the specified stream."}),"\n",(0,n.jsx)(t.h2,{id:"create_generic_producer",children:(0,n.jsx)(t.code,{children:"create_generic_producer"})}),"\n",(0,n.jsx)(t.p,{children:"Create a producer that can stream to any stream."}),"\n",(0,n.jsx)(t.h2,{id:"create_consumer",children:(0,n.jsx)(t.code,{children:"create_consumer"})}),"\n",(0,n.jsx)(t.p,{children:"Create a consumer subscribing to the specified streams."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},6484:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>c});var r=s(2374);const n={},i=r.createContext(n);function a(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);