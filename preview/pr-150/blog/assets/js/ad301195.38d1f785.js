"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[1113],{7630:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(2374);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},7931:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var s=t(9118),a=t(8790),r=t(7630);const i={slug:"2023-11-22-async-runtime-generic",title:"Writing Async Runtime Generic Library",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",tags:["news"]},o=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Approach 1: Defining your own <code>AsyncRuntime</code> trait",id:"approach-1-defining-your-own-asyncruntime-trait",level:3},{value:"Approach 2: Abstract the async runtimes internally and expose feature flags",id:"approach-2-abstract-the-async-runtimes-internally-and-expose-feature-flags",level:3},{value:"Approach 3: Maintain an async runtime abstraction crate",id:"approach-3-maintain-an-async-runtime-abstraction-crate",level:3},{value:"Conclusion",id:"conclusion",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"If you are writing an async application in Rust, at some point you'd want to separate the code into several crates. There are some benefits:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Better encapsulation. Having a crate boundary between sub-systems can lead to cleaner code and a more well-defined API. No more ",(0,a.jsx)(n.code,{children:"pub(crate)"}),"!"]}),"\n",(0,a.jsx)(n.li,{children:"Faster compilation. By breaking down a big crate into several independent small crates, they can be compiled concurrently."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"But the question is, if you are using only one async runtime anyway, what are the benefits of writing async-runtime-generic libraries?"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Portability. You can easily switch to a different async runtime, or wasm."}),"\n",(0,a.jsxs)(n.li,{children:["Correctness. Testing a library against both ",(0,a.jsx)(n.code,{children:"tokio"})," and ",(0,a.jsx)(n.code,{children:"async-std"}),' can uncover more bugs, including concurrency bugs (due to fuzzy task execution orders) and "undefined behaviour" either due to misunderstanding or async-runtime implementation details']}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"So now you've decided to write async-runtime-generic libraries! Here I want to share 3 strategies along with examples found in the Rust ecosystem."}),"\n",(0,a.jsxs)(n.h3,{id:"approach-1-defining-your-own-asyncruntime-trait",children:["Approach 1: Defining your own ",(0,a.jsx)(n.code,{children:"AsyncRuntime"})," trait"]}),"\n",(0,a.jsxs)(n.p,{children:["Using the ",(0,a.jsx)(n.a,{href:"https://docs.rs/futures/latest/futures/",children:(0,a.jsx)(n.code,{children:"futures"})})," crate you can write very generic library code, but there is one missing piece: ",(0,a.jsx)(n.code,{children:"time"})," - to ",(0,a.jsx)(n.code,{children:"sleep"})," or ",(0,a.jsx)(n.code,{children:"timeout"}),", you have to rely on an async runtime. If that's all you need, you can define your own ",(0,a.jsx)(n.code,{children:"AsyncRuntime"})," trait and requires downstream to implement it. This is the approach used by ",(0,a.jsx)(n.a,{href:"https://docs.rs/rdkafka/latest/rdkafka/",children:"rdkafka"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub trait AsyncRuntime: Send + Sync + 'static {\n    type Delay: Future<Output = ()> + Send;\n\n    /// It basically means the return value must be a `Future`\n    fn sleep(duration: Duration) -> Self::Delay;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here is how it's implemented:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"impl AsyncRuntime for TokioRuntime {\n    type Delay = tokio::time::Sleep;\n\n    fn sleep(duration: Duration) -> Self::Delay {\n        tokio::time::sleep(duration)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Library code to use the above:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"async fn operation<R: AsyncRuntime>() {\n    R::sleep(Duration::from_millis(1)).await;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"approach-2-abstract-the-async-runtimes-internally-and-expose-feature-flags",children:"Approach 2: Abstract the async runtimes internally and expose feature flags"}),"\n",(0,a.jsxs)(n.p,{children:["This is the approach used by ",(0,a.jsx)(n.a,{href:"https://docs.rs/redis/latest/redis/",children:"redis-rs"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To work with network connections or file handle, you can use the ",(0,a.jsx)(n.code,{children:"AsyncRead"})," / ",(0,a.jsx)(n.code,{children:"AsyncWrite"})," traits:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[async_trait]\npub(crate) trait AsyncRuntime: Send + Sync + 'static {\n    type Connection: AsyncRead + AsyncWrite + Send + Sync + 'static;\n\n    async fn connect(addr: SocketAddr) -> std::io::Result<Self::Connection>;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then you'll define a module for each async runtime:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[cfg(feature = "runtime-async-std")]\nmod async_std_impl;\n#[cfg(feature = "runtime-async-std")]\nuse async_std_impl::*;\n\n#[cfg(feature = "runtime-tokio")]\nmod tokio_impl;\n#[cfg(feature = "runtime-tokio")]\nuse tokio_impl::*;\n'})}),"\n",(0,a.jsx)(n.p,{children:"Where each module would look like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="tokio_impl.rs"',children:"#[async_trait]\nimpl AsyncRuntime for TokioRuntime {\n    type Connection = tokio::net::TcpStream;\n\n    async fn connect(addr: SocketAddr) -> std::io::Result<Self::Connection> {\n        tokio::net::TcpStream::connect(addr).await\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Library code to use the above:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'async fn operation<R: AsyncRuntime>(conn: R::Connection) {\n    conn.write(b"some bytes").await;\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"approach-3-maintain-an-async-runtime-abstraction-crate",children:"Approach 3: Maintain an async runtime abstraction crate"}),"\n",(0,a.jsxs)(n.p,{children:["This is the approach used by ",(0,a.jsx)(n.a,{href:"https://docs.rs/crate/sqlx-rt",children:"SQLx"})," and ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-streamer-runtime/latest/sea_streamer_runtime/",children:"SeaStreamer"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Basically, aggregate all async runtime APIs you'd use and write a wrapper library. This may be tedious, but this also has the benefit of specifying ",(0,a.jsx)(n.em,{children:"all interactions"})," with the async runtime ",(0,a.jsx)(n.em,{children:"in one place"})," for ",(0,a.jsx)(n.em,{children:"your"})," project, which could be handy for debugging or tracing."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, async ",(0,a.jsx)(n.code,{children:"Task"})," handling:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="common-async-runtime/tokio_task.rs"',children:"pub use tokio::task::{JoinHandle as TaskHandle};\n\npub fn spawn_task<F, T>(future: F) -> TaskHandle<T>\nwhere\n    F: Future<Output = T> + Send + 'static,\n    T: Send + 'static,\n{\n    tokio::task::spawn(future)\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"async-std"}),"'s task API is slightly different (in ",(0,a.jsx)(n.code,{children:"tokio"})," the output is ",(0,a.jsx)(n.code,{children:"Result<T, JoinError>"}),"), which requires some boilerplate:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:'title="common-async-runtime/async_std_task.rs"',children:"/// A shim to match tokio's API\npub struct TaskHandle<T>(async_std::task::JoinHandle<T>);\n\npub fn spawn_task<F, T>(future: F) -> TaskHandle<T>\nwhere\n    F: Future<Output = T> + Send + 'static,\n    T: Send + 'static,\n{\n    TaskHandle(async_std::task::spawn(future))\n}\n\n#[derive(Debug)]\npub struct JoinError;\n\nimpl std::error::Error for JoinError {}\n\n// This is basically how you wrap a `Future`\nimpl<T> Future for TaskHandle<T> {\n    type Output = Result<T, JoinError>;\n\n    fn poll(\n        mut self: std::pin::Pin<&mut Self>,\n        cx: &mut std::task::Context<'_>,\n    ) -> std::task::Poll<Self::Output> {\n        match self.0.poll_unpin(cx) {\n            std::task::Poll::Ready(res) => std::task::Poll::Ready(Ok(res)),\n            std::task::Poll::Pending => std::task::Poll::Pending,\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the library's ",(0,a.jsx)(n.code,{children:"Cargo.toml"}),", you can simply include ",(0,a.jsx)(n.code,{children:"common-async-runtime"})," as dependency. This makes your library code 'pure', because now selecting an async runtime is controlled by downstream. Similar to approach 1, this crate can be compiled ",(0,a.jsx)(n.em,{children:"without any"})," async runtime, which is neat!"]}),"\n",(0,a.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(n.p,{children:["Happy hacking! Welcome to share your experience with the ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-streamer/discussions",children:"community"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},9118:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-150/blog/2023-11-22-async-runtime-generic","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2023-11-22-async-runtime-generic.md","source":"@site/blog/2023-11-22-async-runtime-generic.md","title":"Writing Async Runtime Generic Library","description":"If you are writing an async application in Rust, at some point you\'d want to separate the code into several crates. There are some benefits:","date":"2023-11-22T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-150/blog/tags/news"}],"readingTime":3.49,"hasTruncateMarker":false,"authors":[{"name":"Chris Tsang","title":"SeaQL Team","url":"https://github.com/tyt2y3","imageURL":"https://avatars.githubusercontent.com/u/1782664?v=4","key":null,"page":null}],"frontMatter":{"slug":"2023-11-22-async-runtime-generic","title":"Writing Async Runtime Generic Library","author":"Chris Tsang","author_title":"SeaQL Team","author_url":"https://github.com/tyt2y3","author_image_url":"https://avatars.githubusercontent.com/u/1782664?v=4","tags":["news"]},"unlisted":false,"prevItem":{"title":"OpenUK Award 2023 \ud83c\udfc6","permalink":"/preview/pr-150/blog/2023-11-25-openuk-award"},"nextItem":{"title":"What\'s new in SeaStreamer 0.3","permalink":"/preview/pr-150/blog/2023-09-06-whats-new-in-sea-streamer-0.3"}}')}}]);