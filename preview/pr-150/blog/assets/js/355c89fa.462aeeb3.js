"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[9905],{3216:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-150/blog/2023-02-05-faq-02","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2023-02-05-faq-02.md","source":"@site/blog/2023-02-05-faq-02.md","title":"SeaORM FAQ.02","description":"FAQ.02 Why the empty enum Relation {} is needed even if an Entity has no relations?","date":"2023-02-05T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-150/blog/tags/news"}],"readingTime":1.225,"hasTruncateMarker":false,"authors":[{"name":"Chris Tsang","title":"SeaQL Team","url":"https://github.com/tyt2y3","imageURL":"https://avatars.githubusercontent.com/u/1782664?v=4","key":null,"page":null}],"frontMatter":{"slug":"2023-02-05-faq-02","title":"SeaORM FAQ.02","author":"Chris Tsang","author_title":"SeaQL Team","author_url":"https://github.com/tyt2y3","author_image_url":"https://avatars.githubusercontent.com/u/1782664?v=4","tags":["news"]},"unlisted":false,"prevItem":{"title":"What\'s new in SeaORM 0.11.0","permalink":"/preview/pr-150/blog/2023-02-08-whats-new-in-seaorm-0.11.0"},"nextItem":{"title":"Internship @ SeaQL","permalink":"/preview/pr-150/blog/2023-01-28-internship-at-seaql"}}')},6264:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>h});var i=n(3216),a=n(8790),s=n(7630);const r={slug:"2023-02-05-faq-02",title:"SeaORM FAQ.02",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",tags:["news"]},l=void 0,o={authorsImageUrls:[void 0]},h=[{value:"FAQ.02 Why the empty enum <code>Relation {}</code> is needed even if an Entity has no relations?",id:"faq02-why-the-empty-enum-relation--is-needed-even-if-an-entity-has-no-relations",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.h2,{id:"faq02-why-the-empty-enum-relation--is-needed-even-if-an-entity-has-no-relations",children:["FAQ.02 Why the empty enum ",(0,a.jsx)(t.code,{children:"Relation {}"})," is needed even if an Entity has no relations?"]}),"\n",(0,a.jsxs)(t.p,{children:["Consider the following example ",(0,a.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/examples/actix_example/entity/src/post.rs",children:"Post"})," Entity:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "posts")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub title: String,\n    pub text: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The two lines for defining ",(0,a.jsx)(t.code,{children:"Relation"})," is quite unnecessary right?"]}),"\n",(0,a.jsx)(t.p,{children:"To explain the problem, let's dive slightly deeper into the macro-expanded entity:"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"DeriveRelation"})," macro simply implements the ",(0,a.jsx)(t.code,{children:"RelationTrait"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"impl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            _ => unreachable!()\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Which in turn is needed by ",(0,a.jsx)(t.code,{children:"EntityTrait"})," as an associated type:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"impl EntityTrait for Entity {\n    type Relation = Relation;\n    ...\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"It would be ideal if, when the user does not specify this associated type, the library automatically fills in a stub to satisfy the type system?"}),"\n",(0,a.jsxs)(t.p,{children:["Turns out, there is such a feature in Rust! It is an unstable feature called ",(0,a.jsx)(t.a,{href:"https://rust-lang.github.io/rfcs/2532-associated-type-defaults.html",children:(0,a.jsx)(t.code,{children:"associated_type_defaults"})}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Basically, it allows trait definitions to specify a default associated type, allowing it to be elided:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"// only compiles in nightly\ntrait EntityTrait {\n    type Relation: Relation = EmptyRelation;\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Due to our commitment to stable Rust, this may not land in SeaORM very soon. When it is stabilized, do remind us to implement this feature to get rid of those two lines!"})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},7630:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var i=n(2374);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);