"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[9636],{678:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-150/blog/2025-08-20-sea-query-1.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-08-20-sea-query-1.0.md","source":"@site/blog/2025-08-20-sea-query-1.0.md","title":"The road to SeaQuery 1.0","description":"SeaQuery 0.1.0 was first released on 2020-12-16 - it\'s been a few years! Since then, there have been 32 releases, each introducing a set of new features. As with many software projects, the organic evolution driven by a diverse community of open source contributors has led to occasional inconsistencies across the codebase. It\'s a good problem to have, and a testament to our vibrant community. But now, it\'s time to stabilize SeaQuery and address some of these issues.","date":"2025-08-20T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-150/blog/tags/news"}],"readingTime":15.175,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-08-20-sea-query-1.0","title":"The road to SeaQuery 1.0","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"SeaQuery just made writing raw SQL more enjoyable","permalink":"/preview/pr-150/blog/2025-08-15-sea-query-raw-sql"}}')},5394:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var s=a(678),t=a(8790),r=a(7630);const i={slug:"2025-08-20-sea-query-1.0",title:"The road to SeaQuery 1.0",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png",tags:["news"]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Architectural changes",id:"architectural-changes",level:2},{value:"Forbid unsafe code",id:"forbid-unsafe-code",level:3},{value:"Unify <code>Expr</code> and <code>SimpleExpr</code> as one type",id:"unify-expr-and-simpleexpr-as-one-type",level:3},{value:"Potential compile errors",id:"potential-compile-errors",level:4},{value:"Revamp <code>Iden</code> type system.",id:"revamp-iden-type-system",level:3},{value:"Potential compile errors",id:"potential-compile-errors-1",level:4},{value:"<code>Alias::new</code> is no longer needed",id:"aliasnew-is-no-longer-needed",level:3},{value:"Unbox <code>Value</code> variants",id:"unbox-value-variants",level:3},{value:"Potential compile errors",id:"potential-compile-errors-2",level:4},{value:"<code>non_exhaustive</code> AST enums",id:"non_exhaustive-ast-enums",level:3},{value:"Potential compile errors",id:"potential-compile-errors-3",level:4},{value:"Reworked <code>TableRef</code> and <code>ColumnRef</code>",id:"reworked-tableref-and-columnref",level:3},{value:"Potential compile errors",id:"potential-compile-errors-4",level:4},{value:"New Features",id:"new-features",level:2},{value:"Query Audit",id:"query-audit",level:3},{value:"Ergonomic raw SQL",id:"ergonomic-raw-sql",level:3},{value:"Breaking Changes",id:"breaking-changes",level:2},{value:"Replaced <code>SERIAL</code> with <code>GENERATED BY DEFAULT AS IDENTITY</code> (Postgres)",id:"replaced-serial-with-generated-by-default-as-identity-postgres",level:3},{value:"Changed <code>IntoXXX</code> traits into <code>Into&lt;XXX&gt;</code>",id:"changed-intoxxx-traits-into-intoxxx",level:3},{value:"Performance Improvements",id:"performance-improvements",level:2},{value:"Replaced <code>write!</code> with <code>write_str</code>",id:"replaced-write-with-write_str",level:3},{value:"Refactor Writer to avoid string allocation",id:"refactor-writer-to-avoid-string-allocation",level:3},{value:"Refactor Tokenizer to avoid string allocation",id:"refactor-tokenizer-to-avoid-string-allocation",level:3},{value:"Release Plan",id:"release-plan",level:2},{value:"Our Team",id:"our-team",level:2},{value:"Sponsor",id:"sponsor",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:4},{value:"GitHub Sponsors",id:"github-sponsors",level:4},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("img",{alt:"SeaQuery 1.0 Banner",src:"/blog/img/SeaQuery%201.0%20Banner.png"}),"\n",(0,t.jsx)(n.p,{children:"SeaQuery 0.1.0 was first released on 2020-12-16 - it's been a few years! Since then, there have been 32 releases, each introducing a set of new features. As with many software projects, the organic evolution driven by a diverse community of open source contributors has led to occasional inconsistencies across the codebase. It's a good problem to have, and a testament to our vibrant community. But now, it's time to stabilize SeaQuery and address some of these issues."}),"\n",(0,t.jsx)(n.p,{children:"A very brief recap of important SeaQuery verisons:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"version"}),(0,t.jsx)(n.th,{children:"date"}),(0,t.jsx)(n.th,{children:"notes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0.1.0"}),(0,t.jsx)(n.td,{children:"2020-12-16"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://www.reddit.com/r/rust/comments/kkle6j/seaquery_is_a_database_agnostic_runtime_query/",children:"initial release"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0.16.0"}),(0,t.jsx)(n.td,{children:"2021-09-02"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2021-09-20-introducing-sea-orm/",children:"SeaORM 0.1"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0.30.0"}),(0,t.jsx)(n.td,{children:"2023-07-20"}),(0,t.jsx)(n.td,{children:"SeaORM 0.12"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0.31.0"}),(0,t.jsx)(n.td,{children:"2024-08-02"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2024-08-04-sea-orm-1.0/",children:"SeaORM 1.0"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0.32.0"}),(0,t.jsx)(n.td,{children:"2024-10-17"}),(0,t.jsx)(n.td,{children:"SeaORM 1.1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"0.32.7"}),(0,t.jsx)(n.td,{children:"2025-08-06"}),(0,t.jsx)(n.td,{children:"latest version"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"architectural-changes",children:"Architectural changes"}),"\n",(0,t.jsx)(n.p,{children:"There are a few architectural changes that can only be made by breaking the API, so let's go through them one by one:"}),"\n",(0,t.jsx)(n.h3,{id:"forbid-unsafe-code",children:"Forbid unsafe code"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/930",children:"#930"}),"\n",(0,t.jsx)(n.code,{children:"#![forbid(unsafe_code)]"})," has been added to all workspace crates, ensuring that SeaQuery no longer contains any unsafe code. While only one instance of unsafe was previously used, and has now been removed, this change reinforces our commitment to maintaining code quality."]}),"\n",(0,t.jsxs)(n.h3,{id:"unify-expr-and-simpleexpr-as-one-type",children:["Unify ",(0,t.jsx)(n.code,{children:"Expr"})," and ",(0,t.jsx)(n.code,{children:"SimpleExpr"})," as one type"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/890",children:"#890"})," Previously, a lot of operator methods (e.g. ",(0,t.jsx)(n.code,{children:"eq"}),") were duplicated across ",(0,t.jsx)(n.code,{children:"Expr"})," and ",(0,t.jsx)(n.code,{children:"SimpleExpr"}),", but the list of methods was slightly different for each. Also, it wasn't clear when to use each of the two types. The type conversions were sometimes non-obvious. It complicated the type system and made writing generic code difficult."]}),"\n",(0,t.jsxs)(n.p,{children:["In 0.32.0, almost a year ago, we added ",(0,t.jsx)(n.code,{children:"ExprTrait"})," (",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/771",children:"#771"}),') to standardize and share the list of methods, and to allow calling them on other "lower-level" types like so: ',(0,t.jsx)(n.code,{children:'1_i32.cast_as("REAL")'}),". At that time, we decided to keep the original inherent methods for compatibility. That worsened the duplication even further, bloating the codebase by ~1300 lines of code."]}),"\n",(0,t.jsxs)(n.p,{children:["Later, we looked into the ",(0,t.jsx)(n.code,{children:"Expr"})," vs ",(0,t.jsx)(n.code,{children:"SimpleExpr"})," distinction. It turned out that ",(0,t.jsx)(n.code,{children:"Expr"}),' was primarily meant to be a "namespace" of static constructors for ',(0,t.jsx)(n.code,{children:"SimpleExpr"}),", similar to ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-query/0.32.7/sea_query/func/struct.Func.html",children:(0,t.jsx)(n.code,{children:"Func"})})," vs ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-query/0.32.7/sea_query/func/struct.FunctionCall.html",children:(0,t.jsx)(n.code,{children:"FunctionCall"})}),". But unlike ",(0,t.jsx)(n.code,{children:"Func"}),", which is a unit struct, ",(0,t.jsx)(n.code,{children:"Expr"})," was given its own data fields, which turned out to be a mistake and led users to pass around ",(0,t.jsx)(n.code,{children:"Expr"}),"s instead of ",(0,t.jsx)(n.code,{children:"SimpleExpr"}),"s."]}),"\n",(0,t.jsxs)(n.p,{children:["In 1.0, ",(0,t.jsx)(n.code,{children:"SimpleExpr"}),' is "merged into" ',(0,t.jsx)(n.code,{children:"Expr"}),", meaning that ",(0,t.jsx)(n.code,{children:"SimpleExpr"})," is now just a type alias: ",(0,t.jsx)(n.code,{children:"type SimpleExpr = Expr;"}),". Both names can be used interchangeably. A lot of redundant ",(0,t.jsx)(n.code,{children:".into()"})," can now be removed. If you implemented some trait for both of those types, two impls for one type will no longer compile and you'll need to delete one of the impls."]}),"\n",(0,t.jsxs)(n.p,{children:['The resulting "merged" type has all methods from the two original types, except for the methods defined by ',(0,t.jsx)(n.code,{children:"ExprTrait"}),". Those inherent methods have been removed and have given us back those 1300 lines of code."]}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors",children:"Potential compile errors"}),"\n",(0,t.jsxs)(n.p,{children:["If you encounter the following error, please add ",(0,t.jsx)(n.code,{children:"use sea_query::ExprTrait"})," in scope."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0599]: no method named `like` found for enum `sea_query::Expr` in the current scope\n    |\n    |         Expr::col((self.entity_name(), *self)).like(s)\n    |\n    |     fn like<L>(self, like: L) -> Expr\n    |        ---- the method is available for `sea_query::Expr` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ExprTrait` which provides `like` is implemented but not in scope; perhaps you want to import it\n    |\n -> + use sea_query::ExprTrait;\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'error[E0308]: mismatched types\n  --\x3e src/sqlite/discovery.rs:27:57\n   |\n   |             .and_where(Expr::col(Alias::new("type")).eq("table"))\n   |                                                      -- ^^^^^^^ expected `&Expr`, found `&str`\n   |                                                      |\n   |                                                      arguments to this method are incorrect\n   |\n   = note: expected reference `&sea_query::Expr`\n              found reference `&\'static str`\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"revamp-iden-type-system",children:["Revamp ",(0,t.jsx)(n.code,{children:"Iden"})," type system."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/909",children:"#909"}),"\nPreviously, ",(0,t.jsx)(n.code,{children:"DynIden"})," is lazily rendered, i.e. the identifier is only constructed while serializing the AST. Now, it's an eagerly rendered string ",(0,t.jsx)(n.code,{children:"Cow<'static, str>"}),", constructed while constructing the AST."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub type DynIden = SeaRc<dyn Iden>;               // old\npub struct DynIden(pub(crate) Cow<'static, str>); // new\n\npub struct SeaRc<I>(pub(crate) RcOrArc<I>);       // old\npub struct SeaRc;                                 // new\n"})}),"\n",(0,t.jsx)(n.p,{children:"The implications of this new design are:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Type info is erased from ",(0,t.jsx)(n.code,{children:"Iden"})," early"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SeaRc"})," is no longer an alias to ",(0,t.jsx)(n.code,{children:"Rc"})," / ",(0,t.jsx)(n.code,{children:"Arc"}),". As such, ",(0,t.jsx)(n.code,{children:"Send"})," / ",(0,t.jsx)(n.code,{children:"Sync"})," is removed from the trait ",(0,t.jsx)(n.code,{children:"Iden"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors-1",children:"Potential compile errors"}),"\n",(0,t.jsxs)(n.p,{children:["The method signature of ",(0,t.jsx)(n.code,{children:"Iden::unquoted"})," is changed. If you're implementing ",(0,t.jsx)(n.code,{children:"Iden"})," manually, you can modify it like below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0050]: method `unquoted` has 2 parameters but the declaration in trait `types::Iden::unquoted` has 1\n  --\x3e src/tests_cfg.rs:31:17\n   |\n   |     fn unquoted(&self, s: &mut dyn std::fmt::Write) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 parameter, found 2\n   |\n  ::: src/types.rs:63:17\n   |\n   |     fn unquoted(&self) -> &str;\n   |                 ----- trait requires 1 parameter\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'impl Iden for Glyph {\n  - fn unquoted(&self, s: &mut dyn fmt::Write) {\n  + fn unquoted(&self) -> &str {\n  -     write!(\n  -         s,\n  -         "{}",\n            match self {\n                Self::Table => "glyph",\n                Self::Id => "id",\n                Self::Tokens => "tokens",\n            }\n  -     )\n  -     .unwrap();\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"aliasnew-is-no-longer-needed",children:[(0,t.jsx)(n.code,{children:"Alias::new"})," is no longer needed"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/882",children:"#882"}),"\nSeaQuery encourages you to define all column / table identifiers in one place and use them throughout the project. But there are places where an alias is needed once off. Now ",(0,t.jsx)(n.code,{children:"&'static str"})," is an ",(0,t.jsx)(n.code,{children:"Iden"}),", so it can be used in all places where ",(0,t.jsx)(n.code,{children:"Alias"})," are needed. The ",(0,t.jsx)(n.code,{children:"Alias"})," type remains for backwards compatibility, so existing code should still compile. This can reduce the verbosity of code, for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let query = Query::select()\n    .from(Character::Table)\n -  .expr_as(Func::count(Expr::col(Character::Id)), Alias::new("count"))\n +  .expr_as(Func::count(Expr::col(Character::Id)), "count")\n    .to_owned();\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"unbox-value-variants",children:["Unbox ",(0,t.jsx)(n.code,{children:"Value"})," variants"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/925",children:"#925"}),"\nMost ",(0,t.jsx)(n.code,{children:"Value"})," variants are now unboxed (except ",(0,t.jsx)(n.code,{children:"BigDecimal"})," and ",(0,t.jsx)(n.code,{children:"Array"}),"). Previously the size is 24 bytes, now it's 32."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"assert_eq!(std::mem::size_of::<Value>(), 32);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you were constructing / pattern matching ",(0,t.jsx)(n.code,{children:"Value"})," variants manually, ",(0,t.jsx)(n.code,{children:"Box::new"})," can now be removed and pattern matching is simpler."]}),"\n",(0,t.jsx)(n.p,{children:"It also improved performance because memory allocation and indirection is removed in most cases."}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors-2",children:"Potential compile errors"}),"\n",(0,t.jsxs)(n.p,{children:["If you encounter the following error, simply remove the ",(0,t.jsx)(n.code,{children:"Box"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0308]: mismatched types\n    |\n >  | Value::String(Some(Box::new(string_value.to_string()))));\n    |               ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Box<String>`\n    |               |\n    |               arguments to this enum variant are incorrect\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"non_exhaustive-ast-enums",children:[(0,t.jsx)(n.code,{children:"non_exhaustive"})," AST enums"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/891",children:"#891"}),"\n",(0,t.jsx)(n.code,{children:"#[non_exhaustive]"})," are added to all AST enums. It allows us to add new features and extend the AST without breaking the API."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"+ #[non_exhaustive]\nenum Mode {\n    Creation,\n    Alter,\n    TableAlter,\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors-3",children:"Potential compile errors"}),"\n",(0,t.jsxs)(n.p,{children:["If you encounter the following error, please add a wildcard match ",(0,t.jsx)(n.code,{children:"_ => {..}"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0004]: non-exhaustive patterns: `&_` not covered\n    |\n    |     match table_ref {\n    |           ^^^^^^^^^ pattern `&_` not covered\n    |\nnote: `TableRef` defined here\n    |\n    | pub enum TableRef {\n    | ^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `&TableRef`\n    = note: `TableRef` is marked as non-exhaustive, so a wildcard `_` is necessary to match exhaustively\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n    | TableRef::FunctionCall(_, tbl) => SeaRc::clone(tbl),\n -> | &_ => todo!(),\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reworked-tableref-and-columnref",children:["Reworked ",(0,t.jsx)(n.code,{children:"TableRef"})," and ",(0,t.jsx)(n.code,{children:"ColumnRef"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/927",children:"#927"}),"\nPreviously, the ",(0,t.jsx)(n.code,{children:"TableRef"})," variants are a product of all valid combinations of ",(0,t.jsx)(n.code,{children:"Option<Database>"}),", ",(0,t.jsx)(n.code,{children:"Option<Schema>"}),", ",(0,t.jsx)(n.code,{children:"Table"})," and ",(0,t.jsx)(n.code,{children:"Option<Alias>"}),". It is excessive and makes pattern matching difficult."]}),"\n",(0,t.jsxs)(n.p,{children:["Now they're collapsed into one. It makes constructing and pattern-matching ",(0,t.jsx)(n.code,{children:"TableRef"})," / ",(0,t.jsx)(n.code,{children:"ColumnRef"})," much easier."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// the following variants are collapsed into one:\nenum TableRef {\n    Table(DynIden),\n    SchemaTable(DynIden, DynIden),\n    DatabaseSchemaTable(DynIden, DynIden, DynIden),\n    TableAlias(DynIden, DynIden),\n    SchemaTableAlias(DynIden, DynIden, DynIden),\n    DatabaseSchemaTableAlias(DynIden, DynIden, DynIden, DynIden),\n    ..\n}\n// now it's just:\nenum TableRef {\n    Table(TableName, Option<DynIden>), // optional Alias\n    ..\n}\n\npub struct DatabaseName(pub DynIden);\npub struct SchemaName(pub Option<DatabaseName>, pub DynIden);\n/// A table name, potentially qualified as [database.][schema.]table\npub struct TableName(pub Option<SchemaName>, pub DynIden);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Similarly for ",(0,t.jsx)(n.code,{children:"ColumnRef"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// before\nenum ColumnRef {\n    Column(DynIden),\n    TableColumn(DynIden, DynIden),\n    SchemaTableColumn(DynIden, DynIden, DynIden),\n    Asterisk,\n    TableAsterisk(DynIden),\n}\n// now\nenum ColumnRef {\n    /// A column name, potentially qualified as [database.][schema.][table.]column\n    Column(ColumnName),\n    /// An `*` expression, potentially qualified as [database.][schema.][table.]*\n    Asterisk(Option<TableName>),\n}\n\npub struct ColumnName(pub Option<TableName>, pub DynIden);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors-4",children:"Potential compile errors"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"TableRef"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'error[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n   --\x3e src/entity/relation.rs:526:15\n    |\n >  |     from_tbl: TableRef::Table("foo".into_iden()),\n    |               ^^^^^^^^^^^^^^^-------------------\n    |                              ||\n    |                              |expected `TableName`, found `DynIden`\n    |                              argument #2 of type `Option<DynIden>` is missing\n'})}),"\n",(0,t.jsxs)(n.p,{children:["It's recommended to use the ",(0,t.jsx)(n.code,{children:"IntoTableRef"})," trait to convert types instead of constructing AST manually."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use sea_orm::sea_query::IntoTableRef;\n\nfrom_tbl: "foo".into_table_ref(),\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"ColumnRef"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'error[E0277]: the trait bound `fn(std::option::Option<TableName>) -> sea_query::ColumnRef {sea_query::ColumnRef::Asterisk}: IntoColumnRef` is not satisfied\n    --\x3e src/executor/query.rs:1599:21\n    |\n >  |             .column(ColumnRef::Asterisk)\n    |              ------ ^^^^^^^^^^^^^^^^^^^ the trait `sea_query::Iden` is not implemented for fn item `fn(std::option::Option<TableName>) -> sea_query::ColumnRef {sea_query::ColumnRef::Asterisk}`\n    |              |\n    |              required by a bound introduced by this call\n\nerror[E0308]: mismatched types\n    --\x3e src/executor/query.rs:1607:54\n    |\n >  |                 SimpleExpr::Column(ColumnRef::Column("id".into_iden()))\n    |                                    ----------------- ^^^^^^^^^^^^^^^^ expected `ColumnName`, found `DynIden`\n    |                                    |\n    |                                    arguments to this enum variant are incorrect\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the former case ",(0,t.jsx)(n.code,{children:"Asterisk"})," has an additional inner ",(0,t.jsx)(n.code,{children:"Option<TableName>"}),", you can simply put ",(0,t.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:".column(ColumnRef::Asterisk(None))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the latter case, ",(0,t.jsx)(n.code,{children:"&'static str"})," can now be used in most methods that accepts ",(0,t.jsx)(n.code,{children:"ColumnRef"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'Expr::column("id")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"new-features",children:"New Features"}),"\n",(0,t.jsx)(n.h3,{id:"query-audit",children:"Query Audit"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/908",children:"#908"}),"\nIn order to support Role Based Access Control (RBAC) in SeaORM, a given SQL query has to be analyzed to determine what permissions are needed to act on which resources."]}),"\n",(0,t.jsxs)(n.p,{children:["It supports all the query types: ",(0,t.jsx)(n.code,{children:"SELECT"}),", ",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE"}),", ",(0,t.jsx)(n.code,{children:"DELETE"})," and CTE. This requires the ",(0,t.jsx)(n.code,{children:"audit"})," feature flag."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let query = Query::select()\n    .columns([Char::Character])\n    .from(Char::Table)\n    .left_join(\n        Font::Table,\n        Expr::col((Char::Table, Char::FontId)).equals((Font::Table, Font::Id)),\n    )\n    .inner_join(\n        Glyph::Table,\n        Expr::col((Char::Table, Char::Character)).equals((Glyph::Table, Glyph::Image)),\n    )\n    .take();\n\nassert_eq!(\n    query.to_string(PostgresQueryBuilder),\n    r#"SELECT "character"\n    FROM "character"\n    LEFT JOIN "font" ON "character"."font_id" = "font"."id"\n    INNER JOIN "glyph" ON "character"."character" = "glyph"."image""#\n);\n\nassert_eq!(\n    query.audit()?.selected_tables(),\n    [\n        Char::Table.into_iden(),\n        Font::Table.into_iden(),\n        Glyph::Table.into_iden(),\n    ]\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"ergonomic-raw-sql",children:"Ergonomic raw SQL"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/952",children:"#952"}),"\nThis is already covered in a previous ",(0,t.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-08-15-sea-query-raw-sql/",children:"blog post"}),".\nIn case you've missed it, we've created a new ",(0,t.jsx)(n.code,{children:"raw_query!"})," macro with neat features to make writing raw SQL queries more ergononmic."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let a = 1;\nstruct B { b: i32 }\nlet b = B { b: 2 };\nlet c = "A";\nlet d = vec![3, 4, 5];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"SELECT ("size_w" + {a}) * {b.b} FROM "glyph"\n       WHERE "image" LIKE {c} AND "id" IN ({..d})"#\n);\n\nassert_eq!(\n    query.sql,\n    r#"SELECT ("size_w" + $1) * $2 FROM "glyph"\n       WHERE "image" LIKE $3 AND "id" IN ($4, $5, $6)"#\n);\nassert_eq!(\n    query.values,\n    Values(vec![1.into(), 2.into(), "A".into(), 3.into(), 4.into(), 5.into()])\n);\n'})}),"\n",(0,t.jsx)(n.p,{children:"The snippet above demonstrated:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["named parameter: ",(0,t.jsx)(n.code,{children:"{a}"})," injected"]}),"\n",(0,t.jsxs)(n.li,{children:["nested parameter access: ",(0,t.jsx)(n.code,{children:"{b.b}"})," inner access"]}),"\n",(0,t.jsxs)(n.li,{children:["array expansion: ",(0,t.jsx)(n.code,{children:"{..d}"})," expanded into three parameters"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"breaking-changes",children:"Breaking Changes"}),"\n",(0,t.jsxs)(n.h3,{id:"replaced-serial-with-generated-by-default-as-identity-postgres",children:["Replaced ",(0,t.jsx)(n.code,{children:"SERIAL"})," with ",(0,t.jsx)(n.code,{children:"GENERATED BY DEFAULT AS IDENTITY"})," (Postgres)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/918",children:"#918"}),"\n",(0,t.jsx)(n.code,{children:"SERIAL"})," is deprecated in Postgres because identity column (",(0,t.jsx)(n.code,{children:"GENERATED AS IDENTITY"}),") is more modern and, for example, can avoid sequence number quirks."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let table = Table::create()\n    .table(Char::Table)\n    .col(ColumnDef::new(Char::Id).integer().not_null().auto_increment().primary_key())\n    .to_owned();\n\nassert_eq!(\n    table.to_string(PostgresQueryBuilder),\n    [\n        r#"CREATE TABLE "character" ("#,\n            r#""id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,"#,\n        r#")"#,\n    ].join(" ")\n);\n'})}),"\n",(0,t.jsx)(n.p,{children:"If you need to support legacy systems you can still do:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let table = Table::create()\n    .table(Char::Table)\n    .col(ColumnDef::new(Char::Id).custom("serial").not_null().primary_key())\n    .to_owned();\n\nassert_eq!(\n    table.to_string(PostgresQueryBuilder),\n    [\n        r#"CREATE TABLE "character" ("#,\n            r#""id" serial NOT NULL PRIMARY KEY"#,\n        r#")"#,\n    ].join(" ")\n);\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"changed-intoxxx-traits-into-intoxxx",children:["Changed ",(0,t.jsx)(n.code,{children:"IntoXXX"})," traits into ",(0,t.jsx)(n.code,{children:"Into<XXX>"})]}),"\n",(0,t.jsxs)(n.p,{children:["Changed ",(0,t.jsx)(n.code,{children:"IntoCondition"})," (etc) traits to be defined as ",(0,t.jsx)(n.code,{children:"trait IntoCondition: Into<Condition>"}),".\nA blanket impl is added.\nNow ",(0,t.jsx)(n.code,{children:"IntoCondition"})," and ",(0,t.jsx)(n.code,{children:"Into<Condition>"})," are completely interchangable, but you can still use ",(0,t.jsx)(n.code,{children:".into_condition()"})," for readability."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// before\ntrait IntoCondition {\n    fn into_condition(self) -> Condition;\n}\n\n// now\ntrait IntoCondition: Into<Condition> {\n    fn into_condition(self) -> Condition {\n        self.into()\n    }\n}\n\nimpl<T> IntoCondition for T where T: Into<Condition> {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you have manually implemented ",(0,t.jsx)(n.code,{children:"Into*"})," traits, it may cause conflicts. You\nshould rewrite your impls as as ",(0,t.jsx)(n.code,{children:"impl From<..> for TableRef"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Full list of changed traits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IntoCondition"})," ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/939",children:"#939"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IntoColumnRef"})," ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/959",children:"#959"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IntoTableRef"})," ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/958",children:"#958"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IntoTypeRef"})," ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/969",children:"#969"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IntoValueTuple"})," ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/960",children:"#960"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-improvements",children:"Performance Improvements"}),"\n",(0,t.jsx)(n.p,{children:"We benchmarked the query-building process - and found out that the bulk of the overhead came from serializing queries into strings, not from the AST building. By optimizing the string handling part of the serialization process, we improved the query-building performance by up to 15%!"}),"\n",(0,t.jsxs)(n.h3,{id:"replaced-write-with-write_str",children:["Replaced ",(0,t.jsx)(n.code,{children:"write!"})," with ",(0,t.jsx)(n.code,{children:"write_str"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/947",children:"#947"}),"\nThis simple but not-so-obvious change by far contributed the biggest gain."]}),"\n",(0,t.jsx)(n.p,{children:"We won't go into the details here, as there are two tracking issues in rust-lang:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["format_args! is slow ",(0,t.jsx)(n.a,{href:"https://github.com/rust-lang/rust/issues/76490",children:"rust/#76490"})]}),"\n",(0,t.jsxs)(n.li,{children:["Tracking issue for improving std::fmt::Arguments and format_args!() ",(0,t.jsx)(n.a,{href:"https://github.com/rust-lang/rust/issues/99012",children:"rust/#99012"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// before\nwrite!(\n    sql,\n    "CONSTRAINT {}{}{} ",\n    self.quote().left(),\n    name,\n    self.quote().right()\n);\n\n// now\nsql.write_str("CONSTRAINT ");\nsql.write_char(self.quote().left());\nsql.write_str(name);\nsql.write_char(self.quote().right());\nsql.write_str(" ");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"refactor-writer-to-avoid-string-allocation",children:"Refactor Writer to avoid string allocation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/945",children:"#945"}),"\nLess strings is better!"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// before: an intermediate string is allocated\nlet value: String = self.value_to_string(value);\nwrite!(sql, "{value}");\n\n// now: write to the buffer directly\nself.write_value(sql, value);\n\nfn write_value(&self, sql: &mut dyn Write, value: &Value);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"refactor-tokenizer-to-avoid-string-allocation",children:"Refactor Tokenizer to avoid string allocation"}),"\n",(0,t.jsx)(n.p,{children:"Note that the tokenizer is not part of the runtime query-building code path, but still worth mentioning."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// before\nenum Token {\n    Quoted(String),\n    Unquoted(String),\n    Space(String),\n    Punctuation(String),\n}\n\n// now\nenum Token<'a> {\n    Quoted(&'a str),\n    Unquoted(&'a str),\n    Space(&'a str),\n    Punctuation(&'a str),\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"release-plan",children:"Release Plan"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/blob/master/CHANGELOG.md#100---pending",children:"SeaQuery 1.0"})," is currently an ",(0,t.jsx)(n.code,{children:"rc"})," release, and we plan to finalize it soon - meaning no more major breaking changes. If you feel adventurous or want to use some of the latest features, you can upgrade today. Please let us know the problems you faced, this will help us and the community. If you have ideas / feedback please ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/discussions/795",children:"join the discussion"})," on GitHub!"]}),"\n",(0,t.jsx)(n.p,{children:"As SeaORM is based on top of SeaQuery, the breaking changes above would impact SeaORM users as well. We tried to minimize the impact to lightweight SeaORM users and most changes can be done mechanically. After that, it will be the most exciting release - SeaORM 2.0!"}),"\n",(0,t.jsx)(n.h2,{id:"our-team",children:"Our Team"}),"\n",(0,t.jsx)(n.p,{children:"SeaQuery 1.0 wouldn't have happened without two contributors who joined us recently - Dmitrii Aleksandrov and Huliiiiii. They've made huge contributions that helped define this release, and we're super grateful for the effort and care they've poured into the project."}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)("div",{class:"row",children:[(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--m",href:"https://github.com/tyt2y3",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1782664?v=4"})}),(0,t.jsxs)("div",{class:"avatar__intro",children:[(0,t.jsx)("div",{class:"avatar__name",children:"Chris Tsang"}),(0,t.jsx)("small",{class:"avatar__subtitle",children:"Maintainer"})]})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--m",href:"https://github.com/Expurple",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/56318093?v=4"})}),(0,t.jsxs)("div",{class:"avatar__intro",children:[(0,t.jsx)("div",{class:"avatar__name",children:"Dmitrii Aleksandrov"}),(0,t.jsx)("small",{class:"avatar__subtitle",children:"Maintainer"})]})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--m",href:"https://github.com/Huliiiiii",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/134658521?v=4"})}),(0,t.jsxs)("div",{class:"avatar__intro",children:[(0,t.jsx)("div",{class:"avatar__name",children:"Huliiiiii"}),(0,t.jsx)("small",{class:"avatar__subtitle",children:"Contributor"})]})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"sponsor",children:"Sponsor"}),"\n",(0,t.jsx)(n.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,t.jsx)(n.h4,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,t.jsx)("a",{href:"https://qdx.co/",children:(0,t.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics\u2013powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data engineering workflows."]}),"\n",(0,t.jsx)(n.h4,{id:"github-sponsors",children:"GitHub Sponsors"}),"\n",(0,t.jsxs)(n.p,{children:["A big shout out to our ",(0,t.jsx)(n.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"})," \ud83d\ude07:"]}),"\n",(0,t.jsx)("div",{class:"row",children:(0,t.jsx)("div",{class:"col col--12 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--lg",href:"https://github.com/subscribepro",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/8466133?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Subscribe Pro"})})]})})}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)("div",{class:"row",children:[(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/holly-hacker",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/13605369?u=9566a44f2d869f337a4909836487bb4a29c23b72&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Variant9"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/vealth42",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/184287790?u=d63fb7492a558799c21667a0ec1461b4d5e0f94c&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"vealth"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/AurLemon",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/67463076?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"AurLemon"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/ryanswrt",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/87781?u=10a9d256e741f905f3dd2cf641de8b325720732e&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Ryan Swart"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/OteroRafael",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/175388115?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"OteroRafael"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/higumachan",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1011298?u=de4c2f0d0929c2c6dc433981912f794d0e50f2cd&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Yuta Hinokuma"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/wh7f",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/59872041?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"wh7f"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcson909",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/16665353?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"MS"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/numeusxyz",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/82152211?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Numeus"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/data-intuitive",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/15045722?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Data Intuitive"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/caido-community",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/168573261?v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Caido Community"})})]})}),(0,t.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcusbuffett",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1834328?u=fd066d99cf4a6333bfb3927d1c756af4bb8baf7e&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Marcus Buffett"})})]})})]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)("div",{class:"row",children:[(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/yuly3",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/25814001?u=4b57756e7d8060e48262a9edba687927fe7934a6&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"MasakiMiyazaki"})})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/kallydev",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/36319157?u=5be882aa4dbe7eea97b1a80a6473857369146df6&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"KallyDev"})})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/manfredcml",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/27536502?u=b71636bdabbc698458b32e2ac05c5771ad41097e&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Manfred Lee"})})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/tugascript",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/64930104?u=ad9f63e8e221dbe71bf23de59e3611c99cda1181&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Afonso Barracha"})})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/deansheather",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/11241812?u=260538c7d8b8c3c5350dba175ebb8294358441e0&v=4"})}),(0,t.jsx)("div",{class:"avatar__intro",children:(0,t.jsx)("div",{class:"avatar__name",children:"Dean Sheather"})})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"rustacean-sticker-pack-",children:"Rustacean Sticker Pack \ud83e\udd80"}),"\n",(0,t.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"}),"\n",(0,t.jsx)(n.p,{children:"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."}),"\n",(0,t.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"}),"\n",(0,t.jsx)(n.li,{children:"Mascot of SeaQL: Terres the Hermit Crab"}),"\n",(0,t.jsx)(n.li,{children:"Mascot of Rust: Ferris the Crab"}),"\n",(0,t.jsx)(n.li,{children:"The Rustacean word"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,t.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,t.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},7630:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var s=a(2374);const t={},r=s.createContext(t);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);