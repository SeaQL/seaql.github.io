"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[511],{678:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-150/blog/2025-08-20-sea-query-1.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-08-20-sea-query-1.0.md","source":"@site/blog/2025-08-20-sea-query-1.0.md","title":"The road to SeaQuery 1.0","description":"SeaQuery 0.1.0 was first released on 2020-12-16 - it\'s been a few years! Since then, there have been 32 releases, each introducing a set of new features. As with many software projects, the organic evolution driven by a diverse community of open source contributors has led to occasional inconsistencies across the codebase. It\'s a good problem to have, and a testament to our vibrant community. But now, it\'s time to stabilize SeaQuery and address some of these issues.","date":"2025-08-20T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-150/blog/tags/news"}],"readingTime":9.215,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-08-20-sea-query-1.0","title":"The road to SeaQuery 1.0","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"SeaQuery just made writing raw SQL more enjoyable","permalink":"/preview/pr-150/blog/2025-08-15-sea-query-raw-sql"}}')},5502:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=s(678),t=s(8790),r=s(7630);const o={slug:"2025-08-20-sea-query-1.0",title:"The road to SeaQuery 1.0",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png",tags:["news"]},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Architectural changes",id:"architectural-changes",level:2},{value:"Forbid unsafe code",id:"forbid-unsafe-code",level:3},{value:"Unify <code>Expr</code> and <code>SimpleExpr</code> as one type",id:"unify-expr-and-simpleexpr-as-one-type",level:3},{value:"Revamp <code>Iden</code> type system.",id:"revamp-iden-type-system",level:3},{value:"<code>Alias::new</code> is no longer needed",id:"aliasnew-is-no-longer-needed",level:3},{value:"Unbox <code>Value</code> variants",id:"unbox-value-variants",level:3},{value:"<code>non_exhaustive</code> AST enums",id:"non_exhaustive-ast-enums",level:3},{value:"Potential compile errors",id:"potential-compile-errors",level:4},{value:"Reworked <code>TableRef</code> and <code>ColumnRef</code>",id:"reworked-tableref-and-columnref",level:3},{value:"Potential compile errors",id:"potential-compile-errors-1",level:4},{value:"New Features",id:"new-features",level:2},{value:"Query Audit",id:"query-audit",level:3},{value:"Ergonomic raw SQL",id:"ergonomic-raw-sql",level:3},{value:"Release Plan",id:"release-plan",level:2},{value:"Sponsor",id:"sponsor",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:4},{value:"Our Team",id:"our-team",level:2},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("img",{alt:"SeaQuery 1.0 Banner",src:"/blog/img/SeaQuery%201.0%20Banner.png"}),"\n",(0,t.jsx)(n.p,{children:"SeaQuery 0.1.0 was first released on 2020-12-16 - it's been a few years! Since then, there have been 32 releases, each introducing a set of new features. As with many software projects, the organic evolution driven by a diverse community of open source contributors has led to occasional inconsistencies across the codebase. It's a good problem to have, and a testament to our vibrant community. But now, it's time to stabilize SeaQuery and address some of these issues."}),"\n",(0,t.jsx)(n.h2,{id:"architectural-changes",children:"Architectural changes"}),"\n",(0,t.jsx)(n.p,{children:"There are a few architectural changes that can only be made by breaking the API, so let's go through them one by one:"}),"\n",(0,t.jsx)(n.h3,{id:"forbid-unsafe-code",children:"Forbid unsafe code"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/930",children:"#930"}),"\n",(0,t.jsx)(n.code,{children:"#![forbid(unsafe_code)]"})," has been added to all workspace crates, ensuring that SeaQuery no longer contains any unsafe code. While only one instance of unsafe was previously used, and has now been removed, this change reinforces our commitment to maintaining code quality."]}),"\n",(0,t.jsxs)(n.h3,{id:"unify-expr-and-simpleexpr-as-one-type",children:["Unify ",(0,t.jsx)(n.code,{children:"Expr"})," and ",(0,t.jsx)(n.code,{children:"SimpleExpr"})," as one type"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/890",children:"#890"})," Previously, a lot of operator methods (e.g. ",(0,t.jsx)(n.code,{children:"eq"}),") were duplicated across ",(0,t.jsx)(n.code,{children:"Expr"})," and ",(0,t.jsx)(n.code,{children:"SimpleExpr"}),", but the list of methods was slightly different for each. Also, it wasn't clear when to use each of the two types. The type conversions were sometimes non-obvious. It complicated the type system and made writing generic code difficult."]}),"\n",(0,t.jsxs)(n.p,{children:["In 0.32.0, almost a year ago, we added ",(0,t.jsx)(n.code,{children:"ExprTrait"})," (",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/771",children:"#771"}),') to standardize and share the list of methods, and to allow calling them on other "lower-level" types like so: ',(0,t.jsx)(n.code,{children:'1_i32.cast_as("REAL")'}),". At that time, we decided to keep the original inherent methods for compatibility. That worsened the duplication even further, bloating the codebase by ~1300 lines of code."]}),"\n",(0,t.jsxs)(n.p,{children:["Later, we looked into the ",(0,t.jsx)(n.code,{children:"Expr"})," vs ",(0,t.jsx)(n.code,{children:"SimpleExpr"})," distinction. It turned out that ",(0,t.jsx)(n.code,{children:"Expr"}),' was primarily meant to be a "namespace" of static constructors for ',(0,t.jsx)(n.code,{children:"SimpleExpr"}),", similar to ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-query/0.32.7/sea_query/func/struct.Func.html",children:(0,t.jsx)(n.code,{children:"Func"})})," vs ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-query/0.32.7/sea_query/func/struct.FunctionCall.html",children:(0,t.jsx)(n.code,{children:"FunctionCall"})}),". But unlike ",(0,t.jsx)(n.code,{children:"Func"}),", which is a unit struct, ",(0,t.jsx)(n.code,{children:"Expr"})," was given its own data fields, which turned out to be a mistake and led users to pass around ",(0,t.jsx)(n.code,{children:"Expr"}),"s instead of ",(0,t.jsx)(n.code,{children:"SimpleExpr"}),"s."]}),"\n",(0,t.jsxs)(n.p,{children:["In 1.0, ",(0,t.jsx)(n.code,{children:"SimpleExpr"}),' is "merged into" ',(0,t.jsx)(n.code,{children:"Expr"}),", meaning that ",(0,t.jsx)(n.code,{children:"SimpleExpr"})," is now just a type alias: ",(0,t.jsx)(n.code,{children:"type SimpleExpr = Expr;"}),". Both names can be used interchangeably. A lot of redundant ",(0,t.jsx)(n.code,{children:".into()"})," can now be removed. If you implemented some trait for both of those types, two impls for one type will no longer compile and you'll need to delete one of the impls."]}),"\n",(0,t.jsxs)(n.p,{children:['The resulting "merged" type has all methods from the two original types, except for the methods defined by ',(0,t.jsx)(n.code,{children:"ExprTrait"}),". Those inherent methods have been removed and have given us back those 1300 lines of code. If you encounter the following error, please add ",(0,t.jsx)(n.code,{children:"use sea_query::ExprTrait"})," in scope."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0599]: no method named `like` found for enum `sea_query::Expr` in the current scope\n    |\n    |         Expr::col((self.entity_name(), *self)).like(s)\n    |\n    |     fn like<L>(self, like: L) -> Expr\n    |        ---- the method is available for `sea_query::Expr` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ExprTrait` which provides `like` is implemented but not in scope; perhaps you want to import it\n    |\n -> + use sea_query::ExprTrait;\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'error[E0308]: mismatched types\n  --\x3e src/sqlite/discovery.rs:27:57\n   |\n   |             .and_where(Expr::col(Alias::new("type")).eq("table"))\n   |                                                      -- ^^^^^^^ expected `&Expr`, found `&str`\n   |                                                      |\n   |                                                      arguments to this method are incorrect\n   |\n   = note: expected reference `&sea_query::Expr`\n              found reference `&\'static str`\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"revamp-iden-type-system",children:["Revamp ",(0,t.jsx)(n.code,{children:"Iden"})," type system."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/909",children:"#909"}),"\nPreviously, ",(0,t.jsx)(n.code,{children:"DynIden"})," is lazily rendered, i.e. the identifier is only constructed while serializing the AST. Now, it's an eagerly rendered string ",(0,t.jsx)(n.code,{children:"Cow<'static, str>"}),", constructed while constructing the AST."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub type DynIden = SeaRc<dyn Iden>;               // old\npub struct DynIden(pub(crate) Cow<'static, str>); // new\n\npub struct SeaRc<I>(pub(crate) RcOrArc<I>);       // old\npub struct SeaRc;                                 // new\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The method signature of ",(0,t.jsx)(n.code,{children:"Iden::unquoted"})," is changed. If you're implementing ",(0,t.jsx)(n.code,{children:"Iden"})," manually, you can modify it like below ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/909",children:"https://github.com/SeaQL/sea-query/pull/909"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0050]: method `unquoted` has 2 parameters but the declaration in trait `types::Iden::unquoted` has 1\n  --\x3e src/tests_cfg.rs:31:17\n   |\n   |     fn unquoted(&self, s: &mut dyn std::fmt::Write) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 parameter, found 2\n   |\n  ::: src/types.rs:63:17\n   |\n   |     fn unquoted(&self) -> &str;\n   |                 ----- trait requires 1 parameter\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'impl Iden for Glyph {\n  - fn unquoted(&self, s: &mut dyn fmt::Write) {\n  + fn unquoted(&self) -> &str {\n  -     write!(\n  -         s,\n  -         "{}",\n            match self {\n                Self::Table => "glyph",\n                Self::Id => "id",\n                Self::Tokens => "tokens",\n            }\n  -     )\n  -     .unwrap();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The implications of this new design are:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Type info is erased from ",(0,t.jsx)(n.code,{children:"Iden"})," early"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SeaRc"})," is no longer an alias to ",(0,t.jsx)(n.code,{children:"Rc"})," / ",(0,t.jsx)(n.code,{children:"Arc"}),". As such, ",(0,t.jsx)(n.code,{children:"Send"})," / ",(0,t.jsx)(n.code,{children:"Sync"})," is removed from the trait ",(0,t.jsx)(n.code,{children:"Iden"})]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"aliasnew-is-no-longer-needed",children:[(0,t.jsx)(n.code,{children:"Alias::new"})," is no longer needed"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/882",children:"#882"}),"\nSeaQuery encourages you to define all column / table identifiers in one place and use them throughout the project. But there are places where an alias is needed once off. Now ",(0,t.jsx)(n.code,{children:"&'static str"})," is an ",(0,t.jsx)(n.code,{children:"Iden"}),", so it can be used in all places where ",(0,t.jsx)(n.code,{children:"Alias"})," are needed. The ",(0,t.jsx)(n.code,{children:"Alias"})," type remains for backwards compatibility, so existing code should still compile. This can reduce the verbosity of code, for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let query = Query::select()\n    .from(Character::Table)\n -  .expr_as(Func::count(Expr::col(Character::Id)), Alias::new("count"))\n +  .expr_as(Func::count(Expr::col(Character::Id)), "count")\n    .to_owned();\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"unbox-value-variants",children:["Unbox ",(0,t.jsx)(n.code,{children:"Value"})," variants"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/925",children:"#925"}),"\nMost ",(0,t.jsx)(n.code,{children:"Value"})," variants are now unboxed (except ",(0,t.jsx)(n.code,{children:"BigDecimal"})," and ",(0,t.jsx)(n.code,{children:"Array"}),"). Previously the size is 24 bytes, now it's 32."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"assert_eq!(std::mem::size_of::<Value>(), 32);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you were constructing / pattern matching ",(0,t.jsx)(n.code,{children:"Value"})," variants manually, ",(0,t.jsx)(n.code,{children:"Box::new"})," can now be removed and pattern matching is simpler."]}),"\n",(0,t.jsxs)(n.h3,{id:"non_exhaustive-ast-enums",children:[(0,t.jsx)(n.code,{children:"non_exhaustive"})," AST enums"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/891",children:"#891"}),"\n",(0,t.jsx)(n.code,{children:"#[non_exhaustive]"})," are added to all AST enums. It allows us to add new features and extend the AST without breaking the API."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"+ #[non_exhaustive]\nenum Mode {\n    Creation,\n    Alter,\n    TableAlter,\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors",children:"Potential compile errors"}),"\n",(0,t.jsxs)(n.p,{children:["If you encounter the following error,\nplease add a wildcard match ",(0,t.jsx)(n.code,{children:"_ => {..}"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"error[E0004]: non-exhaustive patterns: `&_` not covered\n    |\n    |     match table_ref {\n    |           ^^^^^^^^^ pattern `&_` not covered\n    |\nnote: `TableRef` defined here\n    |\n    | pub enum TableRef {\n    | ^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `&TableRef`\n    = note: `TableRef` is marked as non-exhaustive, so a wildcard `_` is necessary to match exhaustively\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n    | TableRef::FunctionCall(_, tbl) => SeaRc::clone(tbl),\n -> | &_ => todo!(),\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reworked-tableref-and-columnref",children:["Reworked ",(0,t.jsx)(n.code,{children:"TableRef"})," and ",(0,t.jsx)(n.code,{children:"ColumnRef"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/927",children:"#927"}),"\nPreviously, the ",(0,t.jsx)(n.code,{children:"TableRef"})," variants are a product of all valid combinations of ",(0,t.jsx)(n.code,{children:"Option<Database>"}),", ",(0,t.jsx)(n.code,{children:"Option<Schema>"}),", ",(0,t.jsx)(n.code,{children:"Table"})," and ",(0,t.jsx)(n.code,{children:"Option<Alias>"}),". It is excessive and makes pattern matching difficult."]}),"\n",(0,t.jsxs)(n.p,{children:["Now they're collapsed into one. ",(0,t.jsx)(n.code,{children:"SchemaTable"})," is now simply a type alias of ",(0,t.jsx)(n.code,{children:"TableName"}),". It makes constructing and pattern-matching ",(0,t.jsx)(n.code,{children:"TableRef"})," / ",(0,t.jsx)(n.code,{children:"ColumnRef"})," much easier."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// the following variants are collapsed into one:\nenum TableRef {\n    Table(DynIden),\n    SchemaTable(DynIden, DynIden),\n    DatabaseSchemaTable(DynIden, DynIden, DynIden),\n    TableAlias(DynIden, DynIden),\n    SchemaTableAlias(DynIden, DynIden, DynIden),\n    DatabaseSchemaTableAlias(DynIden, DynIden, DynIden, DynIden),\n    ..\n}\n// now it's just:\nenum TableRef {\n    Table(TableName, Option<DynIden>), // optional Alias\n    ..\n}\n\npub struct DatabaseName(pub DynIden);\npub struct SchemaName(pub Option<DatabaseName>, pub DynIden);\n/// A table name, potentially qualified as [database.][schema.]table\npub struct TableName(pub Option<SchemaName>, pub DynIden);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Similarly for ",(0,t.jsx)(n.code,{children:"ColumnRef"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// before\nenum ColumnRef {\n    Column(DynIden),\n    TableColumn(DynIden, DynIden),\n    SchemaTableColumn(DynIden, DynIden, DynIden),\n    Asterisk,\n    TableAsterisk(DynIden),\n}\n// now\nenum ColumnRef {\n    /// A column name, potentially qualified as [database.][schema.][table.]column\n    Column(ColumnName),\n    /// An `*` expression, potentially qualified as [database.][schema.][table.]*\n    Asterisk(Option<TableName>),\n}\n\npub struct ColumnName(pub Option<TableName>, pub DynIden);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"potential-compile-errors-1",children:"Potential compile errors"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"TableRef"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'error[E0061]: this enum variant takes 2 arguments but 1 argument was supplied\n   --\x3e src/entity/relation.rs:526:15\n    |\n >  |     from_tbl: TableRef::Table("foo".into_iden()),\n    |               ^^^^^^^^^^^^^^^-------------------\n    |                              ||\n    |                              |expected `TableName`, found `DynIden`\n    |                              argument #2 of type `Option<DynIden>` is missing\n'})}),"\n",(0,t.jsxs)(n.p,{children:["It's recommended to use the ",(0,t.jsx)(n.code,{children:"IntoTableRef"})," trait to convert types instead of constructing AST manually."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use sea_orm::sea_query::IntoTableRef;\n\nfrom_tbl: "foo".into_table_ref(),\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"ColumnRef"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'error[E0277]: the trait bound `fn(std::option::Option<TableName>) -> sea_query::ColumnRef {sea_query::ColumnRef::Asterisk}: IntoColumnRef` is not satisfied\n    --\x3e src/executor/query.rs:1599:21\n    |\n >  |             .column(ColumnRef::Asterisk)\n    |              ------ ^^^^^^^^^^^^^^^^^^^ the trait `sea_query::Iden` is not implemented for fn item `fn(std::option::Option<TableName>) -> sea_query::ColumnRef {sea_query::ColumnRef::Asterisk}`\n    |              |\n    |              required by a bound introduced by this call\n\nerror[E0308]: mismatched types\n    --\x3e src/executor/query.rs:1607:54\n    |\n >  |                 SimpleExpr::Column(ColumnRef::Column("id".into_iden()))\n    |                                    ----------------- ^^^^^^^^^^^^^^^^ expected `ColumnName`, found `DynIden`\n    |                                    |\n    |                                    arguments to this enum variant are incorrect\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the former case ",(0,t.jsx)(n.code,{children:"Asterisk"})," has an additional inner ",(0,t.jsx)(n.code,{children:"Option<TableName>"}),", you can simply put ",(0,t.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:".column(ColumnRef::Asterisk(None))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the latter case, ",(0,t.jsx)(n.code,{children:"&'static str"})," can now be used in most methods that accepts ",(0,t.jsx)(n.code,{children:"ColumnRef"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'Expr::column("id")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"new-features",children:"New Features"}),"\n",(0,t.jsx)(n.h3,{id:"query-audit",children:"Query Audit"}),"\n",(0,t.jsx)(n.h3,{id:"ergonomic-raw-sql",children:"Ergonomic raw SQL"}),"\n",(0,t.jsx)(n.h2,{id:"release-plan",children:"Release Plan"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/blob/master/CHANGELOG.md#100---pending",children:"SeaQuery 1.0"})," is currently an ",(0,t.jsx)(n.code,{children:"rc"})," release, and we plan to finalize it soon - meaning no more major breaking changes. If you feel adventurous or want to use some of the latest features, you can upgrade today. Please let us know the problems you faced, this will help us and the community. If you have ideas / feedback please ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/discussions/795",children:"join the discussion"})," on GitHub!"]}),"\n",(0,t.jsx)(n.p,{children:"As SeaORM is based on top of SeaQuery, the breaking changes above would apply to all SeaORM users as well. We tried to minimize the impact to lightweight SeaORM users and most changes can be done mechanically. After that, it will be the most exciting release - SeaORM 2.0!"}),"\n",(0,t.jsx)(n.h2,{id:"sponsor",children:"Sponsor"}),"\n",(0,t.jsx)(n.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,t.jsxs)(n.p,{children:["A big shout out to our ",(0,t.jsx)(n.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"})," \ud83d\ude07:"]}),"\n",(0,t.jsx)("img",{src:"/blog/img/github-sponsors-20250812.jpg#light"}),"\n",(0,t.jsx)("img",{src:"/blog/img/github-sponsors-20250812-dark.jpg#dark"}),"\n",(0,t.jsx)(n.h4,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,t.jsx)("a",{href:"https://qdx.co/",children:(0,t.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics\u2013powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data engineering workflows."]}),"\n",(0,t.jsx)(n.h2,{id:"our-team",children:"Our Team"}),"\n",(0,t.jsx)(n.p,{children:"SeaQuery 1.0 wouldn't have happened without two contributors who joined us recently - Dmitrii Aleksandrov and Huliiiiii. They've made huge contributions that helped define this release, and we're super grateful for the effort and care they've poured into the project."}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)("div",{class:"row",children:[(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--m",href:"https://github.com/tyt2y3",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1782664?v=4"})}),(0,t.jsxs)("div",{class:"avatar__intro",children:[(0,t.jsx)("div",{class:"avatar__name",children:"Chris Tsang"}),(0,t.jsx)("small",{class:"avatar__subtitle",children:"Maintainer"})]})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--m",href:"https://github.com/Expurple",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/56318093?v=4"})}),(0,t.jsxs)("div",{class:"avatar__intro",children:[(0,t.jsx)("div",{class:"avatar__name",children:"Dmitrii Aleksandrov"}),(0,t.jsx)("small",{class:"avatar__subtitle",children:"Maintainer"})]})]})}),(0,t.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,t.jsxs)("div",{class:"avatar",children:[(0,t.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--m",href:"https://github.com/Huliiiiii",children:(0,t.jsx)("img",{src:"https://avatars.githubusercontent.com/u/134658521?v=4"})}),(0,t.jsxs)("div",{class:"avatar__intro",children:[(0,t.jsx)("div",{class:"avatar__name",children:"Huliiiiii"}),(0,t.jsx)("small",{class:"avatar__subtitle",children:"Contributor"})]})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"rustacean-sticker-pack-",children:"Rustacean Sticker Pack \ud83e\udd80"}),"\n",(0,t.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"}),"\n",(0,t.jsx)(n.p,{children:"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."}),"\n",(0,t.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"}),"\n",(0,t.jsx)(n.li,{children:"Mascot of SeaQL: Terres the Hermit Crab"}),"\n",(0,t.jsx)(n.li,{children:"Mascot of Rust: Ferris the Crab"}),"\n",(0,t.jsx)(n.li,{children:"The Rustacean word"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,t.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,t.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},7630:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var a=s(2374);const t={},r=a.createContext(t);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);