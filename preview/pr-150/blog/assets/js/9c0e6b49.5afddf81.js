"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[511],{678:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-150/blog/2025-08-20-sea-query-1.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-08-20-sea-query-1.0.md","source":"@site/blog/2025-08-20-sea-query-1.0.md","title":"The road to SeaQuery 1.0","description":"SeaQuery 0.1.0 was first released on 2020-12-16 - it\'s been a few years! Since then, there have been 32 releases, each introducing a set of new features. As with many software projects, the organic evolution driven by a diverse community of open source contributors has led to occasional inconsistencies across the codebase. It\'s a good problem to have, and a testament to our vibrant community. But now, it\'s time to stabilize SeaQuery and address some of these issues.","date":"2025-08-20T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-150/blog/tags/news"}],"readingTime":6.465,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-08-20-sea-query-1.0","title":"The road to SeaQuery 1.0","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"SeaQuery just made writing raw SQL more enjoyable","permalink":"/preview/pr-150/blog/2025-08-15-sea-query-raw-sql"}}')},5502:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=a(678),r=a(8790),t=a(7630);const o={slug:"2025-08-20-sea-query-1.0",title:"The road to SeaQuery 1.0",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png",tags:["news"]},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Architectural changes",id:"architectural-changes",level:2},{value:"Forbid unsafe code",id:"forbid-unsafe-code",level:3},{value:"Unify <code>Expr</code> and <code>SimpleExpr</code> as one type",id:"unify-expr-and-simpleexpr-as-one-type",level:3},{value:"Revamp <code>Iden</code> type system.",id:"revamp-iden-type-system",level:3},{value:"<code>Alias::new</code> is no longer needed",id:"aliasnew-is-no-longer-needed",level:3},{value:"Unbox <code>Value</code> variants",id:"unbox-value-variants",level:3},{value:"<code>non_exhaustive</code> AST enums",id:"non_exhaustive-ast-enums",level:3},{value:"Reworked <code>TableRef</code> and <code>ColumnRef</code>",id:"reworked-tableref-and-columnref",level:3},{value:"Release Plan",id:"release-plan",level:2},{value:"Sponsor",id:"sponsor",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:4},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("img",{alt:"SeaQuery 1.0 Banner",src:"/blog/img/SeaQuery%201.0%20Banner.png"}),"\n",(0,r.jsx)(n.p,{children:"SeaQuery 0.1.0 was first released on 2020-12-16 - it's been a few years! Since then, there have been 32 releases, each introducing a set of new features. As with many software projects, the organic evolution driven by a diverse community of open source contributors has led to occasional inconsistencies across the codebase. It's a good problem to have, and a testament to our vibrant community. But now, it's time to stabilize SeaQuery and address some of these issues."}),"\n",(0,r.jsx)(n.h2,{id:"architectural-changes",children:"Architectural changes"}),"\n",(0,r.jsx)(n.p,{children:"There are a few architectural changes that can only be made by breaking the API, so let's go through them one by one:"}),"\n",(0,r.jsx)(n.h3,{id:"forbid-unsafe-code",children:"Forbid unsafe code"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/930",children:"#930"}),"\n#![forbid(unsafe_code)] has been added to all workspace crates, ensuring that SeaQuery no longer contains any unsafe code. While only one instance of unsafe was previously used, and has now been removed, this change reinforces our commitment to maintaining code quality."]}),"\n",(0,r.jsxs)(n.h3,{id:"unify-expr-and-simpleexpr-as-one-type",children:["Unify ",(0,r.jsx)(n.code,{children:"Expr"})," and ",(0,r.jsx)(n.code,{children:"SimpleExpr"})," as one type"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/890",children:"#890"}),"\nPreviously, a lot of operator methods (e.g. ",(0,r.jsx)(n.code,{children:"eq"}),") are duplicated across ",(0,r.jsx)(n.code,{children:"Expr"})," and ",(0,r.jsx)(n.code,{children:"SimpleExpr"}),", but the list of methods is slightly different for each. The type conversions between the two are also sometimes non-obvious. It complicates the type system and made writing generic code difficult."]}),"\n",(0,r.jsxs)(n.p,{children:["In 1.0, ",(0,r.jsx)(n.code,{children:"SimpleExpr"}),' is "merged into" ',(0,r.jsx)(n.code,{children:"Expr"}),". Actually ",(0,r.jsx)(n.code,{children:"SimpleExpr"})," is now just a type alias ",(0,r.jsx)(n.code,{children:"type SimpleExpr = Expr;"}),". So a lot of redundant ",(0,r.jsx)(n.code,{children:".into()"})," can now be removed. In addition, now all methods are defined by ",(0,r.jsx)(n.code,{children:"ExprTrait"}),", and the inherent methods were removed. If you encounter the following error, please add ",(0,r.jsx)(n.code,{children:"use sea_query::ExprTrait"})," in scope."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"error[E0599]: no method named `like` found for enum `sea_query::Expr` in the current scope\n    |\n    |         Expr::col((self.entity_name(), *self)).like(s)\n    |\n    |     fn like<L>(self, like: L) -> Expr\n    |        ---- the method is available for `sea_query::Expr` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ExprTrait` which provides `like` is implemented but not in scope; perhaps you want to import it\n    |\n -> + use sea_query::ExprTrait;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'error[E0308]: mismatched types\n  --\x3e src/sqlite/discovery.rs:27:57\n   |\n   |             .and_where(Expr::col(Alias::new("type")).eq("table"))\n   |                                                      -- ^^^^^^^ expected `&Expr`, found `&str`\n   |                                                      |\n   |                                                      arguments to this method are incorrect\n   |\n   = note: expected reference `&sea_query::Expr`\n              found reference `&\'static str`\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"revamp-iden-type-system",children:["Revamp ",(0,r.jsx)(n.code,{children:"Iden"})," type system."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/909",children:"#909"}),"\nPreviously, ",(0,r.jsx)(n.code,{children:"DynIden"})," is lazily rendered, i.e. the identifier is only constructed while serializing the AST. Now, it's an eagerly rendered string ",(0,r.jsx)(n.code,{children:"Cow<'static, str>"}),", constructed while constructing the AST."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub type DynIden = SeaRc<dyn Iden>;               // old\npub struct DynIden(pub(crate) Cow<'static, str>); // new\n\npub struct SeaRc<I>(pub(crate) RcOrArc<I>);       // old\npub struct SeaRc;                                 // new\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The method signature of ",(0,r.jsx)(n.code,{children:"Iden::unquoted"})," is changed. If you're implementing ",(0,r.jsx)(n.code,{children:"Iden"})," manually, you can modify it like below ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/909",children:"https://github.com/SeaQL/sea-query/pull/909"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"error[E0050]: method `unquoted` has 2 parameters but the declaration in trait `types::Iden::unquoted` has 1\n  --\x3e src/tests_cfg.rs:31:17\n   |\n   |     fn unquoted(&self, s: &mut dyn std::fmt::Write) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 1 parameter, found 2\n   |\n  ::: src/types.rs:63:17\n   |\n   |     fn unquoted(&self) -> &str;\n   |                 ----- trait requires 1 parameter\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'impl Iden for Glyph {\n  - fn unquoted(&self, s: &mut dyn fmt::Write) {\n  + fn unquoted(&self) -> &str {\n  -     write!(\n  -         s,\n  -         "{}",\n            match self {\n                Self::Table => "glyph",\n                Self::Id => "id",\n                Self::Tokens => "tokens",\n            }\n  -     )\n  -     .unwrap();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The implications of this new design are:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Type info is erased from ",(0,r.jsx)(n.code,{children:"Iden"})," early"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SeaRc"})," is no longer an alias to ",(0,r.jsx)(n.code,{children:"Rc"})," / ",(0,r.jsx)(n.code,{children:"Arc"}),". As such, ",(0,r.jsx)(n.code,{children:"Send"})," / ",(0,r.jsx)(n.code,{children:"Sync"})," is removed from the trait ",(0,r.jsx)(n.code,{children:"Iden"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"aliasnew-is-no-longer-needed",children:[(0,r.jsx)(n.code,{children:"Alias::new"})," is no longer needed"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/882",children:"#882"}),"\nSeaQuery encourages you to define all column / table identifiers in one place and use them throughout the project. But there are places where an alias is needed once off. Now ",(0,r.jsx)(n.code,{children:"&'static str"})," is an ",(0,r.jsx)(n.code,{children:"Iden"}),", so it can be used in all places where ",(0,r.jsx)(n.code,{children:"Alias"})," are needed. The ",(0,r.jsx)(n.code,{children:"Alias"})," type remains for backwards compatibility, so existing code should still compile. This can reduce the verbosity of code, for example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let query = Query::select()\n    .from(Character::Table)\n -  .expr_as(Func::count(Expr::col(Character::Id)), Alias::new("count"))\n +  .expr_as(Func::count(Expr::col(Character::Id)), "count")\n    .to_owned();\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"unbox-value-variants",children:["Unbox ",(0,r.jsx)(n.code,{children:"Value"})," variants"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/925",children:"#925"}),"\nMost ",(0,r.jsx)(n.code,{children:"Value"})," variants are now unboxed (except ",(0,r.jsx)(n.code,{children:"BigDecimal"})," and ",(0,r.jsx)(n.code,{children:"Array"}),"). Previously the size is 24 bytes, now it's 32."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"assert_eq!(std::mem::size_of::<Value>(), 32);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you were constructing / pattern matching ",(0,r.jsx)(n.code,{children:"Value"})," variants manually, ",(0,r.jsx)(n.code,{children:"Box::new"})," can now be removed and pattern matching is simpler."]}),"\n",(0,r.jsxs)(n.h3,{id:"non_exhaustive-ast-enums",children:[(0,r.jsx)(n.code,{children:"non_exhaustive"})," AST enums"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/891",children:"#891"}),"\n",(0,r.jsx)(n.code,{children:"#[non_exhaustive]"})," are added to all AST enums. It allows us to add new features and extend the AST without breaking the API. If you encounter the following error,\nplease add a wildcard match ",(0,r.jsx)(n.code,{children:"_ => {..}"})," ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/891",children:"https://github.com/SeaQL/sea-query/pull/891"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"error[E0004]: non-exhaustive patterns: `&_` not covered\n    |\n    |     match table_ref {\n    |           ^^^^^^^^^ pattern `&_` not covered\n    |\nnote: `TableRef` defined here\n    |\n    | pub enum TableRef {\n    | ^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `&TableRef`\n    = note: `TableRef` is marked as non-exhaustive, so a wildcard `_` is necessary to match exhaustively\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n    | TableRef::FunctionCall(_, tbl) => SeaRc::clone(tbl),\n -> | &_ => todo!(),\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"reworked-tableref-and-columnref",children:["Reworked ",(0,r.jsx)(n.code,{children:"TableRef"})," and ",(0,r.jsx)(n.code,{children:"ColumnRef"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/927",children:"#927"}),"\nPreviously, the ",(0,r.jsx)(n.code,{children:"TableRef"})," variants are a product of all valid combinations of ",(0,r.jsx)(n.code,{children:"Option<Database>"}),", ",(0,r.jsx)(n.code,{children:"Option<Schema>"}),", ",(0,r.jsx)(n.code,{children:"Table"})," and ",(0,r.jsx)(n.code,{children:"Option<Alias>"}),". It is excessive and makes pattern matching difficult."]}),"\n",(0,r.jsxs)(n.p,{children:["Now they're collapsed into one. ",(0,r.jsx)(n.code,{children:"SchemaTable"})," is now simply a type alias of ",(0,r.jsx)(n.code,{children:"TableName"}),". It makes constructing and pattern-matching ",(0,r.jsx)(n.code,{children:"TableRef"})," much easier."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// the following variants are collapsed into one:\nenum TableRef {\n    Table(DynIden),\n    SchemaTable(DynIden, DynIden),\n    DatabaseSchemaTable(DynIden, DynIden, DynIden),\n    TableAlias(DynIden, DynIden),\n    SchemaTableAlias(DynIden, DynIden, DynIden),\n    DatabaseSchemaTableAlias(DynIden, DynIden, DynIden, DynIden),\n    ..\n}\n// now it's just:\nenum TableRef {\n    Table(TableName, Option<DynIden>), // optional Alias\n    ..\n}\n// because it's restructured to:\npub struct DatabaseName(pub DynIden);\npub struct SchemaName(pub Option<DatabaseName>, pub DynIden);\npub struct TableName(pub Option<SchemaName>, pub DynIden);\n// so TableName can represent [database.][schema.]table\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Reworked ",(0,r.jsx)(n.code,{children:"TableRef"})," and ",(0,r.jsx)(n.code,{children:"ColumnRef"})," variants. ",(0,r.jsx)(n.code,{children:"SchemaTable"})," is now a type alias of ",(0,r.jsx)(n.code,{children:"TableName"})," ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/pull/927",children:"https://github.com/SeaQL/sea-query/pull/927"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// the following variants are collapsed into one:\nenum TableRef {\n    Table(DynIden),\n    SchemaTable(DynIden, DynIden),\n    DatabaseSchemaTable(DynIden, DynIden, DynIden),\n    TableAlias(DynIden, DynIden),\n    SchemaTableAlias(DynIden, DynIden, DynIden),\n    DatabaseSchemaTableAlias(DynIden, DynIden, DynIden, DynIden),\n    ..\n}\n// now it's just:\nenum TableRef {\n    Table(TableName, Option<DynIden>), // optional Alias\n    ..\n}\n// because it's restructured to:\npub struct DatabaseName(pub DynIden);\npub struct SchemaName(pub Option<DatabaseName>, pub DynIden);\npub struct TableName(pub Option<SchemaName>, pub DynIden);\n// so TableName can represent [database.][schema.]table\n"})}),"\n",(0,r.jsx)(n.h2,{id:"release-plan",children:"Release Plan"}),"\n",(0,r.jsxs)(n.p,{children:["This is just one of many new features we've added while preparing ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/blob/master/CHANGELOG.md#100---pending",children:"SeaQuery 1.0"}),". This is currently an ",(0,r.jsx)(n.code,{children:"rc"})," release, if you have ideas please ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/discussions/795",children:"join the discussion"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"sponsor",children:"Sponsor"}),"\n",(0,r.jsx)(n.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,r.jsxs)(n.p,{children:["A big shout out to our ",(0,r.jsx)(n.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"})," \ud83d\ude07:"]}),"\n",(0,r.jsx)("img",{src:"/blog/img/github-sponsors-20250812.jpg#light"}),"\n",(0,r.jsx)("img",{src:"/blog/img/github-sponsors-20250812-dark.jpg#dark"}),"\n",(0,r.jsx)(n.h4,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,r.jsx)("a",{href:"https://qdx.co/",children:(0,r.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics\u2013powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data engineering workflows."]}),"\n",(0,r.jsx)(n.h2,{id:"rustacean-sticker-pack-",children:"Rustacean Sticker Pack \ud83e\udd80"}),"\n",(0,r.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"}),"\n",(0,r.jsx)(n.p,{children:"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."}),"\n",(0,r.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"}),"\n",(0,r.jsx)(n.li,{children:"Mascot of SeaQL: Terres the Hermit Crab"}),"\n",(0,r.jsx)(n.li,{children:"Mascot of Rust: Ferris the Crab"}),"\n",(0,r.jsx)(n.li,{children:"The Rustacean word"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,r.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,r.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},7630:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>i});var s=a(2374);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);