"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[91023],{28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>r});var o=i(96540);const t={},a=o.createContext(t);function l(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),o.createElement(a.Provider,{value:e},n.children)}},43391:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"relation/custom-join-condition","title":"Custom Join Condition","description":"Sometimes you might want to join on another table with custom conditions, such as:","source":"@site/versioned_docs/version-1.1.x/06-relation/06-custom-join-condition.md","sourceDirName":"06-relation","slug":"/relation/custom-join-condition","permalink":"/preview/pr-150/SeaORM/docs/relation/custom-join-condition","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/06-relation/06-custom-join-condition.md","tags":[],"version":"1.1.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756074242000,"sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Self Referencing","permalink":"/preview/pr-150/SeaORM/docs/relation/self-referencing"},"next":{"title":"Data Loader","permalink":"/preview/pr-150/SeaORM/docs/relation/data-loader"}}');var t=i(74848),a=i(28453);const l={},r="Custom Join Condition",c={},d=[{value:"Relation",id:"relation",level:2},{value:"Linked",id:"linked",level:2},{value:"On the fly",id:"on-the-fly",level:2},{value:"<code>OR</code> condition",id:"or-condition",level:2}];function s(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"custom-join-condition",children:"Custom Join Condition"})}),"\n",(0,t.jsx)(e.p,{children:"Sometimes you might want to join on another table with custom conditions, such as:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-sql",children:"SELECT\n    `cake`.`id`,\n    `cake`.`name`\nFROM\n    `cake`\n    LEFT JOIN `fruit` ON `cake`.`id` = `fruit`.`cake_id`\n    AND `fruit`.`name` LIKE '%tropical%' -- Custom Join Condition\n"})}),"\n",(0,t.jsx)(e.p,{children:"It can be done in several ways."}),"\n",(0,t.jsx)(e.h2,{id:"relation",children:"Relation"}),"\n",(0,t.jsxs)(e.p,{children:["Add your additional join conditions directly to the relation enum. The easiest way is to provide a ",(0,t.jsx)(e.code,{children:"sea_query::SimpleExpr"})," via ",(0,t.jsx)(e.code,{children:"on_condition"})," procedural macros attribute."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = "super::fruit::Entity")]\n    Fruit,\n    #[sea_orm(\n        has_many = "super::fruit::Entity",\n        // Additional on_condition, accept anything that implements `sea_query::IntoCondition`\n        on_condition = r#"super::fruit::Column::Name.like("%tropical%")"#\n    )]\n    TropicalFruit,\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"The procedural macros above will be expanded into:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Fruit,\n    TropicalFruit,\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),\n            Self::TropicalFruit => Entity::has_many(super::fruit::Entity)\n                .on_condition(|_left, _right| {\n                    super::fruit::Column::Name.like("%tropical%")\n                        .into_condition()\n                })\n                .into(),\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"The resulting SQL will be:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .join(JoinType::LeftJoin, cake::Relation::TropicalFruit.def())\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id`, `cake`.`name` FROM `cake`",\n        "LEFT JOIN `fruit` ON `cake`.`id` = `fruit`.`cake_id` AND `fruit`.`name` LIKE \'%tropical%\'",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(e.h2,{id:"linked",children:"Linked"}),"\n",(0,t.jsxs)(e.p,{children:["You can also define custom join conditions on ",(0,t.jsx)(e.code,{children:"Linked"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[derive(Debug)]\npub struct CheeseCakeToFillingVendor;\n\nimpl Linked for CheeseCakeToFillingVendor {\n    type FromEntity = super::cake::Entity;\n\n    type ToEntity = super::vendor::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            super::cake_filling::Relation::Cake\n                .def()\n                // The `on_condition` method takes a closure with parameters\n                // denoting the left-hand side and right-hand side table in the join expression.\n                .on_condition(|left, _right| {\n                    Expr::col((left, super::cake::Column::Name))\n                        .like("%cheese%")\n                        .into_condition()\n                })\n                .rev(),\n            super::cake_filling::Relation::Filling.def(),\n            super::filling::Relation::Vendor.def(),\n        ]\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"The resulting SQL will be:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .find_also_linked(entity_linked::CheeseCakeToFillingVendor)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        r#"SELECT `cake`.`id` AS `A_id`, `cake`.`name` AS `A_name`,"#,\n        r#"`r2`.`id` AS `B_id`, `r2`.`name` AS `B_name`"#,\n        r#"FROM `cake`"#,\n        r#"LEFT JOIN `cake_filling` AS `r0` ON `cake`.`id` = `r0`.`cake_id` AND `cake`.`name` LIKE \'%cheese%\'"#,\n        r#"LEFT JOIN `filling` AS `r1` ON `r0`.`filling_id` = `r1`.`id`"#,\n        r#"LEFT JOIN `vendor` AS `r2` ON `r1`.`vendor_id` = `r2`.`id`"#,\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(e.h2,{id:"on-the-fly",children:"On the fly"}),"\n",(0,t.jsx)(e.p,{children:"Lastly, custom join conditions can be defined at the point you construct the join expression."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .join(JoinType::LeftJoin, cake::Relation::TropicalFruit.def())\n        .join(\n            JoinType::LeftJoin,\n            cake_filling::Relation::Cake\n                .def()\n                .rev()\n                .on_condition(|_left, right| {\n                    Expr::col((right, cake_filling::Column::CakeId))\n                        .gt(10)\n                        .into_condition()\n                })\n        )\n        .join(\n            JoinType::LeftJoin,\n            cake_filling::Relation::Filling\n                .def()\n                .on_condition(|_left, right| {\n                    Expr::col((right, filling::Column::Name))\n                        .like("%lemon%")\n                        .into_condition()\n                })\n        )\n        .join(JoinType::LeftJoin, filling::Relation::Vendor.def())\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id`, `cake`.`name` FROM `cake`",\n        "LEFT JOIN `fruit` ON `cake`.`id` = `fruit`.`cake_id` AND `fruit`.`name` LIKE \'%tropical%\'",\n        "LEFT JOIN `cake_filling` ON `cake`.`id` = `cake_filling`.`cake_id` AND `cake_filling`.`cake_id` > 10",\n        "LEFT JOIN `filling` ON `cake_filling`.`filling_id` = `filling`.`id` AND `filling`.`name` LIKE \'%lemon%\'",\n        "LEFT JOIN `vendor` ON `filling`.`vendor_id` = `vendor`.`id`",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(e.p,{children:"You can specify table alias in the join statement:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let cf = Alias::new("cf");\n\nassert_eq!(\n    cake::Entity::find()\n        .join_as(\n            JoinType::LeftJoin,\n            cake_filling::Relation::Cake.def().rev(),\n            cf.clone()\n        )\n        .join(\n            JoinType::LeftJoin,\n            cake_filling::Relation::Filling.def().from_alias(cf)\n        )\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id`, `cake`.`name` FROM `cake`",\n        "LEFT JOIN `cake_filling` AS `cf` ON `cake`.`id` = `cf`.`cake_id`",\n        "LEFT JOIN `filling` ON `cf`.`filling_id` = `filling`.`id`",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsxs)(e.h2,{id:"or-condition",children:[(0,t.jsx)(e.code,{children:"OR"})," condition"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"{6}",children:'#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        has_many = "super::fruit::Entity",\n        on_condition = r#"super::fruit::Column::Name.like("%tropical%")"#\n        condition_type = "any",\n    )]\n    OrTropicalFruit,\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",metastring:"{7,12}",children:'assert_eq!(\n    cake::Entity::find()\n        .column_as(\n            Expr::col((Alias::new("cake_filling_alias"), cake_filling::Column::CakeId)),\n            "cake_filling_cake_id"\n        )\n        .join(JoinType::LeftJoin, cake::Relation::OrTropicalFruit.def())\n        .join_as_rev(\n            JoinType::LeftJoin,\n            cake_filling::Relation::Cake\n                .def()\n                .condition_type(ConditionType::Any)\n                .on_condition(|left, _right| {\n                    Expr::col((left, cake_filling::Column::CakeId))\n                        .gt(10)\n                        .into_condition()\n                }),\n            Alias::new("cake_filling_alias")\n        )\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id`, `cake`.`name`, `cake_filling_alias`.`cake_id` AS `cake_filling_cake_id` FROM `cake`",\n        "LEFT JOIN `fruit` ON `cake`.`id` = `fruit`.`cake_id` OR `fruit`.`name` LIKE \'%tropical%\'",\n        "LEFT JOIN `cake_filling` AS `cake_filling_alias` ON `cake_filling_alias`.`cake_id` = `cake`.`id` OR `cake_filling_alias`.`cake_id` > 10",\n    ]\n    .join(" ")\n);\n'})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(s,{...n})}):s(n)}}}]);