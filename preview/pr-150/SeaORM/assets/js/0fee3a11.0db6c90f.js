"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[53609],{28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>d});var t=a(96540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},72149:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"basic-crud/select","title":"Select","description":"Once you have defined the entity, you are ready to retrieve data from the database. Each row of data in the database corresponds to a Model.","source":"@site/versioned_docs/version-0.10.x/05-basic-crud/01-select.md","sourceDirName":"05-basic-crud","slug":"/basic-crud/select","permalink":"/preview/pr-150/SeaORM/docs/0.10.x/basic-crud/select","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-0.10.x/05-basic-crud/01-select.md","tags":[],"version":"0.10.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756133696000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Newtype","permalink":"/preview/pr-150/SeaORM/docs/0.10.x/generate-entity/newtype"},"next":{"title":"Insert","permalink":"/preview/pr-150/SeaORM/docs/0.10.x/basic-crud/insert"}}');var r=a(74848),i=a(28453);const s={},d="Select",o={},l=[{value:"Find by Primary Key",id:"find-by-primary-key",level:2},{value:"Find with Conditions and Orders",id:"find-with-conditions-and-orders",level:2},{value:"Find Related Models",id:"find-related-models",level:2},{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Eager Loading",id:"eager-loading",level:3},{value:"One to One",id:"one-to-one",level:4},{value:"One to Many",id:"one-to-many",level:4},{value:"Paginate Result",id:"paginate-result",level:2},{value:"Cursor Pagination",id:"cursor-pagination",level:2},{value:"Select custom",id:"select-custom",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"select",children:"Select"})}),"\n",(0,r.jsxs)(n.p,{children:["Once you have defined the entity, you are ready to retrieve data from the database. Each row of data in the database corresponds to a ",(0,r.jsx)(n.code,{children:"Model"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["By default, SeaORM will select all columns defined in the ",(0,r.jsx)(n.code,{children:"Column"})," enum."]}),"\n",(0,r.jsx)(n.h2,{id:"find-by-primary-key",children:"Find by Primary Key"}),"\n",(0,r.jsxs)(n.p,{children:["Find a model by its primary key, it can be a single key or composite key. We start by calling ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.EntityTrait.html#method.find_by_id",children:(0,r.jsx)(n.code,{children:"find_by_id"})})," on ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.EntityTrait.html",children:(0,r.jsx)(n.code,{children:"Entity"})})," which helps you construct the select query and condition automatically. Then, fetch a single model from the database with the ",(0,r.jsx)(n.code,{children:"one"})," method."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use super::cake::Entity as Cake;\nuse super::cake_filling::Entity as CakeFilling;\n\n// Find by primary key\nlet cheese: Option<cake::Model> = Cake::find_by_id(1).one(db).await?;\n\n// Find by composite primary keys\nlet vanilla: Option<cake_filling::Model> = CakeFilling::find_by_id((6, 8)).one(db).await?;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"find-with-conditions-and-orders",children:"Find with Conditions and Orders"}),"\n",(0,r.jsxs)(n.p,{children:["In addition to retrieving a model by primary key, you can also retrieve one or more models matching specific conditions in a certain order. The ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.EntityTrait.html#method.find",children:(0,r.jsx)(n.code,{children:"find"})})," method gives you access to the query builder in SeaORM. It supports the construction of all common select expressions like ",(0,r.jsx)(n.code,{children:"where"})," and ",(0,r.jsx)(n.code,{children:"order by"}),". They can be constructed using ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/trait.QueryFilter.html#method.filter",children:(0,r.jsx)(n.code,{children:"filter"})})," and ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/query/trait.QueryOrder.html#method.order_by",children:(0,r.jsx)(n.code,{children:"order_by_*"})})," methods respectively."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Read more about ",(0,r.jsx)(n.a,{href:"/preview/pr-150/SeaORM/docs/0.10.x/advanced-query/conditional-expression",children:"conditional expression"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let chocolate: Vec<cake::Model> = Cake::find()\n    .filter(cake::Column::Name.contains("chocolate"))\n    .order_by_asc(cake::Column::Name)\n    .all(db)\n    .await?;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"find-related-models",children:"Find Related Models"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Read more about ",(0,r.jsx)(n.a,{href:"/preview/pr-150/SeaORM/docs/0.10.x/advanced-query/custom-joins",children:"table joins"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/trait.ModelTrait.html#method.find_related",children:(0,r.jsx)(n.code,{children:"find_related"})})," method."]}),"\n",(0,r.jsx)(n.p,{children:"Related models are loaded on demand when you ask for them, preferable if you want to load related models based on some application logic. Note that lazy loading will increase database round trips compared to eager loading."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Find a cake model first\nlet cheese: Option<cake::Model> = Cake::find_by_id(1).one(db).await?;\nlet cheese: cake::Model = cheese.unwrap();\n\n// Then, find all related fruits of this cake\nlet fruits: Vec<fruit::Model> = cheese.find_related(Fruit).all(db).await?;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,r.jsx)(n.p,{children:"All related models are loaded at once. This provides minimum overhead on database round trips compared to lazy loading."}),"\n",(0,r.jsx)(n.h4,{id:"one-to-one",children:"One to One"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.Select.html#method.find_also_related",children:(0,r.jsx)(n.code,{children:"find_also_related"})})," method."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let cake_and_fruit: Vec<(cake::Model, Option<fruit::Model>)> = Cake::find().find_also_related(Fruit).all(db).await?;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"one-to-many",children:"One to Many"}),"\n",(0,r.jsxs)(n.p,{children:["Using the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.Select.html#method.find_with_related",children:(0,r.jsx)(n.code,{children:"find_with_related"})})," method, the related models will be grouped by the parent models."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let cake_with_fruits: Vec<(cake::Model, Vec<fruit::Model>)> = Cake::find()\n    .find_with_related(Fruit)\n    .all(db)\n    .await?;\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["Since 0.9.0, ",(0,r.jsx)(n.code,{children:"SelectTwoMany::one()"})," method has been dropped:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let cake_with_fruits: Option<(cake::Model, Option<fruit::Model>)> = Cake::find()\n    .find_with_related(Fruit)\n    .one(db) // This method has been dropped\n    .await?;\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"SelectTwoMany"})," is for selecting models of a one-to-many relationship\nbut ",(0,r.jsx)(n.code,{children:"SelectTwoMany::one()"})," returns ",(0,r.jsx)(n.code,{children:"Option<(E, Option<F>)>"}),"\nand the return value is a pair of models instead of ",(0,r.jsx)(n.code,{children:"(E, Vec<F>)"}),"\nwhich is a weird query result for a one-to-many relationship."]}),(0,r.jsxs)(n.p,{children:["Users are advised to query ",(0,r.jsx)(n.code,{children:"(E, Vec<F>)"})," by first querying ",(0,r.jsx)(n.code,{children:"E"})," from the database,\nthen use ",(0,r.jsx)(n.code,{children:"find_related"})," method to query ",(0,r.jsx)(n.code,{children:"Vec<F>"}),".\nRead ",(0,r.jsx)(n.a,{href:"#lazy-loading",children:"lazy loading"})," for details."]})]}),"\n",(0,r.jsxs)(n.p,{children:["If you are building a web API that perform selecting nested relation extensively. Consider serving a GraphQL server instead. ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/seaography",children:"seaography"}),' is a GraphQL framework for building GraphQL resolvers using SeaORM entities. With GraphQL resolver in place select above nested relation is straightforward and easy. Check "',(0,r.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2022-09-27-getting-started-with-seaography/#query-data-via-graphql",children:"Getting Started with Seaography"}),'" to learn more.']}),"\n",(0,r.jsx)(n.h2,{id:"paginate-result",children:"Paginate Result"}),"\n",(0,r.jsxs)(n.p,{children:["Convert any SeaORM select into a ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/struct.Paginator.html",children:"paginator"})," with custom page size."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{entity::*, query::*, tests_cfg::cake};\nlet mut cake_pages = cake::Entity::find()\n    .order_by_asc(cake::Column::Id)\n    .paginate(db, 50);\n \nwhile let Some(cakes) = cake_pages.fetch_and_next().await? {\n    // Do something on cakes: Vec<cake::Model>\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"cursor-pagination",children:"Cursor Pagination"}),"\n",(0,r.jsx)(n.p,{children:"Use cursor pagination If you want to paginate rows based on column(s) such as the primary key."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{entity::*, query::*, tests_cfg::cake};\n// Create a cursor that order by `cake`.`id`\nlet mut cursor = cake::Entity::find().cursor_by(cake::Column::Id);\n\n// Filter paginated result by `cake`.`id` > 1 AND `cake`.`id` < 100\ncursor.after(1).before(100);\n\n// Get first 10 rows (order by `cake`.`id` ASC)\nfor cake in cursor.first(10).all(db).await? {\n    // Do something on cake: cake::Model\n}\n\n// Get last 10 rows (order by `cake`.`id` DESC but rows are returned in ascending order)\nfor cake in cursor.last(10).all(db).await? {\n    // Do something on cake: cake::Model\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Paginate rows based on a composite primary key is also available."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{entity::*, query::*, tests_cfg::cake_filling};\nlet rows = cake_filling::Entity::find()\n    .cursor_by((cake_filling::Column::CakeId, cake_filling::Column::FillingId))\n    .after((0, 1))\n    .before((10, 11))\n    .first(3)\n    .all(&db)\n    .await?,\n"})}),"\n",(0,r.jsx)(n.h2,{id:"select-custom",children:"Select custom"}),"\n",(0,r.jsxs)(n.p,{children:["If you want to select custom columns and expressions, read the ",(0,r.jsx)(n.a,{href:"/preview/pr-150/SeaORM/docs/0.10.x/advanced-query/custom-select",children:"custom select"})," section."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);