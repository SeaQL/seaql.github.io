"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[19734],{19679:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"advanced-query/advanced-joins","title":"Advanced Joins","description":"An anatomy of a complex relational query with multiple joins and custom selects.","source":"@site/versioned_docs/version-1.1.x/08-advanced-query/04-advanced-joins.md","sourceDirName":"08-advanced-query","slug":"/advanced-query/advanced-joins","permalink":"/preview/pr-150/SeaORM/docs/advanced-query/advanced-joins","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/08-advanced-query/04-advanced-joins.md","tags":[],"version":"1.1.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1755770072000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Aggregate Functions","permalink":"/preview/pr-150/SeaORM/docs/advanced-query/aggregate-function"},"next":{"title":"Sub Query","permalink":"/preview/pr-150/SeaORM/docs/advanced-query/subquery"}}');var t=i(74848),r=i(28453);const a={},s="Advanced Joins",d={},l=[{value:"Schema",id:"schema",level:2},{value:"<code>BaseProduct</code>",id:"baseproduct",level:4},{value:"<code>ComplexProduct</code>",id:"complexproduct",level:4},{value:"<code>ProductType</code>",id:"producttype",level:4},{value:"1. Define result data structure",id:"1-define-result-data-structure",level:2},{value:"2. Define helper aliases",id:"2-define-helper-aliases",level:2},{value:"3. Custom selects",id:"3-custom-selects",level:2},{value:"Custom join conditions",id:"custom-join-conditions",level:3},{value:"4. Filter Conditions",id:"4-filter-conditions",level:2},{value:"5. Extra: associated models",id:"5-extra-associated-models",level:2},{value:"<code>ProductHistory</code>",id:"producthistory",level:4}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"advanced-joins",children:"Advanced Joins"})}),"\n",(0,t.jsx)(n.p,{children:"An anatomy of a complex relational query with multiple joins and custom selects."}),"\n",(0,t.jsx)(n.h2,{id:"schema",children:"Schema"}),"\n",(0,t.jsxs)(n.p,{children:["Suppose we have a schema design of ",(0,t.jsx)(n.code,{children:"BaseProduct"})," -> ",(0,t.jsx)(n.code,{children:"ComplexProduct"}),", ",(0,t.jsx)(n.code,{children:"BaseProduct"})," -> ",(0,t.jsx)(n.code,{children:"ProductTypes"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"baseproduct",children:(0,t.jsx)(n.code,{children:"BaseProduct"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "base_product")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i64,\n    #[sea_orm(unique)]\n    pub name: String,\n    pub type_id: i32, // linking to product_type\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_one = "super::complex_product::Entity")]\n    ComplexProduct,\n    #[sea_orm(has_many = "super::product_history::Entity")]\n    ProductHistory,\n    #[sea_orm(\n        belongs_to = "super::product_type::Entity",\n        from = "Column::TypeId",\n        to = "super::product_type::Column::Id",\n        on_update = "NoAction",\n        on_delete = "NoAction"\n    )]\n    ProductType,\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"complexproduct",children:(0,t.jsx)(n.code,{children:"ComplexProduct"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "complex_product")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub product_id: i64, // linking to base_product\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub price: Option<Decimal>,\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub lot_size: Option<Decimal>,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"producttype",children:(0,t.jsx)(n.code,{children:"ProductType"})}),"\n",(0,t.jsx)(n.p,{children:"Basically a 'enum table'."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "product_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)]\n    pub name: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = "super::base_product::Entity")]\n    BaseProduct,\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"1-define-result-data-structure",children:"1. Define result data structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq, Eq, FromQueryResult, Serialize)]\npub struct ComplexProduct {\n    pub id: i64,\n    pub name: String,\n    pub r#type: String,\n    pub price: Decimal,\n    pub lot_size: Decimal,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n    #[sea_orm(skip)]\n    pub history: Vec<product_history::Model>,\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:"Serialize"}),", you can transform the select result into JSON directly."]}),"\n",(0,t.jsx)(n.h2,{id:"2-define-helper-aliases",children:"2. Define helper aliases"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[derive(DeriveIden, Clone, Copy)]\npub struct Id;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Name;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Base;\n\nuse complex_product::Entity as Prod;\npub type ProdCol = <Prod as EntityTrait>::Column;\ntype ProdRel = <Prod as EntityTrait>::Relation;\n"})}),"\n",(0,t.jsx)(n.p,{children:"This would make our code much more concise and readable."}),"\n",(0,t.jsxs)(n.p,{children:["Avoid using ",(0,t.jsx)(n.code,{children:"Alias::new"})," because it's error-prone and slightly more expensive."]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"If you need to use many aliases, you can define a enum:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[derive(DeriveIden, Clone, Copy)]\npub enum Prod {\n    Base,\n    Frame,\n    Package,\n}\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"3-custom-selects",children:"3. Custom selects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub fn query() -> Select<complex_product::Entity> {\n    complex_product::Entity::find()\n        .select_only()\n        .tbl_col_as((Base, Id), "id")\n        .tbl_col_as((Base, Name), "name")\n        .column_as(product_type::Column::Name, "type")\n        .column_as(ProdCol::Price, "price")\n        .column_as(ProdCol::LotSize, "lot_size")\n        .column_as(ProdCol::DateAdded, "date_added")\n        .column_as(ProdCol::LastModified, "last_modified")\n        .join_as(JoinType::InnerJoin, ProdRel::BaseProduct.def(), Base)\n        .join(JoinType::InnerJoin, base_product::Relation::ProductType.def().from_alias(Base))\n        .order_by_asc(Expr::col((Base, Id)))\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Our query starts from ",(0,t.jsx)(n.code,{children:"ComplexProduct"}),". We join back to ",(0,t.jsx)(n.code,{children:"BaseProduct"}),", alias it as ",(0,t.jsx)(n.code,{children:"Base"}),". We then join to ",(0,t.jsx)(n.code,{children:"ProductType"})," via ",(0,t.jsx)(n.code,{children:"Base"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"ComplexProduct -> BaseProduct as Base -> ProductType\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"It's possible to join in a diamond topology:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"ComplexProduct -> BaseProduct -> Attribute\n               -> Material    -> Attribute\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:".join_as(JoinType::LeftJoin, complex_product::Relation::BaseProduct.def(), Base)\n.join_as(JoinType::LeftJoin, complex_product::Relation::Material.def(), Material)\n.join(JoinType::InnerJoin, base_product::Relation::Attribute.def().from_alias(Base))\n.join(JoinType::InnerJoin, material::Relation::Attribute.def().from_alias(Material))\n"})})]}),"\n",(0,t.jsx)(n.h3,{id:"custom-join-conditions",children:"Custom join conditions"}),"\n",(0,t.jsxs)(n.p,{children:["You can use the ",(0,t.jsx)(n.code,{children:"join"})," method to construct complex joins in select queries. It takes any ",(0,t.jsx)(n.code,{children:"RelationDef"}),", and you can further customize the join conditions. Below is an illustration (albeit it's from the Bakery schema):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use sea_orm::{JoinType, RelationTrait};\nuse sea_query::Expr;\n\nassert_eq!(\n    cake::Entity::find()\n        .column_as(filling::Column::Id.count(), "count")\n        .column_as(\n            Expr::col((Alias::new("fruit_alias"), fruit::Column::Name)).into_simple_expr(),\n            "fruit_name"\n        )\n        // construct `RelationDef` on the fly\n        .join_rev(\n            JoinType::InnerJoin,\n            cake_filling::Entity::belongs_to(cake::Entity)\n                .from(cake_filling::Column::CakeId)\n                .to(cake::Column::Id)\n                .into()\n        )\n        // reuse a `Relation` from existing Entity\n        .join(JoinType::InnerJoin, cake_filling::Relation::Filling.def())\n        // join with table alias and custom on condition\n        .join_as(\n            JoinType::LeftJoin,\n            cake::Relation::Fruit\n                .def()\n                .on_condition(|_left, right| {\n                    Expr::col((right, fruit::Column::Name))\n                        .like("%tropical%")\n                        .into_condition()\n                }),\n            Alias::new("fruit_alias")\n        )\n        .group_by(cake::Column::Id)\n        .having(filling::Column::Id.count().equals(Expr::value(2)))\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id`, `cake`.`name`, COUNT(`filling`.`id`) AS `count`, `fruit_alias`.`name` AS `fruit_name` FROM `cake`",\n        "INNER JOIN `cake_filling` ON `cake_filling`.`cake_id` = `cake`.`id`",\n        "INNER JOIN `filling` ON `cake_filling`.`filling_id` = `filling`.`id`",\n        "LEFT JOIN `fruit` AS `fruit_alias` ON `cake`.`id` = `fruit_alias`.`cake_id` AND `fruit_alias`.`name` LIKE \'%tropical%\'",\n        "GROUP BY `cake`.`id`",\n        "HAVING COUNT(`filling`.`id`) = 2",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"4-filter-conditions",children:"4. Filter Conditions"}),"\n",(0,t.jsx)(n.p,{children:"Suppose we support the following query parameters on the API:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"\n#[derive(Default, Deserialize)]\npub struct Query {\n    #[serde(default)]\n    pub id: Vec<i64>,\n    pub name: Option<String>,\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn condition(query: Query) -> Condition {\n    Condition::all()\n        .add_option(if !query.id.is_empty() {\n            Some(Expr::col((Base, Id)).is_in(query.id))\n        } else { None })\n        .add_option(if let Some(name) = &query.name {\n            Some(Expr::col((Base, Name)).like(name))\n        } else { None })\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Bonus tip: if you're only using Postgres you can replace ",(0,t.jsx)(n.code,{children:"is_in"})," with ",(0,t.jsx)(n.code,{children:"any"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use sea_orm::sea_query::extension::postgres::PgFunc;\n\nExpr::col((Base, Id)).eq(PgFunc::any(query.id)) // WHERE base.id = ANY($N)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let products = query()\n    .filter(condition(q))\n    .into_model::<ComplexProduct>()\n    .all(db)\n    .await?;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"5-extra-associated-models",children:"5. Extra: associated models"}),"\n",(0,t.jsxs)(n.p,{children:["Now, suppose we have a data structure associated with each ",(0,t.jsx)(n.code,{children:"BaseProduct"})," recording its history:"]}),"\n",(0,t.jsx)(n.h4,{id:"producthistory",children:(0,t.jsx)(n.code,{children:"ProductHistory"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]\n#[sea_orm(table_name = "product_history")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[serde(skip)]\n    pub id: i32,\n    pub product_id: i64,\n    pub from: DateTime,\n    pub until: DateTime,\n    pub name: Option<String>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Let's make a helper function to query the histories associated to a set of products:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub fn history_of(ids: Vec<i64>) -> Select<product_history::Entity> {\n    product_history::Entity::find()\n        .filter(Expr::col(product_history::Column::ProductId).is_in(ids))\n        .order_by_asc(product_history::Column::Id)\n}\n\nlet histories = history_of(products.iter().map(|s| s.id).collect::<Vec<_>>())\n    .all(db)\n    .await?;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The final step is to associate ",(0,t.jsx)(n.code,{children:"product_history::Model"})," to ",(0,t.jsx)(n.code,{children:"ComplexProduct"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub fn associate(\n    mut parent: Vec<ComplexProduct>,\n    children: Vec<product_history::Model>,\n) -> Vec<ComplexProduct> {\n    let len = parent.len();\n    parent.dedup_by_key(|s| s.id);\n    if len != parent.len() {\n        warn!("parent is not unique.");\n    }\n\n    let parent_id_map: HashMap<i64, usize> = parent\n        .iter()\n        .enumerate()\n        .map(|(i, s)| (s.id, i))\n        .collect();\n\n    // put children into associated parent\n    for item in children {\n        if let Some(index) = parent_id_map.get(&item.product_id) {\n            parent[*index].history.push(item);\n        }\n    }\n\n    parent\n}\n\nlet products = associate(products, histories);\n'})}),"\n",(0,t.jsx)(n.p,{children:'This is sometimes called "data loader" pattern, and can be generalized with generics to work with any model.'})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var o=i(96540);const t={},r=o.createContext(t);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);