"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[9328],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},66228:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"basic-crud/insert","title":"Insert","description":"Insert One","source":"@site/docs/05-basic-crud/04-insert.md","sourceDirName":"05-basic-crud","slug":"/basic-crud/insert","permalink":"/preview/pr-150/SeaORM/docs/next/basic-crud/insert","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/05-basic-crud/04-insert.md","tags":[],"version":"current","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756136705000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ActiveModel","permalink":"/preview/pr-150/SeaORM/docs/next/basic-crud/active-model"},"next":{"title":"Update","permalink":"/preview/pr-150/SeaORM/docs/next/basic-crud/update"}}');var i=t(74848),s=t(28453);const a={},o="Insert",d={},c=[{value:"Insert One",id:"insert-one",level:2},{value:"Insert Many",id:"insert-many",level:2},{value:"On Conflict",id:"on-conflict",level:2},{value:"MySQL support",id:"mysql-support",level:3},{value:"Returning Inserted Models",id:"returning-inserted-models",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"insert",children:"Insert"})}),"\n",(0,i.jsx)(n.h2,{id:"insert-one",children:"Insert One"}),"\n",(0,i.jsxs)(n.p,{children:["Insert an active model and get back a fresh ",(0,i.jsx)(n.code,{children:"Model"}),". Its value is retrieved from database, so any auto-generated fields will be populated."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let pear = fruit::ActiveModel {\n    name: Set("Pear".to_owned()),\n    ..Default::default() // all other attributes are `NotSet`\n};\n\nlet pear: fruit::Model = pear.insert(db).await?;\n'})}),"\n",(0,i.jsx)(n.p,{children:"Insert an active model and get back the last insert id. Its type matches the model's primary key type, so it could be a tuple if the model has a composite primary key."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let pear = fruit::ActiveModel {\n    name: Set("Pear".to_owned()),\n    ..Default::default() // all other attributes are `NotSet`\n};\n\nlet res: InsertResult = fruit::Entity::insert(pear).exec(db).await?;\nassert_eq!(res.last_insert_id, 28)\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"SQL Server (MSSQL) backend",type:"tip",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"IDENTITY INSERT"})," of MSSQL is documented ",(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM-X/docs/basic-crud/insert/",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"insert-many",children:"Insert Many"}),"\n",(0,i.jsx)(n.p,{children:"Insert many active models and get back the last insert id."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let apple = fruit::ActiveModel {\n    name: Set("Apple".to_owned()),\n    ..Default::default()\n};\n\nlet orange = fruit::ActiveModel {\n    name: Set("Orange".to_owned()),\n    ..Default::default()\n};\n\nlet res: InsertResult = Fruit::insert_many([apple, orange]).exec(db).await?;\nassert_eq!(res.last_insert_id, 30)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Supplying an empty set to ",(0,i.jsx)(n.code,{children:"insert_many"})," method will result in an error. However, you can change the behaviour with ",(0,i.jsx)(n.code,{children:"on_empty_do_nothing"})," which wraps the ",(0,i.jsx)(n.code,{children:"InsertResult"})," with a ",(0,i.jsx)(n.code,{children:"TryInsertResult"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let res = Bakery::insert_many(std::iter::empty())\n    .on_empty_do_nothing()\n    .exec(db)\n    .await;\n\nassert!(matches!(res, Ok(TryInsertResult::Empty)));\n"})}),"\n",(0,i.jsx)(n.h2,{id:"on-conflict",children:"On Conflict"}),"\n",(0,i.jsx)(n.p,{children:"Insert active model with on conflict behaviour."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let orange = cake::ActiveModel {\n    id: ActiveValue::set(2),\n    name: ActiveValue::set("Orange".to_owned()),\n};\n\nassert_eq!(\n    cake::Entity::insert(orange.clone())\n        .on_conflict(\n            // on conflict do nothing\n            sea_query::OnConflict::column(cake::Column::Name)\n                .do_nothing()\n                .to_owned()\n        )\n        .build(DbBackend::Postgres)\n        .to_string(),\n    r#"INSERT INTO "cake" ("id", "name") VALUES (2, \'Orange\') ON CONFLICT ("name") DO NOTHING"#,\n);\n\nassert_eq!(\n    cake::Entity::insert(orange)\n        .on_conflict(\n            // on conflict do update\n            sea_query::OnConflict::column(cake::Column::Name)\n                .update_column(cake::Column::Name)\n                .to_owned()\n        )\n        .build(DbBackend::Postgres)\n        .to_string(),\n    r#"INSERT INTO "cake" ("id", "name") VALUES (2, \'Orange\') ON CONFLICT ("name") DO UPDATE SET "name" = "excluded"."name""#,\n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Performing an upsert statement without inserting or updating any of the row will result in a ",(0,i.jsx)(n.code,{children:"DbErr::RecordNotInserted"})," error."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// When `id` column have conflicting value, do nothing\nlet on_conflict = OnConflict::column(Column::Id).do_nothing().to_owned();\n\n// Insert `1`, `2`, `3` into the table\nlet res = Entity::insert_many([\n    ActiveModel { id: Set(1) },\n    ActiveModel { id: Set(2) },\n    ActiveModel { id: Set(3) },\n])\n.on_conflict(on_conflict.clone())\n.exec(db)\n.await;\n\nassert_eq!(res?.last_insert_id, 3);\n\n// Insert `4` into the table together with the previous 3 rows\nlet res = Entity::insert_many([\n    ActiveModel { id: Set(1) },\n    ActiveModel { id: Set(2) },\n    ActiveModel { id: Set(3) },\n    ActiveModel { id: Set(4) },\n])\n.on_conflict(on_conflict.clone())\n.exec(db)\n.await;\n\nassert_eq!(res?.last_insert_id, 4);\n\n// Repeat last insert. Since all 4 rows already exist, this essentially did nothing.\n// A `DbErr::RecordNotInserted` error will be thrown.\nlet res = Entity::insert_many([\n    ActiveModel { id: Set(1) },\n    ActiveModel { id: Set(2) },\n    ActiveModel { id: Set(3) },\n    ActiveModel { id: Set(4) },\n])\n.on_conflict(on_conflict)\n.exec(db)\n.await;\n\nassert_eq!(res.err(), Some(DbErr::RecordNotInserted));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you want ",(0,i.jsx)(n.code,{children:"RecordNotInserted"})," to be an ",(0,i.jsx)(n.code,{children:"Ok"})," instead of an error, call ",(0,i.jsx)(n.code,{children:".do_nothing()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let res = Entity::insert_many([..])\n    .on_conflict(on_conflict)\n    .do_nothing()\n    .exec(db)\n    .await;\n\nassert!(matches!(res, Ok(TryInsertResult::Conflicted)));\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mysql-support",children:"MySQL support"}),"\n",(0,i.jsxs)(n.p,{children:["Set ",(0,i.jsx)(n.code,{children:"ON CONFLICT"})," on primary key ",(0,i.jsx)(n.code,{children:"DO NOTHING"}),", but with MySQL specific polyfill."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let orange = cake::ActiveModel {\n    id: ActiveValue::set(2),\n    name: ActiveValue::set("Orange".to_owned()),\n};\n\nassert_eq!(\n    cake::Entity::insert(orange.clone())\n        .on_conflict_do_nothing()\n        .build(DbBackend::MySql)\n        .to_string(),\n    r#"INSERT INTO `cake` (`id`, `name`) VALUES (2, \'Orange\') ON DUPLICATE KEY UPDATE `id` = `id`"#,\n);\nassert_eq!(\n    cake::Entity::insert(orange.clone())\n        .on_conflict_do_nothing()\n        .build(DbBackend::Postgres)\n        .to_string(),\n    r#"INSERT INTO "cake" ("id", "name") VALUES (2, \'Orange\') ON CONFLICT ("id") DO NOTHING"#,\n);\nassert_eq!(\n    cake::Entity::insert(orange)\n        .on_conflict_do_nothing()\n        .build(DbBackend::Sqlite)\n        .to_string(),\n    r#"INSERT INTO "cake" ("id", "name") VALUES (2, \'Orange\') ON CONFLICT ("id") DO NOTHING"#,\n);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"returning-inserted-models",children:"Returning Inserted Models"}),"\n",(0,i.jsx)(n.p,{children:"Supported by Postgres and SQLite, the following returns the newly inserted models after insert."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::insert(cake::ActiveModel {\n        id: NotSet,\n        name: Set("Apple Pie".to_owned()),\n    })\n    .exec_with_returning(&db)\n    .await?,\n    cake::Model {\n        id: 1,\n        name: "Apple Pie".to_owned(),\n    }\n);\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::insert_many([\n        cake::ActiveModel {\n            id: NotSet,\n            name: Set("Apple Pie".to_owned()),\n        },\n        cake::ActiveModel {\n            id: NotSet,\n            name: Set("Choco Pie".to_owned()),\n        },\n    ])\n    .exec_with_returning(&db)\n    .await?,\n    [\n        cake::Model {\n            id: 1,\n            name: "Apple Pie".to_owned(),\n        },\n        cake::Model {\n            id: 2,\n            name: "Choco Pie".to_owned(),\n        }\n    ]\n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["There is also a ",(0,i.jsx)(n.code,{children:"exec_with_returning_keys"})," if you only need the primary keys after insert."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"assert_eq!(\n    cakes_bakers::Entity::insert_many([\n        cakes_bakers::ActiveModel {\n            cake_id: Set(1),\n            baker_id: Set(2),\n        },\n        cakes_bakers::ActiveModel {\n            cake_id: Set(2),\n            baker_id: Set(1),\n        },\n    ])\n    .exec_with_returning_keys(db)\n    .await\n    .unwrap(),\n    [(1, 2), (2, 1)]\n);\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);