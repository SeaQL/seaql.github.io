"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[91051],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var i=t(96540);const a={},r=i.createContext(a);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(r.Provider,{value:n},e.children)}},99996:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"internal-design/expanded-entity-format","title":"Expanded Entity Format","description":"This was the entity format before compact format, nowadays the compact format is the default, and all new features are added on top of the compact format.","source":"@site/versioned_docs/version-1.1.x/12-internal-design/05-expanded-entity-format.md","sourceDirName":"12-internal-design","slug":"/internal-design/expanded-entity-format","permalink":"/preview/pr-150/SeaORM/docs/internal-design/expanded-entity-format","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/versioned_docs/version-1.1.x/12-internal-design/05-expanded-entity-format.md","tags":[],"version":"1.1.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1756120076000,"sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Architecture","permalink":"/preview/pr-150/SeaORM/docs/internal-design/architecture"},"next":{"title":"What\'s Next for SeaORM?","permalink":"/preview/pr-150/SeaORM/docs/whats-next/whats-next"}}');var a=t(74848),r=t(28453);const l={},s="Expanded Entity Format",o={},d=[{value:"Entity",id:"entity",level:2},{value:"Column",id:"column",level:2},{value:"Additional properties",id:"additional-properties",level:3},{value:"Cast Column Type on Select and Save",id:"cast-column-type-on-select-and-save",level:3},{value:"Primary Key",id:"primary-key",level:2},{value:"Model",id:"model",level:2},{value:"Nullable Attribute",id:"nullable-attribute",level:3},{value:"Active Model",id:"active-model",level:2},{value:"Relation",id:"relation",level:2},{value:"Related",id:"related",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"expanded-entity-format",children:"Expanded Entity Format"})}),"\n",(0,a.jsx)(n.p,{children:"This was the entity format before compact format, nowadays the compact format is the default, and all new features are added on top of the compact format."}),"\n",(0,a.jsxs)(n.p,{children:["Expanded format is considered legacy. But if you are curious what ",(0,a.jsx)(n.code,{children:"DeriveEntityModel"})," expands into, read along."]}),"\n",(0,a.jsxs)(n.p,{children:["The expanded entity format can be generated by ",(0,a.jsx)(n.code,{children:"sea-orm-cli"})," with the ",(0,a.jsx)(n.code,{children:"--expanded-format"})," option."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's go through the sections of the expanded ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/cake_expanded.rs",children:"Cake"})," entity."]}),"\n",(0,a.jsx)(n.h2,{id:"entity",children:"Entity"}),"\n",(0,a.jsxs)(n.p,{children:["By implementing the ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.EntityTrait.html",children:(0,a.jsx)(n.code,{children:"EntityTrait"})}),", you can perform CRUD operations on the given table."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn schema_name(&self) -> Option<&str> {\n        None\n    }\n\n    fn table_name(&self) -> &str {\n        "cake"\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"column",children:"Column"}),"\n",(0,a.jsx)(n.p,{children:"An enum representing all columns in this table."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Name,\n}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Name => ColumnType::String(StringLen::None).def(),\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["All column names are assumed to be in snake-case. You can override the column name by specifying the ",(0,a.jsx)(n.code,{children:"column_name"})," attribute."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'pub enum Column {\n    Id,      // maps to "id" in SQL\n    Name,    // maps to "name" in SQL\n    #[sea_orm(column_name = "create_at")]\n    CreateAt // maps to "create_at" in SQL\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To specify the datatype of each column, the ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/enum.ColumnType.html",children:(0,a.jsx)(n.code,{children:"ColumnType"})})," enum can be used."]}),"\n",(0,a.jsx)(n.h3,{id:"additional-properties",children:"Additional properties"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Default Value"}),"\n",(0,a.jsx)(n.li,{children:"Unique"}),"\n",(0,a.jsx)(n.li,{children:"Indexed"}),"\n",(0,a.jsx)(n.li,{children:"Nullable"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'ColumnType::String(StringLen::None).def().default_value("Sam").unique().indexed().nullable()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cast-column-type-on-select-and-save",children:"Cast Column Type on Select and Save"}),"\n",(0,a.jsxs)(n.p,{children:["If you need to select a column as one type but save it into the database as another, you can override the ",(0,a.jsx)(n.code,{children:"select_as"})," and the ",(0,a.jsx)(n.code,{children:"save_as"})," methods to perform the casting. A typical use case is selecting a column of type ",(0,a.jsx)(n.code,{children:"citext"})," (case-insensitive text) as ",(0,a.jsx)(n.code,{children:"String"})," in Rust and saving it into the database as ",(0,a.jsx)(n.code,{children:"citext"}),". One should override the ",(0,a.jsx)(n.code,{children:"ColumnTrait"}),"'s methods as below:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use sea_orm::sea_query::{Expr, SimpleExpr, Alias}\n\nimpl ColumnTrait for Column {\n    // Snipped...\n\n    /// Cast column expression used in select statement.\n    fn select_as(&self, expr: Expr) -> SimpleExpr {\n        match self {\n            Column::CaseInsensitiveText => expr.cast_as(Alias::new("text")),\n            _ => self.select_enum_as(expr),\n        }\n    }\n\n    /// Cast value of a column into the correct type for database storage.\n    fn save_as(&self, val: Expr) -> SimpleExpr {\n        match self {\n            Column::CaseInsensitiveText => val.cast_as(Alias::new("citext")),\n            _ => self.save_enum_as(val),\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"primary-key",children:"Primary Key"}),"\n",(0,a.jsx)(n.p,{children:"An enum representing the primary key of this table. A composite key is represented by an enum with multiple variants."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"ValueType"})," defines the type of last_insert_id in ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/struct.InsertResult.html",children:(0,a.jsx)(n.code,{children:"InsertResult"})}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"auto_increment"})," defines whether the primary key has an auto-generated value."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    #[sea_orm(column_name = "id")] // Override the default column name\n    Id,  // maps to "id" in SQL\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n\n    fn auto_increment() -> bool {\n        true\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Example composite key"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub enum PrimaryKey {\n    CakeId,\n    FruitId,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = (i32, i32);\n\n    fn auto_increment() -> bool {\n        false\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"model",children:"Model"}),"\n",(0,a.jsx)(n.p,{children:"The Rust struct for storing query results."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq, Eq, DeriveModel, DeriveActiveModel)]\npub struct Model {\n    pub id: i32,\n    pub name: String,\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"nullable-attribute",children:"Nullable Attribute"}),"\n",(0,a.jsxs)(n.p,{children:["If the table column is nullable, wrap it with an ",(0,a.jsx)(n.code,{children:"Option"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",metastring:"{3}",children:"pub struct Model {\n    pub id: i32,\n    pub name: Option<String>,\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"active-model",children:"Active Model"}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.code,{children:"ActiveModel"})," has all the attributes of its corresponding ",(0,a.jsx)(n.code,{children:"Model"})," but all attributes are wrapped in an ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/enum.ActiveValue.html",children:(0,a.jsx)(n.code,{children:"ActiveValue"})}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq)]\npub struct ActiveModel {\n    pub id: ActiveValue<i32>,\n    pub name: ActiveValue<Option<String>>,\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"relation",children:"Relation"}),"\n",(0,a.jsx)(n.p,{children:"Specifying the relations with other entities."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Fruit,\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,a.jsx)(n.p,{children:"Defining trait bounds to help you query related entities together, especially helpful in many-to-many relations."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"impl Related<super::fruit::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Fruit.def()\n    }\n}\n\nimpl Related<super::filling::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);