"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[67811],{28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>l});var r=n(96540);const i={},s=r.createContext(i);function d(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(s.Provider,{value:t},e.children)}},28489:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"generate-entity/column-types","title":"Column Types","description":"Type mappings","source":"@site/docs/04-generate-entity/03-column-types.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/column-types","permalink":"/preview/pr-169/SeaORM/docs/generate-entity/column-types","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/04-generate-entity/03-column-types.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1770970604000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Entity Format","permalink":"/preview/pr-169/SeaORM/docs/generate-entity/entity-format"},"next":{"title":"ActiveEnum","permalink":"/preview/pr-169/SeaORM/docs/generate-entity/enumeration"}}');var i=n(74848),s=n(28453);const d={},l="Column Types",c={},a=[{value:"Type mappings",id:"type-mappings",level:2},{value:"JSON column",id:"json-column",level:2},{value:"Postgres Array",id:"postgres-array",level:2},{value:"Postgres Vector",id:"postgres-vector",level:2},{value:"IpNetwork (Postgres)",id:"ipnetwork-postgres",level:2},{value:"Unix Timestamp",id:"unix-timestamp",level:2}];function o(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"column-types",children:"Column Types"})}),"\n",(0,i.jsx)(t.h2,{id:"type-mappings",children:"Type mappings"}),"\n",(0,i.jsx)(t.p,{children:"The column type will be derived automatically with the following mapping."}),"\n",(0,i.jsx)(t.admonition,{title:"SQL Server (MSSQL) backend",type:"tip",children:(0,i.jsxs)(t.p,{children:["The type mappings of MSSQL can be found ",(0,i.jsx)(t.a,{href:"https://www.sea-ql.org/SeaORM-X/docs/generate-entity/entity-structure/",children:"here"}),"."]})}),"\n",(0,i.jsx)(t.p,{children:"For the mappings of Rust primitive data types:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Rust type"}),(0,i.jsxs)(t.th,{children:["Database Type ",(0,i.jsx)("br",{})," (",(0,i.jsx)(t.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/entity/enum.ColumnType.html",children:(0,i.jsx)(t.code,{children:"ColumnType"})}),")"]}),(0,i.jsxs)(t.th,{children:["SQLite ",(0,i.jsx)("br",{})," datatype"]}),(0,i.jsxs)(t.th,{children:["MySQL ",(0,i.jsx)("br",{})," datatype"]}),(0,i.jsxs)(t.th,{children:["PostgreSQL ",(0,i.jsx)("br",{})," datatype"]})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"String"})}),(0,i.jsx)(t.td,{children:"Char"}),(0,i.jsx)(t.td,{children:"char"}),(0,i.jsx)(t.td,{children:"char"}),(0,i.jsx)(t.td,{children:"char"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"String"})}),(0,i.jsx)(t.td,{children:"String"}),(0,i.jsx)(t.td,{children:"varchar"}),(0,i.jsx)(t.td,{children:"varchar"}),(0,i.jsx)(t.td,{children:"varchar"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"i8"})}),(0,i.jsx)(t.td,{children:"TinyInteger"}),(0,i.jsx)(t.td,{children:"tinyint"}),(0,i.jsx)(t.td,{children:"tinyint"}),(0,i.jsx)(t.td,{children:"char"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"u8"})}),(0,i.jsx)(t.td,{children:"TinyUnsigned"}),(0,i.jsx)(t.td,{children:"tinyint"}),(0,i.jsx)(t.td,{children:"tinyint unsigned"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"i16"})}),(0,i.jsx)(t.td,{children:"SmallInteger"}),(0,i.jsx)(t.td,{children:"smallint"}),(0,i.jsx)(t.td,{children:"smallint"}),(0,i.jsx)(t.td,{children:"smallint"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"u16"})}),(0,i.jsx)(t.td,{children:"SmallUnsigned"}),(0,i.jsx)(t.td,{children:"smallint"}),(0,i.jsx)(t.td,{children:"smallint unsigned"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"i32"})}),(0,i.jsx)(t.td,{children:"Integer"}),(0,i.jsx)(t.td,{children:"integer"}),(0,i.jsx)(t.td,{children:"int"}),(0,i.jsx)(t.td,{children:"integer"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"u32"})}),(0,i.jsx)(t.td,{children:"Unsigned"}),(0,i.jsx)(t.td,{children:"integer"}),(0,i.jsx)(t.td,{children:"int unsigned"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"i64"})}),(0,i.jsx)(t.td,{children:"BigInteger"}),(0,i.jsx)(t.td,{children:"integer"}),(0,i.jsx)(t.td,{children:"bigint"}),(0,i.jsx)(t.td,{children:"bigint"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"u64"})}),(0,i.jsx)(t.td,{children:"BigUnsigned"}),(0,i.jsx)(t.td,{children:"integer"}),(0,i.jsx)(t.td,{children:"bigint unsigned"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"f32"})}),(0,i.jsx)(t.td,{children:"Float"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"real"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"f64"})}),(0,i.jsx)(t.td,{children:"Double"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"double precision"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"bool"})}),(0,i.jsx)(t.td,{children:"Boolean"}),(0,i.jsx)(t.td,{children:"boolean"}),(0,i.jsx)(t.td,{children:"bool"}),(0,i.jsx)(t.td,{children:"bool"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"Vec<u8>"})}),(0,i.jsx)(t.td,{children:"Binary"}),(0,i.jsx)(t.td,{children:"blob"}),(0,i.jsx)(t.td,{children:"blob"}),(0,i.jsx)(t.td,{children:"bytea"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["For the mappings of Rust non-primitive data types. You can check ",(0,i.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/entity/prelude.rs",children:(0,i.jsx)(t.code,{children:"entity/prelude.rs"})})," for all of the reexported types."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Rust type"}),(0,i.jsxs)(t.th,{children:["Database Type ",(0,i.jsx)("br",{})," (",(0,i.jsx)(t.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.25/sea_orm/entity/enum.ColumnType.html",children:(0,i.jsx)(t.code,{children:"ColumnType"})}),")"]}),(0,i.jsxs)(t.th,{children:["SQLite ",(0,i.jsx)("br",{})," datatype"]}),(0,i.jsxs)(t.th,{children:["MySQL ",(0,i.jsx)("br",{})," datatype"]}),(0,i.jsxs)(t.th,{children:["PostgreSQL ",(0,i.jsx)("br",{})," datatype"]})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"Date"}),": chrono::NaiveDate ",(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"TimeDate"}),": time::Date"]}),(0,i.jsx)(t.td,{children:"Date"}),(0,i.jsx)(t.td,{children:"date_text"}),(0,i.jsx)(t.td,{children:"date"}),(0,i.jsx)(t.td,{children:"date"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"Time"}),": chrono::NaiveTime ",(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"TimeTime"}),": time::Time"]}),(0,i.jsx)(t.td,{children:"Time"}),(0,i.jsx)(t.td,{children:"time_text"}),(0,i.jsx)(t.td,{children:"time"}),(0,i.jsx)(t.td,{children:"time"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"DateTime"}),": chrono::NaiveDateTime ",(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"TimeDateTime"}),": time::PrimitiveDateTime"]}),(0,i.jsx)(t.td,{children:"DateTime"}),(0,i.jsx)(t.td,{children:"datetime_text"}),(0,i.jsx)(t.td,{children:"datetime"}),(0,i.jsx)(t.td,{children:"timestamp"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"DateTimeLocal"}),": chrono::DateTime<Local> ",(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"DateTimeUtc"}),": chrono::DateTime<Utc>"]}),(0,i.jsx)(t.td,{children:"Timestamp"}),(0,i.jsx)(t.td,{children:"timestamp_text"}),(0,i.jsx)(t.td,{children:"timestamp"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"DateTimeWithTimeZone"}),": chrono::DateTime<FixedOffset> ",(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"TimeDateTimeWithTimeZone"}),": time::OffsetDateTime"]}),(0,i.jsx)(t.td,{children:"TimestampWithTimeZone"}),(0,i.jsx)(t.td,{children:"timestamp_with_timezone_text"}),(0,i.jsx)(t.td,{children:"timestamp"}),(0,i.jsx)(t.td,{children:"timestamp with time zone"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"Uuid"}),": uuid::Uuid, uuid::fmt::Braced, uuid::fmt::Hyphenated, uuid::fmt::Simple, uuid::fmt::Urn"]}),(0,i.jsx)(t.td,{children:"Uuid"}),(0,i.jsx)(t.td,{children:"uuid_text"}),(0,i.jsx)(t.td,{children:"binary(16)"}),(0,i.jsx)(t.td,{children:"uuid"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"Json"}),": serde_json::Value"]}),(0,i.jsx)(t.td,{children:"Json"}),(0,i.jsx)(t.td,{children:"json_text"}),(0,i.jsx)(t.td,{children:"json"}),(0,i.jsx)(t.td,{children:"json"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"Decimal"}),": rust_decimal::Decimal"]}),(0,i.jsx)(t.td,{children:"Decimal"}),(0,i.jsx)(t.td,{children:"real"}),(0,i.jsx)(t.td,{children:"decimal"}),(0,i.jsx)(t.td,{children:"decimal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"PgVector"}),": pgvector::Vector"]}),(0,i.jsx)(t.td,{children:"Vector"}),(0,i.jsx)(t.td,{children:"N/A"}),(0,i.jsx)(t.td,{children:"N/A"}),(0,i.jsx)(t.td,{children:"vector"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:[(0,i.jsx)(t.code,{children:"IpNetwork"}),": ipnetwork::IpNetwork"]}),(0,i.jsx)(t.td,{children:"Inet"}),(0,i.jsx)(t.td,{children:"N/A"}),(0,i.jsx)(t.td,{children:"N/A"}),(0,i.jsx)(t.td,{children:"inet"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["You can override the default mappings between a Rust type and ",(0,i.jsx)(t.code,{children:"ColumnType"})," with the ",(0,i.jsx)(t.code,{children:"column_type"})," attribute."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[sea_orm(column_type = "Text")]\npub name: String\n#[sea_orm(column_type = "Decimal(Some((16, 4)))")]\npub price: Decimal,\n'})}),"\n",(0,i.jsx)(t.h2,{id:"json-column",children:"JSON column"}),"\n",(0,i.jsxs)(t.p,{children:["If you need your JSON field to be deserialized into a struct. You would need to derive ",(0,i.jsx)(t.code,{children:"FromJsonQueryResult"})," for it."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_struct")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // JSON column as `serde_json::Value`\n    pub json: Json,\n    // JSON column as custom struct\n    pub json_value: KeyValue,\n    // nullable JSON column as custom struct, backed by jsonb (Postgres only)\n    #[sea_orm(column_type = "JsonBinary")]\n    pub json_value_opt: Option<KeyValue>,\n    // JSON column storing a vector of objects\n    pub json_value_vec: Vec<KeyValue>,\n}\n\n// The custom struct must derive `FromJsonQueryResult`, `Serialize` and `Deserialize`\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct KeyValue {\n    pub id: i32,\n    pub name: String,\n    pub price: f32,\n    pub notes: Option<String>,\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"If you want a cross-database way of implementing array column, you can wrap it with a wrapper type."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "json_string_vec")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // nullable JSON column storing a vector of string\n    pub str_vec: Option<StringVec>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct StringVec(pub Vec<String>);\n'})}),"\n",(0,i.jsx)(t.p,{children:"More details and examples in the next chapter."}),"\n",(0,i.jsx)(t.h2,{id:"postgres-array",children:"Postgres Array"}),"\n",(0,i.jsx)(t.p,{children:"Array datatype is a Postgres-only feature. You can define a vector of primitive types that is already supported by SeaORM."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "collection")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub integers: Vec<i32>,\n    pub integers_opt: Option<Vec<i32>>,\n    pub floats: Vec<f32>,\n    pub doubles: Vec<f64>,\n    pub strings: Vec<String>,\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"postgres-vector",children:"Postgres Vector"}),"\n",(0,i.jsxs)(t.p,{children:["Since ",(0,i.jsx)(t.code,{children:"1.1.6"}),", PgVector support is added. Requires ",(0,i.jsx)(t.code,{children:"postgres-vector"})," feature flag."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "image_model")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub id: i32,\n    pub embedding: PgVector,\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["For a complete example, see ",(0,i.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/tests/embedding_tests.rs",children:"embedding_tests"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"ipnetwork-postgres",children:"IpNetwork (Postgres)"}),"\n",(0,i.jsxs)(t.p,{children:["Since ",(0,i.jsx)(t.code,{children:"1.1.8"}),", IpNetwork support is added. Requires ",(0,i.jsx)(t.code,{children:"with-ipnetwork"})," feature flag."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "host_network")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub ipaddress: IpNetwork,\n    #[sea_orm(column_type = "Cidr")]\n    pub network: IpNetwork,\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"unix-timestamp",children:"Unix Timestamp"}),"\n",(0,i.jsxs)(t.p,{children:["Since ",(0,i.jsx)(t.code,{children:"2.0.0"}),", several new wrapper types are added to map chrono / time datetime as ",(0,i.jsx)(t.code,{children:"BigInteger"}),". These values are converted to ",(0,i.jsx)(t.code,{children:"i64"})," before sending to database."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "access_log")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub ts: ChronoUnixTimestamp,\n    pub ms: ChronoUnixTimestampMillis,\n    pub ts: TimeUnixTimestamp,\n    pub ms: TimeUnixTimestampMillis,\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);