"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[12038],{28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>i});var r=a(96540);const n={},o=r.createContext(n);function s(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(o.Provider,{value:t},e.children)}},47896:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"graph-ql/seaography-intro","title":"\ud83e\udded Seaography","description":"GraphQL has become the preferred interface for product teams. Both frontend and backend developers benefit from its type-safety, contractual guarantees, and composability. Yet the real challenge lies on the backend: implementing relational resolvers that can traverse complex schemas is often difficult and time-consuming.","source":"@site/docs/10-graph-ql/01-seaography-intro.md","sourceDirName":"10-graph-ql","slug":"/graph-ql/seaography-intro","permalink":"/preview/pr-154/SeaORM/docs/graph-ql/seaography-intro","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/10-graph-ql/01-seaography-intro.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1760952789000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Create Index","permalink":"/preview/pr-154/SeaORM/docs/schema-statement/create-index"},"next":{"title":"Getting Started","permalink":"/preview/pr-154/SeaORM/docs/graph-ql/getting-started"}}');var n=a(74848),o=a(28453);const s={},i="\ud83e\udded Seaography",l={},c=[];function h(e){const t={a:"a",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"-seaography",children:"\ud83e\udded Seaography"})}),"\n",(0,n.jsx)(t.p,{children:"GraphQL has become the preferred interface for product teams. Both frontend and backend developers benefit from its type-safety, contractual guarantees, and composability. Yet the real challenge lies on the backend: implementing relational resolvers that can traverse complex schemas is often difficult and time-consuming."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"})," is a GraphQL framework built on top of SeaORM and ",(0,n.jsx)(t.a,{href:"https://github.com/async-graphql/async-graphql",children:"async-graphql"}),". Given a set of SeaORM entities, you can instantly launch a fully-featured GraphQL server / resolver with relational query, filters, pagination and mutations."]}),"\n",(0,n.jsx)(t.p,{children:"In addition, Seaography is an extensible GraphQL framework allowing you grow it into a complex application backend:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Automatic GraphQL resolver generation with data loader integration to solve the N+1 problem"}),"\n",(0,n.jsx)(t.li,{children:"Extensive customization options and the ability to add custom endpoints easily"}),"\n",(0,n.jsx)(t.li,{children:"Authorization: Role-Based Access Control (RBAC) and fine-grained control with hooks / guards"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Learn more about the ",(0,n.jsx)(t.a,{href:"https://www.sea-ql.org/blog/2025-10-08-seaography/",children:"latest features of Seaography 2.0"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);