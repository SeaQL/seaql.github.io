"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[61476],{22098:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"relation/complex-relations","title":"Complex Relations","description":"Linked","source":"@site/docs/06-relation/04-complex-relations.md","sourceDirName":"06-relation","slug":"/relation/complex-relations","permalink":"/preview/pr-154/SeaORM/docs/relation/complex-relations","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/06-relation/04-complex-relations.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1760952789000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Many to Many","permalink":"/preview/pr-154/SeaORM/docs/relation/many-to-many"},"next":{"title":"Model Loader","permalink":"/preview/pr-154/SeaORM/docs/relation/model-loader"}}');var t=i(74848),a=i(28453);const r={},o="Complex Relations",s={},d=[{value:"Linked",id:"linked",level:2},{value:"Defining the Link",id:"defining-the-link",level:3},{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Eager Loading",id:"eager-loading",level:3},{value:"Self Referencing Relations",id:"self-referencing-relations",level:2},{value:"Querying model pairs",id:"querying-model-pairs",level:3},{value:"Diamond Relations",id:"diamond-relations",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"complex-relations",children:"Complex Relations"})}),"\n",(0,t.jsx)(n.h2,{id:"linked",children:"Linked"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Related"})," trait is a representation of the arrows (1-1, 1-N, M-N) we draw on Entity Relationship Diagrams. A ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.Linked.html",children:(0,t.jsx)(n.code,{children:"Linked"})})," is composed of a chain of relations, and is useful when:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["there exist multiple join paths between a pair of entities, making it impossible to impl ",(0,t.jsx)(n.code,{children:"Related"})]}),"\n",(0,t.jsx)(n.li,{children:"joining across multiple entities in a relational query"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Implementing ",(0,t.jsx)(n.code,{children:"Linked"})," trait is completely optional, as there are other ways of doing relational queries in SeaORM, which will be explained in later chapters.\nWith ",(0,t.jsx)(n.code,{children:"Linked"})," implemented, several ",(0,t.jsx)(n.code,{children:"find_*_linked"})," helper methods become available, and relationships can be defined in a single place."]}),"\n",(0,t.jsx)(n.h3,{id:"defining-the-link",children:"Defining the Link"}),"\n",(0,t.jsxs)(n.p,{children:["Take ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/src/tests_cfg/entity_linked.rs",children:"this"})," as an example, where we join cake and filling via an intermediate ",(0,t.jsx)(n.code,{children:"cake_filling"})," table."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="entity/links.rs"',children:"pub struct CakeToFilling;\n\nimpl Linked for CakeToFilling {\n    type FromEntity = cake::Entity;\n    type ToEntity = filling::Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![\n            cake_filling::Relation::Cake.def().rev(), // cake -> cake_filling\n            cake_filling::Relation::Filling.def(),    // cake_filling -> filling\n        ]\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,t.jsxs)(n.p,{children:["Find fillings that can be filled into a cake with the ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/trait.ModelTrait.html#method.find_linked",children:(0,t.jsx)(n.code,{children:"find_linked"})})," method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let cake_model = cake::Model {\n    id: 12,\n    name: "Chocolate".into(),\n};\n\nassert_eq!(\n    cake_model\n        .find_linked(cake::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `filling`.`id`, `filling`.`name`, `filling`.`vendor_id`",\n        "FROM `filling`",\n        "INNER JOIN `cake_filling` AS `r0` ON `r0`.`filling_id` = `filling`.`id`",\n        "INNER JOIN `cake` AS `r1` ON `r1`.`id` = `r0`.`cake_id`",\n        "WHERE `r1`.`id` = 12",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"eager-loading",children:"Eager Loading"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.Select.html#method.find_also_linked",children:(0,t.jsx)(n.code,{children:"find_also_linked"})})," is a dual of ",(0,t.jsx)(n.code,{children:"find_also_related"}),"; ",(0,t.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/prelude/struct.Select.html#method.find_with_linked",children:(0,t.jsx)(n.code,{children:"find_with_linked"})})," is a dual of ",(0,t.jsx)(n.code,{children:"find_with_related"}),"; :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::Entity::find()\n        .find_also_linked(links::CakeToFilling)\n        .build(DbBackend::MySql)\n        .to_string(),\n    [\n        "SELECT `cake`.`id` AS `A_id`, `cake`.`name` AS `A_name`,",\n        "`r1`.`id` AS `B_id`, `r1`.`name` AS `B_name`, `r1`.`vendor_id` AS `B_vendor_id`",\n        "FROM `cake`",\n        "LEFT JOIN `cake_filling` AS `r0` ON `cake`.`id` = `r0`.`cake_id`",\n        "LEFT JOIN `filling` AS `r1` ON `r0`.`filling_id` = `r1`.`id`",\n    ]\n    .join(" ")\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"self-referencing-relations",children:"Self Referencing Relations"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Link"})," trait can also define self referencing relations. The following example defines an Entity that references itself."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",metastring:'title="self_join.rs"',children:'use sea_orm::entity::prelude::*;\n\n#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "self_join")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub uuid: Uuid,\n    pub uuid_ref: Option<Uuid>,\n    pub time: Option<Time>,\n    #[sea_orm(self_ref, relation_enum = "SelfRef", from = "uuid_ref", to = "uuid")]\n    pub other: HasOne<Entity>,\n}\n\npub struct SelfReferencingLink;\n\nimpl Linked for SelfReferencingLink {\n    type FromEntity = Entity;\n    type ToEntity = Entity;\n\n    fn link(&self) -> Vec<RelationDef> {\n        vec![Relation::SelfRef.def()] // <- use the relation here\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"querying-model-pairs",children:"Querying model pairs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let models: Vec<(self_join::Model, Option<self_join::Model>)> = self_join::Entity::find()\n    .find_also_linked(self_join::SelfReferencingLink)\n    .order_by_asc(self_join::Column::Time)\n    .all(db)\n    .await?;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"diamond-relations",children:"Diamond Relations"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes there exist multiple relations between a pair of entities. Here we take the simplest example, where ",(0,t.jsx)(n.code,{children:"Cake"})," can have multiple ",(0,t.jsx)(n.code,{children:"Fruit"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "cake")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    pub topping_id: i32,\n    pub filling_id: i32,\n    #[sea_orm(belongs_to, relation_enum = "Topping", from = "topping_id", to = "id")]\n    pub topping: HasOne<super::fruit::Entity>,\n    #[sea_orm(belongs_to, relation_enum = "Filling", from = "filling_id", to = "id")]\n    pub filling: HasOne<super::fruit::Entity>,\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["How can we define the ",(0,t.jsx)(n.code,{children:"Fruit"})," Entity?\nBy default, ",(0,t.jsx)(n.code,{children:"has_many"})," invokes the ",(0,t.jsx)(n.code,{children:"Related"})," trait to define the relation.\nAs a consequence, we have to specify the ",(0,t.jsx)(n.code,{children:"Relation"})," variant of the related entity manually with the ",(0,t.jsx)(n.code,{children:"via_rel"})," attribute."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "fruit")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(has_many, relation_enum = "ToppingOf", via_rel = "Topping")]\n    pub topping_of: HasMany<super::cake::Entity>,\n    #[sea_orm(has_many, relation_enum = "FillingOf", via_rel = "Filling")]\n    pub filling_of: HasMany<super::cake::Entity>,\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then you can use the relations like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fruit::Entity::find().join(JoinType::LeftJoin, fruit::Relation::ToppingOf.def());\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var l=i(96540);const t={},a=l.createContext(t);function r(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);