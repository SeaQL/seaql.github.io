"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[57946],{28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var t=a(96540);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}},50094:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"generate-entity/enumeration","title":"ActiveEnum","description":"You can use Rust enums in model where the values are mapped to a database string, integer or native enum.","source":"@site/docs/04-generate-entity/04-enumeration.md","sourceDirName":"04-generate-entity","slug":"/generate-entity/enumeration","permalink":"/preview/pr-154/SeaORM/docs/generate-entity/enumeration","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/04-generate-entity/04-enumeration.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1760688811000,"sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Column Types","permalink":"/preview/pr-154/SeaORM/docs/generate-entity/column-types"},"next":{"title":"New Type","permalink":"/preview/pr-154/SeaORM/docs/generate-entity/newtype"}}');var r=a(74848),s=a(28453);const i={},l="ActiveEnum",o={},c=[{value:"String",id:"string",level:2},{value:"Simple enum strings",id:"simple-enum-strings",level:3},{value:"Integers",id:"integers",level:2},{value:"Native Database Enum",id:"native-database-enum",level:2},{value:"MySQL",id:"mysql",level:2},{value:"Postgres",id:"postgres",level:2},{value:"1. <code>TYPE</code> statement",id:"1-type-statement",level:3},{value:"2. <code>create_enum_from_active_enum</code>",id:"2-create_enum_from_active_enum",level:3},{value:"Trait impl",id:"trait-impl",level:2},{value:"Using ActiveEnum on Model",id:"using-activeenum-on-model",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components},{Details:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"activeenum",children:"ActiveEnum"})}),"\n",(0,r.jsx)(n.p,{children:"You can use Rust enums in model where the values are mapped to a database string, integer or native enum."}),"\n",(0,r.jsx)(n.h2,{id:"string",children:"String"}),"\n",(0,r.jsxs)(n.p,{children:["For string enums, in addition to being able to specify the string value for each variant, you can also specify the ",(0,r.jsx)(n.code,{children:"rename_all"})," attribute on the Enum if all the values should have string values based on case-transformations."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "String", db_type = "String(StringLen::None)", rename_all = "camelCase")]\npub enum Category {\n    BigTask,\n    SmallWork,\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The above is equivalent to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "String", db_type = "String(StringLen::None)")]\npub enum Category {\n    #[sea_orm(string_value = "bigTask")]\n    BigTask,\n    #[sea_orm(string_value = "smallBreak")]\n    SmallWork,\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Which specify the string values manually with ",(0,r.jsx)(n.code,{children:"string_value"}),"."]}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsxs)("summary",{children:["You can find a list of valid values for the ",(0,r.jsx)(n.code,{children:"rename_all"})," attribute here:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"camelCase"}),"\n",(0,r.jsx)(n.li,{children:"kebab-case"}),"\n",(0,r.jsx)(n.li,{children:"mixed_case"}),"\n",(0,r.jsx)(n.li,{children:"SCREAMING_SNAKE_CASE"}),"\n",(0,r.jsx)(n.li,{children:"snake_case"}),"\n",(0,r.jsx)(n.li,{children:"title_case"}),"\n",(0,r.jsx)(n.li,{children:"UPPERCASE"}),"\n",(0,r.jsx)(n.li,{children:"lowercase"}),"\n",(0,r.jsx)(n.li,{children:"SCREAMING-KEBAB-CASE"}),"\n",(0,r.jsx)(n.li,{children:"PascalCase"}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"simple-enum-strings",children:"Simple enum strings"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"DeriveValueType"})," added support for enums. It offers a simpler alternative to ",(0,r.jsx)(n.code,{children:"DeriveActiveEnum"})," for client-side enums backed by string database types.\nYou have to provide custom ",(0,r.jsx)(n.code,{children:"from_str"})," and ",(0,r.jsx)(n.code,{children:"to_str"})," implementations."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(DeriveValueType)]\n#[sea_orm(value_type = "String")]\npub enum Category {\n    BigTask,\n    SmallWork,\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Read the next chapter for more details."}),"\n",(0,r.jsx)(n.h2,{id:"integers",children:"Integers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "i32", db_type = "Integer")]\npub enum Color {\n    #[sea_orm(num_value = 0)]\n    Black,\n    #[sea_orm(num_value = 1)]\n    White,\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, you could write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "i32", db_type = "Integer")]\npub enum Color {\n    Black = 0,\n    White = 1,\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"native-database-enum",children:"Native Database Enum"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "tea")]\npub enum Tea {\n    #[sea_orm(string_value = "EverydayTea")]\n    EverydayTea,\n    #[sea_orm(string_value = "BreakfastTea")]\n    BreakfastTea,\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"mysql",children:"MySQL"}),"\n",(0,r.jsx)(n.p,{children:"MySQL enum is just part of the column definition, and cannot be reused for different tables."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'Table::create()\n    .table(Posts::TableName)\n    .col(ColumnDef::new(Posts::ColumnName)\n            .enumeration("tea", ["EverydayTea", "BreakfastTea"]))\n\n"CREATE TABLE `table_name` (`column_name` ENUM(\'EverydayTea\', \'BreakfastTea\'))",\n'})}),"\n",(0,r.jsx)(n.h2,{id:"postgres",children:"Postgres"}),"\n",(0,r.jsxs)(n.p,{children:["If you are using Postgres, the enum has to be created in a separate ",(0,r.jsx)(n.code,{children:"Type"})," statement in a migration, you can create it with:"]}),"\n",(0,r.jsxs)(n.h3,{id:"1-type-statement",children:["1. ",(0,r.jsx)(n.code,{children:"TYPE"})," statement"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/sea-orm-migration/tests/common/migration/m20220118_000004_create_tea_enum.rs",children:"Full example"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// run this in migration:\n\nmanager\n    .create_type(\n        // CREATE TYPE "tea" AS ENUM (\'EverydayTea\', \'BreakfastTea\')\n        Type::create()\n            .as_enum("tea")\n            .values(["EverydayTea", "BreakfastTea"])\n            .to_owned(),\n    )\n    .await?;\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"2-create_enum_from_active_enum",children:["2. ",(0,r.jsx)(n.code,{children:"create_enum_from_active_enum"})]}),"\n",(0,r.jsx)(n.p,{children:"This method will provide an interface for adding the type to the database, using the type for table columns, and adding values of this type to rows when seeding data."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Define an ",(0,r.jsx)(n.code,{children:"ActiveEnum"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "tea_type")]\npub enum TeaType {\n    #[sea_orm(string_value = "EverydayTea")]\n    EverydayTea,\n    #[sea_orm(string_value = "BreakfastTea")]\n    BreakfastTea,\n}\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Create the type in the database"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use sea_orm::{Schema, DbBackend};\n\n// in a migration:\nlet schema = Schema::new(DbBackend::Postgres);\n\nmanager\n    .create_type(\n        // CREATE TYPE \"tea_type\" AS ENUM ('EverydayTea', 'BreakfastTea')\n        schema.create_enum_from_active_enum::<TeaType>(),\n    )\n    .await?;\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"Use the type as a table column type when creating a table"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"diff",children:"// in a migration:\n\nmanager::create()\n    .table(Tea::Table)\n    .if_not_exists()\n    .col(Column::new(Tea::Type).custom(TeaType::name())) // use the type for a table column \n    // ... more columns\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["see also ",(0,r.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM/docs/migration/writing-migration/#schema-creation-methods",children:"Schema Creation Methods - Create Table"})]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsx)(n.li,{children:"Use the type when populating the database"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// in a migration\n\nlet insert = Query::insert()\n    .into_table(Tea::Table)\n    .columns([Tea::TeaType])\n    .values_panic([TeaType::EverydayTea.as_enum()]) // call `as_enum` to convert the variant into a SimpleExpr\n    .to_owned();\n\nmanager.execute(insert).await?;\n// ...\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["see also ",(0,r.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM/docs/migration/seeding-data/#:~:text=write%20SeaQuery%20statement%20to%20seed%20the%20table",children:"Seeding Data - with sea_query statement"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"trait-impl",children:"Trait impl"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/derive.DeriveActiveEnum.html",children:(0,r.jsx)(n.code,{children:"DeriveActiveEnum"})})," macro implements the ",(0,r.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/entity/trait.ActiveEnum.html",children:(0,r.jsx)(n.code,{children:"ActiveEnum"})})," trait under the hood."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Debug, PartialEq, Eq, EnumIter, DeriveActiveEnum)]\n#[sea_orm(\n    rs_type = "String",\n    db_type = "String(StringLen::N(1))",\n    enum_name = "category"\n)]\npub enum Category {\n    #[sea_orm(string_value = "B")]\n    Big,\n    #[sea_orm(string_value = "S")]\n    Small,\n}\n'})}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsx)("summary",{children:"For illustration purpose, this is roughly what the macro implements:"}),(0,r.jsx)("div",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n#[derive(Debug, PartialEq, Eq, EnumIter)]\npub enum Category {\n    Big,\n    Small,\n}\n\n// Implementing manually\nimpl ActiveEnum for Category {\n    // The macro attribute `rs_type` is being pasted here\n    type Value = String;\n\n    // By default, the name of Rust enum in camel case if `enum_name` was not provided explicitly\n    fn name() -> String {\n        "category".to_owned()\n    }\n\n    // Map Rust enum variants to corresponding `num_value` or `string_value`\n    fn to_value(&self) -> Self::Value {\n        match self {\n            Self::Big => "B",\n            Self::Small => "S",\n        }\n        .to_owned()\n    }\n\n    // Map `num_value` or `string_value` to corresponding Rust enum variants\n    fn try_from_value(v: &Self::Value) -> Result<Self, DbErr> {\n        match v.as_ref() {\n            "B" => Ok(Self::Big),\n            "S" => Ok(Self::Small),\n            _ => Err(DbErr::Type(format!(\n                "unexpected value for Category enum: {}",\n                v\n            ))),\n        }\n    }\n\n    // The macro attribute `db_type` is being pasted here\n    fn db_type() -> ColumnDef {\n        ColumnType::String(Some(1)).def()\n    }\n}\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"using-activeenum-on-model",children:"Using ActiveEnum on Model"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use sea_orm::entity::prelude::*;\n\n// Define the `Category` active enum\n#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = "String", db_type = "String(StringLen::N(1))")]\npub enum Category {\n    #[sea_orm(string_value = "B")]\n    Big,\n    #[sea_orm(string_value = "S")]\n    Small,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "active_enum")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // Represents a db column using `Category` active enum\n    pub category: Category,\n    pub category_opt: Option<Category>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);