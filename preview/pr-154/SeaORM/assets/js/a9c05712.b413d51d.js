"use strict";(self.webpackChunksea_orm=self.webpackChunksea_orm||[]).push([[67397],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}},68010:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"write-test/sqlite","title":"Using SQLite","description":"If you want to test high level application domain logic that\'s not tied to database specific features, you can use SQLite in integration tests.","source":"@site/docs/07-write-test/03-sqlite.md","sourceDirName":"07-write-test","slug":"/write-test/sqlite","permalink":"/preview/pr-154/SeaORM/docs/write-test/sqlite","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaORM/docs/07-write-test/03-sqlite.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1760952789000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Mock Interface","permalink":"/preview/pr-154/SeaORM/docs/write-test/mock"},"next":{"title":"Custom Select","permalink":"/preview/pr-154/SeaORM/docs/advanced-query/custom-select"}}');var a=n(74848),i=n(28453);const r={},o="Using SQLite",c={},l=[{value:"Integration Test",id:"integration-test",level:2},{value:"Setup database schema",id:"setup-database-schema",level:2},{value:"Performing tests",id:"performing-tests",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"using-sqlite",children:"Using SQLite"})}),"\n",(0,a.jsx)(t.p,{children:"If you want to test high level application domain logic that's not tied to database specific features, you can use SQLite in integration tests."}),"\n",(0,a.jsx)(t.p,{children:"Of course, it is not a substitute to integration testing against the target database, but a supplement: SQLite runs in memory, and is quick to run and easy to write tests. You don't have to setup Docker container for executing them, so you can have more comprehensive tests on every layer of the application."}),"\n",(0,a.jsxs)(t.p,{children:["Check out a simple example ",(0,a.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/tests/basic.rs",children:"here"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"integration-test",children:"Integration Test"}),"\n",(0,a.jsxs)(t.p,{children:["It is recommended to execute more complex test cases in ",(0,a.jsx)(t.a,{href:"https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html",children:"integration tests"}),". The following code snippet illustrates the steps of connecting to a database, setting up schema and performing tests."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'async fn main() -> Result<(), DbErr> {\n    // Connecting SQLite\n    let db = Database::connect("sqlite::memory:").await?;\n\n    // Setup database schema\n    setup_schema(&db).await?;\n\n    // Performing tests\n    testcase(&db).await?;\n\n    Ok(())\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"setup-database-schema",children:"Setup database schema"}),"\n",(0,a.jsxs)(t.p,{children:["To create tables in SQLite database for testing, instead of writing ",(0,a.jsx)(t.a,{href:"https://docs.rs/sea-query/*/sea_query/table/struct.TableCreateStatement.html",children:(0,a.jsx)(t.code,{children:"TableCreateStatement"})})," manually, you can construct a complex schema using ",(0,a.jsx)(t.a,{href:"https://docs.rs/sea-orm/2.0.0-rc.11/sea_orm/schema/struct.SchemaBuilder.html",children:(0,a.jsx)(t.code,{children:"SchemaBuilder"})}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"async fn setup_schema(db: &DbConn) -> Result<()> {\n\n    // it doesn't matter which order you register entities.\n    // SeaORM figures out the foreign key dependencies and\n    // creates the tables in the right order along with foreign keys\n    db.get_schema_builder()\n        .register(cake::Entity)\n        .register(cake_filling::Entity)\n        .register(filling::Entity)\n        .apply(db)\n        .await?;\n\n    // or, write DDL manually\n    db.execute(\n        Table::create()\n            .table(cake::Entity)\n            .col(pk_auto(cake::Column::Id))\n            .col(string(cake::Column::Name))\n        ).await?;\n\n    Ok(())\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"performing-tests",children:"Performing tests"}),"\n",(0,a.jsx)(t.p,{children:"Execute test cases and assert against the results. Here is a simple function that demonstrates the whole setup neatly:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'#[tokio::test]\nasync fn main() {\n    // create in memory database\n    let db = &Database::connect("sqlite::memory:").await.unwrap();\n\n    // setup schema\n    db.execute(\n        &Schema::new(db.get_database_backend())\n            .create_table_from_entity(post::Entity)\n    )\n    .await\n    .unwrap();\n\n    // this is your application request handler\n    let post = Mutation::create_post(\n        db,\n        post::Model {\n            id: 0,\n            title: "Title A".to_owned(),\n            text: "Text A".to_owned(),\n        },\n    )\n    .await\n    .unwrap();\n\n    assert_eq!(\n        post,\n        post::ActiveModel {\n            id: sea_orm::ActiveValue::Unchanged(1),\n            title: sea_orm::ActiveValue::Unchanged("Title A".to_owned()),\n            text: sea_orm::ActiveValue::Unchanged("Text A".to_owned())\n        }\n    );\n\n    let post = Mutation::create_post(\n        db,\n        post::Model {\n            id: 0,\n            title: "Title B".to_owned(),\n            text: "Text B".to_owned(),\n        },\n    )\n    .await\n    .unwrap();\n\n    assert_eq!(\n        post,\n        post::ActiveModel {\n            id: sea_orm::ActiveValue::Unchanged(2),\n            title: sea_orm::ActiveValue::Unchanged("Title B".to_owned()),\n            text: sea_orm::ActiveValue::Unchanged("Text B".to_owned())\n        }\n    );\n\n    let post = Query::find_post_by_id(db, 1).await.unwrap().unwrap();\n\n    assert_eq!(post.id, 1);\n    assert_eq!(post.title, "Title A");\n\n    let post = Mutation::update_post_by_id(\n        db,\n        1,\n        post::Model {\n            id: 1,\n            title: "New Title A".to_owned(),\n            text: "New Text A".to_owned(),\n        },\n    )\n    .await\n    .unwrap();\n\n    assert_eq!(\n        post,\n        post::Model {\n            id: 1,\n            title: "New Title A".to_owned(),\n            text: "New Text A".to_owned(),\n        }\n    );\n\n    let result = Mutation::delete_post(db, 2).await.unwrap();\n    assert_eq!(result.rows_affected, 1);\n\n    let post = Query::find_post_by_id(db, 2).await.unwrap();\n    assert!(post.is_none());\n\n    let result = Mutation::delete_all_posts(db).await.unwrap();\n    assert_eq!(result.rows_affected, 1);\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Here ",(0,a.jsx)(t.code,{children:"unwrap"})," is used, because in case the test fails, it tells you exactly where."]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);