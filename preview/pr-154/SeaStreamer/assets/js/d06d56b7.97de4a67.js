"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[6013],{6484:(e,r,s)=>{s.d(r,{R:()=>o,x:()=>i});var n=s(2374);const t={},a=n.createContext(t);function o(e){const r=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(a.Provider,{value:r},e.children)}},9304:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"introduction/sea-streamer","title":"SeaStreamer Concepts","description":"Streamer","source":"@site/versioned_docs/version-0.1.x/01-introduction/03-sea-streamer.md","sourceDirName":"01-introduction","slug":"/introduction/sea-streamer","permalink":"/preview/pr-154/SeaStreamer/docs/0.1.x/introduction/sea-streamer","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.1.x/01-introduction/03-sea-streamer.md","tags":[],"version":"0.1.x","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1761297220000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Async Programming in Rust","permalink":"/preview/pr-154/SeaStreamer/docs/0.1.x/introduction/async-programming"},"next":{"title":"Example Processors","permalink":"/preview/pr-154/SeaStreamer/docs/0.1.x/introduction/examples"}}');var t=s(8790),a=s(6484);const o={},i="SeaStreamer Concepts",c={},d=[{value:"Streamer",id:"streamer",level:2},{value:"Cluster",id:"cluster",level:3},{value:"Stream",id:"stream",level:2},{value:"Stream URL",id:"stream-url",level:3},{value:"Consumer",id:"consumer",level:2},{value:"Consumer Mode",id:"consumer-mode",level:3},{value:"Producer",id:"producer",level:2},{value:"Processor",id:"processor",level:2},{value:"Stream Semantics",id:"stream-semantics",level:2}];function m(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"seastreamer-concepts",children:"SeaStreamer Concepts"})}),"\n",(0,t.jsx)(r.h2,{id:"streamer",children:"Streamer"}),"\n",(0,t.jsx)(r.p,{children:"The streaming server. It is identified by an URI where all producers and consumers can connect to."}),"\n",(0,t.jsx)(r.h3,{id:"cluster",children:"Cluster"}),"\n",(0,t.jsx)(r.p,{children:"The streaming server is assumed to be a cluster: it can scale horizontally across multiple nodes."}),"\n",(0,t.jsx)(r.h2,{id:"stream",children:"Stream"}),"\n",(0,t.jsxs)(r.p,{children:["A stream consists of a series of messages sharing the same key (known as ",(0,t.jsx)(r.code,{children:"topic"})," in Kafka). Each message has a timestamp, sequence number (known as ",(0,t.jsx)(r.code,{children:"offset"})," in Kafka), shard id (known as ",(0,t.jsx)(r.code,{children:"partition number"})," in Kafka), and payload. A message is uniquely identified by the (stream key, shard id, sequence number) tuple."]}),"\n",(0,t.jsx)(r.h3,{id:"stream-url",children:"Stream URL"}),"\n",(0,t.jsxs)(r.p,{children:["In SeaStreamer streams are resources, and can be accessed through a URL comprising (protocol, host, stream). An example stream URL is ",(0,t.jsx)(r.code,{children:"kafka://streamer.sea-ql.org:12345/my_stream"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"consumer",children:"Consumer"}),"\n",(0,t.jsx)(r.p,{children:"A stream consumer subscribes to one or more streams and receive messages from one or more nodes in the cluster."}),"\n",(0,t.jsx)(r.p,{children:"A consumer can rewind a stream to any point (addressed by timestamp or sequence number) and continue streaming."}),"\n",(0,t.jsx)(r.h3,{id:"consumer-mode",children:"Consumer Mode"}),"\n",(0,t.jsx)(r.p,{children:"There are two consuming modes:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Real-time: we only care about the latest messages and would be okay to miss old data"}),"\n",(0,t.jsx)(r.li,{children:"Resumable: when the consumer resubscribes, it will resume from the last consumed message"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"producer",children:"Producer"}),"\n",(0,t.jsx)(r.p,{children:"A stream producer send messages to a streaming server, where the server would store the messages within the cluster, and deliver them to clients."}),"\n",(0,t.jsx)(r.p,{children:"A producer can send a message with any stream key, but in SeaStreamer we recommend you to anchor each producer to a particular stream key."}),"\n",(0,t.jsx)(r.h2,{id:"processor",children:"Processor"}),"\n",(0,t.jsx)(r.p,{children:"A stream processor is a consumer and producer at the same time. It consumes messages, transforms them and produces another stream."}),"\n",(0,t.jsx)(r.p,{children:"SeaStreamer aims to make it easy and flexible to develop and operate stream processors."}),"\n",(0,t.jsx)(r.h2,{id:"stream-semantics",children:"Stream Semantics"}),"\n",(0,t.jsx)(r.p,{children:"Advanced concepts, like sharding, load-balancing and transactions are backend-specific and you should read the relevant documentation of the streaming backend."})]})}function l(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);