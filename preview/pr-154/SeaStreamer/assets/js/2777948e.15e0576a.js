"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[110],{5482:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"processors/intra-process","title":"Intra Process","description":"Here is how you might organize a mid-to-large scale stream processing project. You have a number of crates implementing different processors, each depends on sea-streamer in a workspace. Now, you want to construct a downstream crate where you connect several processors together for testing.","source":"@site/versioned_docs/version-0.3.x/04-processors/02-intra-process.md","sourceDirName":"04-processors","slug":"/processors/intra-process","permalink":"/preview/pr-154/SeaStreamer/docs/processors/intra-process","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.3.x/04-processors/02-intra-process.md","tags":[],"version":"0.3.x","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1761297220000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Inter Process","permalink":"/preview/pr-154/SeaStreamer/docs/processors/inter-process"},"next":{"title":"The Roadmap","permalink":"/preview/pr-154/SeaStreamer/docs/whats-next/roadmap"}}');var o=s(8790),n=s(6484);const a={},i="Intra Process",c={},l=[{value:"Stdio",id:"stdio",level:2},{value:"File",id:"file",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"intra-process",children:"Intra Process"})}),"\n",(0,o.jsxs)(t.p,{children:["Here is how you might organize a mid-to-large scale stream processing project. You have a number of crates implementing different processors, each depends on ",(0,o.jsx)(t.code,{children:"sea-streamer"})," in a workspace. Now, you want to construct a downstream crate where you connect several processors together for testing."]}),"\n",(0,o.jsx)(t.h2,{id:"stdio",children:"Stdio"}),"\n",(0,o.jsxs)(t.p,{children:["You can execute tests involving several processors by setting Stdio's ",(0,o.jsx)(t.a,{href:"https://docs.rs/sea-streamer-stdio/*/sea_streamer_stdio/struct.StdioConnectOptions.html#method.set_loopback",children:"loopback"})," option, where messages produced will be feed back to consumers in the same process."]}),"\n",(0,o.jsxs)(t.p,{children:["It's just ",(0,o.jsx)(t.code,{children:"cargo test"})," without any external dependency or side effects, so it's extremely quick to execute. Use a unique stream key for each test case. So if the tests fail, you will be able to diagnose the problem from the stdout log. You can check out the ",(0,o.jsx)(t.a,{href:"https://github.com/SeaQL/sea-streamer/blob/main/sea-streamer-stdio/tests/loopback.rs",children:"full example"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:'let stream = StreamKey::new("hello")?;\nlet mut options = StdioConnectOptions::default();\noptions.set_loopback(true);\nlet streamer = StdioStreamer::connect(StreamerUri::zero(), options).await?;\nlet producer = streamer.create_producer(stream.clone(), Default::default()).await?;\nlet mut consumer = streamer.create_consumer(&[stream.clone()], Default::default()).await?;\n\nfor i in 0..5 {\n    let mess = format!("{}", i);\n    producer.send(mess)?;\n}\n\nlet seq = collect(&mut consumer, 5).await;\nassert_eq!(seq, [0, 1, 2, 3, 4]);\n'})}),"\n",(0,o.jsx)(t.h2,{id:"file",children:"File"}),"\n",(0,o.jsx)(t.p,{children:"You can produce-to and consume-from the same file with the File backend. You'd want to use a random file name to avoid interference with other processes."}),"\n",(0,o.jsx)(t.p,{children:"The File backend is just a thin abstraction layer over tokio / async-std's async File IO. There is no network protocol involved, so it's as raw as it can be in terms of throughput."}),"\n",(0,o.jsxs)(t.p,{children:["Check out the ",(0,o.jsx)(t.a,{href:"https://github.com/SeaQL/sea-streamer/blob/main/sea-streamer-file/tests/producer.rs",children:"full example"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:'use sea_streamer_file::FileId;\nuse sea_streamer_types::Timestamp;\nuse std::fs::OpenOptions;\n\npub fn temp_file(name: &str) -> Result<FileId, std::io::Error> {\n    let path = format!("/tmp/{name}");\n    let _file = OpenOptions::new()\n        .read(true)\n        .write(true) // Make sure we have write permission\n        .create_new(true) // Fail if this file already exists\n        .open(&path)?;\n\n    Ok(FileId::new(path))\n}\n'})})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},6484:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>i});var r=s(2374);const o={},n=r.createContext(o);function a(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);