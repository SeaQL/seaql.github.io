"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[3753],{2282:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-154/blog/2025-10-08-seaography","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-10-08-seaography.md","source":"@site/blog/2025-10-08-seaography.md","title":"Seaography 2.0: A Powerful and Extensible GraphQL Framework","description":"GraphQL has become the preferred interface for product teams. Both frontend and backend developers benefit from its type-safety, contractual guarantees, and composability. Yet the real challenge lies on the backend: implementing relational resolvers that can traverse complex schemas is often difficult and time-consuming.","date":"2025-10-08T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-154/blog/tags/news"}],"readingTime":10.83,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-10-08-seaography","title":"Seaography 2.0: A Powerful and Extensible GraphQL Framework","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/Seaography%202.0%20Banner.png","tags":["news"]},"unlisted":false,"prevItem":{"title":"SeaORM 2.0: new entity format and relational capabilities","permalink":"/preview/pr-154/blog/2025-10-20-sea-orm-2.0"},"nextItem":{"title":"Role Based Access Control in SeaORM 2.0","permalink":"/preview/pr-154/blog/2025-09-30-sea-orm-rbac"}}')},3994:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var s=t(2282),a=t(4848),i=t(8453);const r={slug:"2025-10-08-seaography",title:"Seaography 2.0: A Powerful and Extensible GraphQL Framework",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/Seaography%202.0%20Banner.png",tags:["news"]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"\ud83e\udded What is Seaography",id:"-what-is-seaography",level:2},{value:"What kinds of queries are supported?",id:"what-kinds-of-queries-are-supported",level:3},{value:"Filter, Ordering and Pagination",id:"filter-ordering-and-pagination",level:4},{value:"Nested Relational Query",id:"nested-relational-query",level:4},{value:"Mutations: create, update, delete",id:"mutations-create-update-delete",level:4},{value:"Custom Query",id:"custom-query",level:2},{value:"Custom Query with pagination",id:"custom-query-with-pagination",level:3},{value:"How does it work?",id:"how-does-it-work",level:2},{value:"Custom Mutation",id:"custom-mutation",level:2},{value:"Custom methods and unions",id:"custom-methods-and-unions",level:3},{value:"Lifecycle hooks",id:"lifecycle-hooks",level:2},{value:"Fine\u2011grained Access Control",id:"finegrained-access-control",level:3},{value:"Other hooks",id:"other-hooks",level:3},{value:"\ud83d\udda5\ufe0f SeaORM Pro: A Seaography Showcase",id:"\ufe0f-seaorm-pro-a-seaography-showcase",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Sponsors",id:"sponsors",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{alt:"Seaography 2.0 Banner",src:"/blog/img/Seaography%202.0%20Banner.png"}),"\n",(0,a.jsx)(n.p,{children:"GraphQL has become the preferred interface for product teams. Both frontend and backend developers benefit from its type-safety, contractual guarantees, and composability. Yet the real challenge lies on the backend: implementing relational resolvers that can traverse complex schemas is often difficult and time-consuming."}),"\n",(0,a.jsx)(n.p,{children:"Yes, there are libraries that can spin up a GraphQL resolver quickly, but they often come with trade-offs: they're hard to customize, making it painful to add additional endpoints when your application grows beyond the basics."}),"\n",(0,a.jsxs)(n.p,{children:["The hardest challenge is customization. Real-world applications demand fine-grained permissions and context-dependent business logic. ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"})," is designed to solve this exact problem, offering:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automatic GraphQL resolver generation with data loader integration to solve the N+1 problem"}),"\n",(0,a.jsx)(n.li,{children:"Extensive customization options and the ability to add custom endpoints easily"}),"\n",(0,a.jsx)(n.li,{children:"Authorization: Role-Based Access Control (RBAC) and fine-grained control with hooks / guards"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"-what-is-seaography",children:"\ud83e\udded What is Seaography"}),"\n",(0,a.jsx)(n.p,{children:"A video is worth a thousand words, so let's look at a quick demo."}),"\n",(0,a.jsxs)("video",{width:"100%",autoplay:!0,muted:!0,playsInline:!0,controls:!0,children:[(0,a.jsx)("source",{src:"/blog/img/Seaography%20Demo.mp4",type:"video/mp4"}),(0,a.jsx)(n.p,{children:"Your browser does not support the video tag."})]}),"\n",(0,a.jsx)(n.p,{children:"In under a minute, we've done the following:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Generate SeaORM entities from an existing sakila database (SQLite in demo)"}),"\n",(0,a.jsx)(n.li,{children:"Generate a GraphQL web server around the entities (supports Axum, Actix, Poem)"}),"\n",(0,a.jsx)(n.li,{children:"Launch it and run some queries with GraphQL playground"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This is of course a speed run, but you can follow the ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/seaography#quick-start---ready-to-serve-in-3-minutes",children:"same steps"})," easily, and the generated framework is fully customizable."]}),"\n",(0,a.jsx)(n.h3,{id:"what-kinds-of-queries-are-supported",children:"What kinds of queries are supported?"}),"\n",(0,a.jsx)(n.h4,{id:"filter-ordering-and-pagination",children:"Filter, Ordering and Pagination"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  film(\n    filters: {\n      title: { contains: "sea" } # \u2b05 like \'%sea%\'\n      and: [{ releaseYear: { gt: "2000" } }, { length: { gt: 120 } }]\n      # \u2b06 composable attribute filters\n    }\n    orderBy: { filmId: ASC }\n    pagination: { page: { page: 0, limit: 10 } }\n    # \u2b06 cursor based pagination is also supported:\n    #    pagination: { cursor: { limit: 10, cursor: "Int[3]:100" } }\n  ) {\n    nodes {\n      filmId\n      title\n      description\n    }\n    paginationInfo {\n      pages\n      current\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"nested-relational-query",children:"Nested Relational Query"}),"\n",(0,a.jsx)(n.p,{children:'The following query finds us all the documentaries starred by the actor "David" along with the stores having it in stock so that we can go rent it.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'{\n  film(\n    # \u2b07 filter by related entity\n    having: { # \u2b05 where exists (..) AND (..)\n      actor: { firstName: { eq: "David" } }\n      category: { name: { eq: "Documentary" } }\n    }\n  ) {\n    nodes {\n      filmId\n      title\n      # \u2b07 skipped the film_actor junction\n      actor {\n        nodes {\n          firstName\n          lastName\n        }\n      }\n      # \u2b07 nested relational query\n      inventory {\n        nodes {\n          store {\n            address {\n              address\n              city {\n                city\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"There are two join paths in this query:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"film -> film_actor -> actor\n     -> inventory -> store -> address -> city\n"})}),"\n",(0,a.jsx)(n.p,{children:"A data loader is used for resolving the relations, such that it does not suffers from the N+1 problem."}),"\n",(0,a.jsx)(n.h4,{id:"mutations-create-update-delete",children:"Mutations: create, update, delete"}),"\n",(0,a.jsxs)(n.p,{children:["Full CRUD is supported, including ",(0,a.jsx)(n.code,{children:"CreateOne"})," ",(0,a.jsx)(n.code,{children:"CreateBatch"})," ",(0,a.jsx)(n.code,{children:"Update"})," and ",(0,a.jsx)(n.code,{children:"Delete"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'mutation {\n  # \u2b07 operations will be executed inside a transaction\n  filmTextCreateBatch(\n    data: [\n      { filmId: 1, title: "Foo bar", description: "Lorem ipsum dolor sit amet" }\n      { filmId: 2, title: "Fizz buzz", description: "Consectetur adipiscing elit" }\n    ]\n    ) {\n      filmId\n      title\n      description\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"custom-query",children:"Custom Query"}),"\n",(0,a.jsxs)(n.p,{children:["The above is not something entirely new, as some features already exist in ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2024-07-01-graphql-support-with-loco-seaography/",children:"Seaography 1.0"}),". The real game-changer is how you can implement custom endpoints and mix-and-match them with SeaORM entities. Let's dive into it!"]}),"\n",(0,a.jsx)(n.h3,{id:"custom-query-with-pagination",children:"Custom Query with pagination"}),"\n",(0,a.jsx)(n.p,{children:"Seaography 2.0 introduced a set of macros to allow you to write custom query endpoints by reusing facilities in Seaography."}),"\n",(0,a.jsx)(n.p,{children:"Let's say we have a Customer entity:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'//! This is an entity from the sakila schema, generated by sea-orm-cli\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "customer")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub customer_id: i32,\n    pub store_id: i32,\n    pub first_name: String,\n    pub last_name: String,\n    ..\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"We want to create a custom endpoint, like the one Seaography already provides, but with an additional requirement: only return customers of the current store from which the user makes request from."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use seaography::{apply_pagination, Connection, CustomFields, PaginationInput};\n\npub struct Operations;\n\n#[CustomFields]\nimpl Operations {\n    async fn customer_of_current_store(\n        ctx: &Context<'_>,\n        pagination: PaginationInput,\n        //          \u2b06 this input struct is provided by Seaography\n    ) -> async_graphql::Result<Connection<customer::Entity>> {\n        //  this output struct \u2b06 is provided by Seaography\n        let db = ctx.data::<DatabaseConnection>()?;\n        //  \u2b06 this is a normal SeaORM db connection\n        let session = ctx.data::<Session>()?;\n        //  \u2b06 this session is inject by the HTTP handler\n        let query = customer::Entity::find()\n        //          \u2b06 this is the same old SeaORM API\n            .filter(customer::Column::StoreId.eq(session.store_id));\n        //  \u2b06 here we implement our custom logic\n        // note that here, we haven't execute the query yet ..\n        // instead, we pass it to Seaography to handle the rest!\n        let connection = apply_pagination(&CONTEXT, db, query, pagination).await?;\n        //                                         now the query executes \u2b06 \n\n        Ok(connection)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This would expose the following query endpoint:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"customer_of_current_store(\n  pagination: PaginationInput\n): CustomerConnection!\n"})}),"\n",(0,a.jsx)(n.p,{children:"Query it like the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  customer_of_current_store(pagination: { page: { page: 0, limit: 10 } }) {\n    nodes {\n      storeId\n      customerId\n      firstName\n      lastName\n      email\n    }\n    paginationInfo {\n      pages\n      current\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"It's almost effortless, right? In just a few lines of code, we've added a new API endpoint that does a lot under the hood.\nBut the heavylifting is done by Seaography + SeaORM."}),"\n",(0,a.jsx)(n.h2,{id:"how-does-it-work",children:"How does it work?"}),"\n",(0,a.jsx)(n.p,{children:"On a very high-level, how it all works:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Seaography bridges SeaORM types with Async GraphQL, such that any SeaORM entity can be used as GraphQL output"}),"\n",(0,a.jsx)(n.li,{children:"The schema meta of SeaORM entities are transformed into GraphQL schema on-the-fly on application startup"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The lifecycle of a GraphQL request:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Async GraphQL parses the HTTP request and construct a GraphQL request context"}),"\n",(0,a.jsx)(n.li,{children:"Your http handler intercepts this request and adds in additional session context"}),"\n",(0,a.jsx)(n.li,{children:"This GraphQL request is passed to Seaography"}),"\n",(0,a.jsx)(n.li,{children:"Seaography parses the input types and then construct the Rust types"}),"\n",(0,a.jsx)(n.li,{children:"Your async resolver is called, performing some business logic and returns result to Seaography"}),"\n",(0,a.jsx)(n.li,{children:"Seaography transforms the output and return to Async GraphQL"}),"\n",(0,a.jsx)(n.li,{children:"Async GraphQL does some final checks and serializes everything into a HTTP response"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["You may wonder, isn't the above kind of already possible by using Async GraphQL's derive macros, for example, by deriving ",(0,a.jsx)(n.a,{href:"https://docs.rs/async-graphql/latest/async_graphql/derive.SimpleObject.html",children:(0,a.jsx)(n.code,{children:"SimpleObject"})})," on a SeaORM entity?"]}),"\n",(0,a.jsxs)(n.p,{children:["Actually this is how ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2022-09-17-introducing-seaography/",children:"Seaography 0.1"})," worked in its initial release. However, the complex queries we shown you in the beginning is only achievable with a dynamic schema, but in Async GraphQL the static and dynamic schemas are completely different type systems - they can't inter-operate ... until now!"]}),"\n",(0,a.jsxs)(n.p,{children:["The difference is, the transformation between SeaORM Model ",(0,a.jsx)(n.code,{children:"<->"})," GraphQL Model happens dynamically, so there's not a ton of code generated beneath the surface."]}),"\n",(0,a.jsx)(n.h2,{id:"custom-mutation",children:"Custom Mutation"}),"\n",(0,a.jsx)(n.p,{children:"Let's continue on making custom mutation endpoints. Say now we want to create a transactional endpoint for staff members in store to handle customer rentals."}),"\n",(0,a.jsx)(n.p,{children:"First we can design the data structures for the input form:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use sea_orm::entity::prelude::{DateTimeUtc};\nuse seaography::{async_graphql, CustomFields, CustomInputType};\n\n#[derive(Clone, CustomInputType)]\npub struct RentalRequest {\n    pub customer: String,\n    pub film: String,\n    pub coupon: Option<Coupon>,\n    pub timestamp: DateTimeUtc,\n}\n\n#[derive(Clone, CustomInputType)]\npub struct Coupon {\n    pub code: String,\n    pub points: Option<Decimal>,\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then we can define the mutation endpoint:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[CustomFields]\nimpl Operations {\n    async fn rental_request(\n        ctx: &Context<'_>,\n        rental_request: RentalRequest,\n        //              \u2b06 our custom input struct\n    ) -> async_graphql::Result<rental::Model> {\n        //                     \u2b06 a normal SeaORM Model\n        let db = ctx.data::<DatabaseConnection>()?;\n        let session = ctx.data::<Session>()?;\n        let txn = db.begin().await?;\n        //  \u2b06 create a transaction to make operation atomic\n\n        let customer = Customer::find_by_name(rental_request.customer, &txn).await?;\n        let film = Film::find_by_name(rental_request.film, &txn).await?;\n        //  \u2b06 helper methods to find the corresponding customer and film\n\n        //  \u2b07 find if there is inventory in current store\n        let inventory = Inventory::find()\n            .filter(inventory::Column::FilmId.eq(film.id))\n            .filter(inventory::Column::StoreId.eq(session.store_id))\n            .one(&txn)\n            .unwrap_or(Error::NoInventory)?;\n        //  \u2b06 return error if no inventory\n\n        let rental = rental::ActiveModel {\n            rental_date: Set(rental_request.timestamp),\n            inventory_id: Set(inventory.id),\n            customer_id: Set(customer.id),\n            staff_id: Set(session.staff_id), // \u2b05 current staff\n            last_update: Set(Utc::now()),\n            ..Default::default()\n        }.insert(&txn).await?;\n\n        inventory.delete(&txn).await?;\n        //       \u2b06 now remove it from inventory\n        txn.commit().await?;\n        // \u2b07 return the newly created rental record\n        Ok(rental)\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Coupon"})," object is used to demonstrate that nested objects are supported, and it will be reflected in the GraphQL schema. I will leave it as an exercise for you to fit in the logic for handling it."]}),"\n",(0,a.jsx)(n.h3,{id:"custom-methods-and-unions",children:"Custom methods and unions"}),"\n",(0,a.jsx)(n.p,{children:"The GraphQL type system is very expressive (so is Rust), and so I want to demonstrate two more advanced features:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, CustomInputType, CustomOutputType)]\npub struct Rectangle {\n    pub origin: Point,\n    pub size: Size,\n}\n\n#[CustomFields]\nimpl Rectangle {\n    pub async fn area(&self) -> async_graphql::Result<f64> {\n        //            \u2b06 this is an instance method\n        Ok(self.size.width * self.size.height)\n    }\n}\n\n#[derive(Clone, CustomInputType, CustomOutputType)]\npub struct Circle {\n    pub center: Point,\n    pub radius: f64,\n}\n\n#[CustomFields]\nimpl Circle {\n    pub async fn area(&self) -> async_graphql::Result<f64> {\n        Ok(std::f64::consts::PI * self.radius * self.radius)\n    }\n}\n\n#[derive(Clone, CustomInputType, CustomOutputType)]\npub enum Shape {\n    Rectangle(Rectangle),\n    Circle(Circle),\n    Triangle(Triangle),\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After registering as ",(0,a.jsx)(n.code,{children:"complex_custom_outputs"}),", they will appear like below in the GraphQL schema:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"union Shape = Rectangle | Circle | Triangle\n\ntype Rectangle {\n  origin: Point!\n  size: Size!\n  area: Float! # \u2b05 as a 'computed property'\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"area"})," method will only be invoked when a query includes this field. Note that it is an async function, so you can even do database queries inside the function. For example, you can return a ",(0,a.jsx)(n.code,{children:"SimpleObject"})," from a related model."]}),"\n",(0,a.jsx)(n.p,{children:"The union type definition allows you to use union types in input / output, a very natural construct in Rust."}),"\n",(0,a.jsxs)(n.p,{children:["Full example can be found ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/seaography/blob/main/examples/sqlite/src/query_root.rs",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"lifecycle-hooks",children:"Lifecycle hooks"}),"\n",(0,a.jsx)(n.p,{children:"In Seaography, all logic is centralized in the same process, and it allows you to inject arbitrary custom logic throughout the request lifecycle using hooks. You can even implement access control this way."}),"\n",(0,a.jsx)(n.h3,{id:"finegrained-access-control",children:"Fine\u2011grained Access Control"}),"\n",(0,a.jsx)(n.p,{children:"Imagine you have a drawing app, and users can only access projects they own. You can implement the access control logic like the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'struct AccessControlHook;\n\nimpl LifecycleHooksInterface for AccessControlHook {\n    fn entity_filter(\n        &self,\n        ctx: &ResolverContext,\n        entity: &str,\n        _action: OperationType, // \u2b05 Read, Create, Update, Delete\n    ) -> Option<Condition> {\n        let session = ctx.data::<Session>()?;\n        //  \u2b06 extract user session\n        match entity {\n            "Project" => Some(\n                Condition::all()\n                    .add(project::Column::OwnerId.eq(session.user_id))\n                //  \u2b06 add custom filter condition\n            ),\n            _ => None,\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"By registering that into Seaography, this function will be called every time an Entity is being accessed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"lazy_static::lazy_static! {\n    static ref CONTEXT : BuilderContext = {\n        BuilderContext {\n            hooks: LifecycleHooks::new(AccessControlHook),\n            ..Default::default()\n        }\n    };\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"other-hooks",children:"Other hooks"}),"\n",(0,a.jsx)(n.p,{children:"There are many useful hooks for type conversion, access guard, event notification, etc."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub trait LifecycleHooksInterface: Send + Sync {\n    /// This happens before an Entity is accessed\n    fn entity_guard(\n        &self, ctx: &ResolverContext, entity: &str, action: OperationType\n    ) -> GuardAction {\n        GuardAction::Allow\n    }\n\n    /// This happens after an Entity is mutated\n    async fn entity_watch(\n        &self, ctx: &ResolverContext, entity: &str, action: OperationType\n    ) {}\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"\ufe0f-seaorm-pro-a-seaography-showcase",children:"\ud83d\udda5\ufe0f SeaORM Pro: A Seaography Showcase"}),"\n",(0,a.jsx)("img",{src:"/blog/img/sea-orm-pro-light.png#light"}),"\n",(0,a.jsx)("img",{src:"/blog/img/sea-orm-pro-dark.png#dark"}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/sea-orm-pro/",children:"SeaORM Pro"}),", you can launch a ready-to-use admin panel in minutes. Built on Seaography, it demonstrates the seamless integration of the full technology stack - async Rust backend, React frontend, and GraphQL as the protocol."]}),"\n",(0,a.jsxs)(n.p,{children:["SeaORM Pro has been updated to support the latest features in SeaORM 2.0, with ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-09-30-sea-orm-rbac/",children:"RBAC"})," support now available for preview in ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/sea-orm-pro/docs/introduction/sea-orm-pro-plus/",children:"SeaORM Pro Plus"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Features:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Full CRUD"}),"\n",(0,a.jsx)(n.li,{children:"Built on React + GraphQL"}),"\n",(0,a.jsx)(n.li,{children:"Customize the UI with TOML config"}),"\n",(0,a.jsx)(n.li,{children:"GraphQL resolver using Seaography"}),"\n",(0,a.jsxs)(n.li,{children:["Custom GraphQL endpoints ",(0,a.jsx)(n.em,{children:"(new in 2.0)"})]}),"\n",(0,a.jsxs)(n.li,{children:["Role Based Access Control ",(0,a.jsx)(n.em,{children:"(new in 2.0)"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"It took us a long time to get here, but this is our vision for application development in Rust: a framework that makes it effortless to get started, gives developers a ton of functionality out of the box, and still provides the power and flexibility to build complex applications."}),"\n",(0,a.jsx)(n.p,{children:"We're heavily inspired by tools in the Python, Ruby and node.js ecosystem. You can draw some parallels between Seaography and FastAPI:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Seaography"}),(0,a.jsx)(n.th,{children:"FastAPI"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GraphQL API"}),(0,a.jsx)(n.td,{children:"Rest API"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GraphQL schema"}),(0,a.jsx)(n.td,{children:"JSON Schema"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"GraphQL Playground"}),(0,a.jsx)(n.td,{children:"Swagger UI"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Rust native types"}),(0,a.jsx)(n.td,{children:"Pydantic"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"SeaORM"}),(0,a.jsx)(n.td,{children:"SQLModel"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"In another sense, Seaography is like PostGraphile, offering instant GraphQL API for SQL databases:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Seaography"}),(0,a.jsx)(n.th,{children:"PostGraphile"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsxs)(n.td,{children:["MySQL, Postgres, SQLite, ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM-X/",children:"SQL Server*"})]}),(0,a.jsx)(n.td,{children:"Postgres"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Compiled schema"}),(0,a.jsx)(n.td,{children:"Runtime generated schema"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"SeaORM's RBAC"}),(0,a.jsx)(n.td,{children:"Postgres' RLS"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Lifecycle hooks, builder context"}),(0,a.jsx)(n.td,{children:"Plugins"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"sponsors",children:"Sponsors"}),"\n",(0,a.jsxs)(n.p,{children:["This Seaography release has been made possible through the generous sponsorship of ",(0,a.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," and their close collaboration with SeaQL.org. QDX has built their data-driven applications with the Seaography + SeaORM stack, and we are deeply grateful for their contributions - both financial and technical - that helped bring this release to reality."]}),"\n",(0,a.jsxs)(n.p,{children:["We welcome companies to ",(0,a.jsx)(n.a,{href:"mailto:hello@sea-ql.org",children:"collaborate with SeaQL.org"})," to adopt and unlock the full potential of the Rust + SeaQL ecosystem, with our team providing expert technical consulting to support their software development."]}),"\n",(0,a.jsx)(n.h3,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,a.jsx)("a",{href:"https://qdx.co/",children:(0,a.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics\u2013powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring SeaQL.org."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);