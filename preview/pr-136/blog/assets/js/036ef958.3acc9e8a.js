"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[5396],{9680:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>c});var r=a(6687);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,s=function(e,t){if(null==e)return{};var a,r,s={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var o=r.createContext({}),m=function(e){var t=r.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=m(e.components);return r.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,s=e.mdxType,n=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=m(a),c=s,h=u["".concat(o,".").concat(c)]||u[c]||d[c]||n;return a?r.createElement(h,i(i({ref:t},p),{},{components:a})):r.createElement(h,i({ref:t},p))}));function c(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var n=a.length,i=new Array(n);i[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:s,i[1]=l;for(var m=2;m<n;m++)i[m]=a[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},880:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>n,metadata:()=>l,toc:()=>m});var r=a(1308),s=(a(6687),a(9680));const n={slug:"2024-11-30-whats-new-in-sea-streamer-0.5",title:"What's new in SeaStreamer 0.5",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",image:"https://www.sea-ql.org/SeaStreamer/img/SeaStreamer%20banner.png",tags:["news"]},i=void 0,l={permalink:"/preview/pr-136/blog/2024-11-30-whats-new-in-sea-streamer-0.5",editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2024-11-30-whats-new-in-sea-streamer-0.5.md",source:"@site/blog/2024-11-30-whats-new-in-sea-streamer-0.5.md",title:"What's new in SeaStreamer 0.5",description:"\ud83c\udf89 We are pleased to release SeaStreamer 0.5.x!",date:"2024-11-30T00:00:00.000Z",formattedDate:"November 30, 2024",tags:[{label:"news",permalink:"/preview/pr-136/blog/tags/news"}],readingTime:3.615,hasTruncateMarker:!1,authors:[{name:"Chris Tsang",title:"SeaQL Team",url:"https://github.com/tyt2y3",imageURL:"https://avatars.githubusercontent.com/u/1782664?v=4"}],frontMatter:{slug:"2024-11-30-whats-new-in-sea-streamer-0.5",title:"What's new in SeaStreamer 0.5",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",image:"https://www.sea-ql.org/SeaStreamer/img/SeaStreamer%20banner.png",tags:["news"]},prevItem:{title:"What's new in SeaQuery 0.32.0",permalink:"/preview/pr-136/blog/2024-12-03-whats-new-in-seaquery-0.32.0"},nextItem:{title:"GraphQL based Admin Dashboard with Loco and Seaography",permalink:"/preview/pr-136/blog/2024-08-08-graphql-admin-dashboard-with-loco-seaography"}},o={authorsImageUrls:[void 0]},m=[{value:"<code>sea-streamer-types</code>",id:"sea-streamer-types",level:2},{value:"<code>sea-streamer-socket</code>",id:"sea-streamer-socket",level:2},{value:"<code>sea-streamer-redis</code>",id:"sea-streamer-redis",level:2},{value:"<code>sea-streamer-file</code>",id:"sea-streamer-file",level:2},{value:"<code>sea-streamer-fuse</code>",id:"sea-streamer-fuse",level:2},{value:"Anecdote",id:"anecdote",level:2},{value:"Community",id:"community",level:2}],p={toc:m};function d(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("a",{href:"https://www.sea-ql.org/SeaStreamer/"},(0,s.kt)("img",{src:"https://www.sea-ql.org/SeaStreamer/img/SeaStreamer%20banner.png"})),(0,s.kt)("p",null,"\ud83c\udf89 We are pleased to release SeaStreamer ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/SeaQL/sea-streamer/releases/tag/0.5.2"},(0,s.kt)("inlineCode",{parentName:"a"},"0.5.x")),"!"),(0,s.kt)("p",null,"Here is the summary of new features and enhancements:"),(0,s.kt)("h2",{id:"sea-streamer-types"},(0,s.kt)("inlineCode",{parentName:"h2"},"sea-streamer-types")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Added ",(0,s.kt)("inlineCode",{parentName:"li"},"From<Url>")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"FromIterator<Url>")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"StreamerUri")," ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/SeaQL/sea-streamer/pull/28"},"#28")),(0,s.kt)("li",{parentName:"ul"},"Impl ",(0,s.kt)("inlineCode",{parentName:"li"},"Default")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"Payload")),(0,s.kt)("li",{parentName:"ul"},"Impl serde ",(0,s.kt)("inlineCode",{parentName:"li"},"Serialize")," & ",(0,s.kt)("inlineCode",{parentName:"li"},"Deserialize")," for ",(0,s.kt)("inlineCode",{parentName:"li"},"StreamKey")," (enabled by the feature flag ",(0,s.kt)("inlineCode",{parentName:"li"},"serde"),"), so this is now possible:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Serialize, Deserialize)]\nstruct MyStruct {\n    stream_key: StreamKey,\n}\n")),(0,s.kt)("h2",{id:"sea-streamer-socket"},(0,s.kt)("inlineCode",{parentName:"h2"},"sea-streamer-socket")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The Socket library can now be compiled without the ",(0,s.kt)("inlineCode",{parentName:"li"},"stdio")," backend ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/SeaQL/sea-streamer/pull/35"},"#35"))),(0,s.kt)("h2",{id:"sea-streamer-redis"},(0,s.kt)("inlineCode",{parentName:"h2"},"sea-streamer-redis")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Support nanosecond timestamp in Redis (under feature flag ",(0,s.kt)("inlineCode",{parentName:"li"},"nanosecond-timestamp"),").\nRedis's default Stream ID resolution is millisecond, and it can be changed to nanosecond with ",(0,s.kt)("a",{parentName:"li",href:"https://docs.rs/sea-streamer-redis/latest/sea_streamer_redis/struct.RedisConnectOptions.html#method.set_timestamp_format"},(0,s.kt)("inlineCode",{parentName:"a"},"RedisConnectOptions::set_timestamp_format")),":",(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"let mut options = RedisConnectOptions::default();\noptions.set_timestamp_format(TimestampFormat::UnixTimestampNanos);\n"))),(0,s.kt)("li",{parentName:"ul"},"Added ",(0,s.kt)("a",{parentName:"li",href:"https://docs.rs/sea-streamer-redis/latest/sea_streamer_redis/struct.RedisConnectOptions.html#method.set_message_field"},(0,s.kt)("inlineCode",{parentName:"a"},"RedisConnectOptions::set_message_field"))," to set custom message field (the default used to be ",(0,s.kt)("inlineCode",{parentName:"li"},"msg"),"):",(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'let mut options = RedisConnectOptions::default();\noptions.set_message_field("event");\n'))),(0,s.kt)("li",{parentName:"ul"},"Added ",(0,s.kt)("a",{parentName:"li",href:"https://docs.rs/sea-streamer-redis/latest/sea_streamer_redis/struct.RedisProducer.html#method.send_with_ts"},(0,s.kt)("inlineCode",{parentName:"a"},"RedisProducer::send_with_ts"))," to specify custom timestamp:",(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"producer.send_with_ts(&stream_key, timestamp, message)?;\n"))),(0,s.kt)("li",{parentName:"ul"},"Added ",(0,s.kt)("a",{parentName:"li",href:"https://docs.rs/sea-streamer-redis/latest/sea_streamer_redis/struct.RedisProducer.html#method.flush_immut"},(0,s.kt)("inlineCode",{parentName:"a"},"RedisProducer::flush_immut")),". This method is same as ",(0,s.kt)("a",{parentName:"li",href:"https://docs.rs/sea-streamer-redis/latest/sea_streamer_redis/struct.RedisProducer.html#method.flush"},(0,s.kt)("inlineCode",{parentName:"a"},"RedisProducer::flush"))," but without ",(0,s.kt)("inlineCode",{parentName:"li"},"&mut self")),(0,s.kt)("li",{parentName:"ul"},"Added ",(0,s.kt)("a",{parentName:"li",href:"https://docs.rs/sea-streamer-redis/latest/sea_streamer_redis/struct.RedisProducer.html#method.trim"},(0,s.kt)("inlineCode",{parentName:"a"},"RedisProducer::trim"))," to perform ",(0,s.kt)("inlineCode",{parentName:"li"},"XTRIM MAXLEN"),":",(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"producer.trim(&stream_key, maxlen).await?;\n"))),(0,s.kt)("li",{parentName:"ul"},"Fixed ",(0,s.kt)("inlineCode",{parentName:"li"},"capacity overflow")," error in some cases")),(0,s.kt)("h2",{id:"sea-streamer-file"},(0,s.kt)("inlineCode",{parentName:"h2"},"sea-streamer-file")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Added a special ",(0,s.kt)("inlineCode",{parentName:"li"},"SEA_STREAMER_WILDCARD")," stream key to subscribe to all streams in a file:",(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"let consumer: SeaConsumer = streamer\n    .create_consumer(&[StreamKey::new(SEA_STREAMER_WILDCARD)?], options)\n    .await?;\n")))),(0,s.kt)("h2",{id:"sea-streamer-fuse"},(0,s.kt)("inlineCode",{parentName:"h2"},"sea-streamer-fuse")),(0,s.kt)("p",null,"We've shipped the first component library for stream processing! It currently only has one class, ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/sea-streamer-fuse/latest/sea_streamer_fuse/struct.StreamJoin.html"},(0,s.kt)("inlineCode",{parentName:"a"},"StreamJoin")),"."),(0,s.kt)("p",null,"It is designed to be used in stream replay. In live streaming, if you have multiple streams from different sources and you want to multiplex them together, you can use the awesome ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/futures-concurrency"},(0,s.kt)("inlineCode",{parentName:"a"},"futures_concurrency"))," crate's ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html"},(0,s.kt)("inlineCode",{parentName:"a"},"Merge")),", and it just works!"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"use futures_concurrency::{stream::Merge, vec::Merge as Merged};\n\nlet consumers: Vec<SeaConsumer> = vec![stream_a, stream_b];\nlet streams: Vec<SeaMessageStream<'a>> = consumers.iter_mut().map(|ss| ss.stream()).collect();\nlet merged: Merged<SeaMessageStream<'a>> = streams.merge();\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"stream_a")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"stream_b")," can be heterogeneous, meaning they can be Kafka, Redis or even File."),(0,s.kt)("p",null,"How about in replay? In replay, different streams can flow at different pace, and thus if we try to naively merge them, the messages would come out-of-order."),(0,s.kt)("p",null,"To solve this problem, you can use ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/sea-streamer-fuse/latest/sea_streamer_fuse/struct.StreamJoin.html#method.muxed"},(0,s.kt)("inlineCode",{parentName:"a"},"StreamJoin::muxed")),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"type LiveStream<'a> = Merged<SeaMessageStream<'a>>;\nlet joined: StreamJoin<LiveStream<'a>, SeaMessage<'a>, StreamErr<BackendErr>> = StreamJoin::muxed(merged);\n")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/sea-streamer-fuse/latest/sea_streamer_fuse/struct.StreamJoin.html#method.align"},(0,s.kt)("inlineCode",{parentName:"a"},"StreamJoin::align"))," must be called manually to specify which streams should be aligned. Otherwise, messages will be out of order until the first message of each key arrives. Imagine a severely delayed stream sending its first message one day later; it would invalidate everything that came before it. However, the issue lies with the delayed stream itself, not the others."),(0,s.kt)("p",null,"In the example below, messages from the fast stream will be buffered, until a message from the slow stream arrives."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"fast | (1) (2) (3) (4) (5)\nslow |         (2)         (6)\n")),(0,s.kt)("p",null,"Messages ",(0,s.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," from fast will be buffered, until ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," from the slow stream arrives. Likewise, messages ",(0,s.kt)("inlineCode",{parentName:"p"},"3"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"4"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"5")," will be buffered until 6 arrives."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"StreamJoin")," component is generic, and can actually be used outside of SeaStreamer, the only requirement is that the thing we want to align implements ",(0,s.kt)("a",{parentName:"p",href:"https://docs.rs/sea-streamer-types/latest/sea_streamer_types/trait.Message.html"},(0,s.kt)("inlineCode",{parentName:"a"},"sea_streamer::Message")),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"impl Message for MyMessage {\n    fn stream_key(&self) -> StreamKey { /* implement this */ }\n\n    fn timestamp(&self) -> Timestamp { /* implement this */ }\n\n    fn shard_id(&self) -> ShardId { /* doesn't matter */ }\n\n    fn sequence(&self) -> SeqNo { /* doesn't matter */ }\n\n    fn message(&self) -> Payload { /* doesn't matter */ }\n}\n")),(0,s.kt)("h2",{id:"anecdote"},"Anecdote"),(0,s.kt)("p",null,"Over the past year, we've been using SeaStreamer heavily in production and it served us well!"),(0,s.kt)("p",null,"SeaStreamer File is really handy, because it supports live streaming and also duals as an archive, in which it can be rotated and uploaded to the data lake every day. It has replaced our use of Redis in some same-host mpmc streaming scenario."),(0,s.kt)("p",null,"Redis Streams is also super nice (fast and reliable) and especially easy with SeaStreamer. IMO it's been underrated, it became our default choice for cross-host streaming."),(0,s.kt)("p",null,"By the way, SeaStreamer File is used as the tracing file format in ",(0,s.kt)("a",{parentName:"p",href:"https://firedbg.sea-ql.org/"},"FireDBG"),"."),(0,s.kt)("h2",{id:"community"},"Community"),(0,s.kt)("p",null,"SeaQL.org is an independent open-source organization run by passionate \ufe0fdevelopers. If you like our projects, please star \u2b50 and share our repositories. If you feel generous, a small donation via ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/sponsors/SeaQL"},"GitHub Sponsor")," will be greatly appreciated, and goes a long way towards sustaining the organization \ud83d\udea2."),(0,s.kt)("p",null,"SeaStreamer is a community driven project. We welcome you to participate, contribute and together build for Rust's future \ud83e\udd80."))}d.isMDXComponent=!0}}]);