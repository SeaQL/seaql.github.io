"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[939],{1672:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var r=t(7705),s=t(8790),i=t(7630);const o={slug:"2025-01-08-sea-orm-inheritance",title:"Tutorial: Modeling Inheritance in SeaORM",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%201.0%20Banner.png",tags:["news"]},a=void 0,d={authorsImageUrls:[void 0]},l=[{value:"Introduction",id:"introduction",level:2},{value:"Schema",id:"schema",level:2},{value:"<code>BaseProduct</code>",id:"baseproduct",level:4},{value:"<code>ComplexProduct</code>",id:"complexproduct",level:4},{value:"<code>ProductType</code>",id:"producttype",level:4},{value:"1. Define result data structure",id:"1-define-result-data-structure",level:2},{value:"2. Define helper aliases",id:"2-define-helper-aliases",level:2},{value:"3. Custom selects",id:"3-custom-selects",level:2},{value:"4. Filter Conditions",id:"4-filter-conditions",level:2},{value:"5. Associated models",id:"5-associated-models",level:2},{value:"<code>ProductHistory</code>",id:"producthistory",level:4},{value:"Conclusion",id:"conclusion",level:2},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"This tutorial walks you through the design and implementation of a REST API endpoint that involves some complex relational queries."}),"\n",(0,s.jsx)(n.p,{children:"The API looks like this:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"POST"})," ",(0,s.jsx)(n.code,{children:"/api/v1/complex-products"})]}),"\n",(0,s.jsx)(n.p,{children:"Parameters (JSON body):"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Field"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"id"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int[]"})}),(0,s.jsx)(n.td,{children:"Get products with these ids"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"name"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Search products with name matching this"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"type"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"enum"})," of ",(0,s.jsx)(n.code,{children:"ProductType"})]}),(0,s.jsx)(n.td,{children:"Limit products to this type"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Return example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "id": 1,\n    "name": "Mountain Bike V2",\n    "type": "Bike",\n    "price": "2500.0",\n    "lot_size": "1.0",\n    "date_added": "2020-01-01T00:00:00",\n    "last_modified": "2025-01-02T12:18:54",\n    "history": [\n        {\n            "from": "2020-01-01T00:00:00",\n            "until": "2022-01-01T00:00:00",\n            "name": "Mountain Bike V1"\n        }\n    ]\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"schema",children:"Schema"}),"\n",(0,s.jsx)(n.p,{children:"Imagine we run a store with many types of products. Each product type has its own attributes and we want to factor out the common product attributes to a base class."}),"\n",(0,s.jsx)(n.p,{children:"In OOP terms:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct BaseProduct {\n    r#type: ProductType,\n    ..\n}\n\n// made up syntax, but it means inheritance\nstruct ComplexProduct: BaseProduct { .. }\n\nenum ProductType { .. }\n"})}),"\n",(0,s.jsx)(n.p,{children:"In SQL terms, we have 3 entities and 2 relations among them:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BaseProduct"})," -> ",(0,s.jsx)(n.code,{children:"ComplexProduct"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BaseProduct"})," -> ",(0,s.jsx)(n.code,{children:"ProductType"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Below are the SeaORM Entities:"}),"\n",(0,s.jsx)(n.h4,{id:"baseproduct",children:(0,s.jsx)(n.code,{children:"BaseProduct"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "base_product")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i64,\n    #[sea_orm(unique)]\n    pub name: String,\n    pub type_id: i32, // linking to product_type\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_one = "super::complex_product::Entity")]\n    ComplexProduct,\n    #[sea_orm(has_many = "super::product_history::Entity")]\n    ProductHistory,\n    #[sea_orm(\n        belongs_to = "super::product_type::Entity",\n        from = "Column::TypeId",\n        to = "super::product_type::Column::Id",\n        on_update = "NoAction",\n        on_delete = "NoAction"\n    )]\n    ProductType,\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"complexproduct",children:(0,s.jsx)(n.code,{children:"ComplexProduct"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "complex_product")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub product_id: i64, // linking to base_product\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub price: Option<Decimal>,\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub lot_size: Option<Decimal>,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"producttype",children:(0,s.jsx)(n.code,{children:"ProductType"})}),"\n",(0,s.jsx)(n.p,{children:"Basically an 'enum table'."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "product_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)]\n    pub name: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = "super::base_product::Entity")]\n    BaseProduct,\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"1-define-result-data-structure",children:"1. Define result data structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Clone, Debug, PartialEq, Eq, FromQueryResult, Serialize)]\npub struct ComplexProduct {\n    pub id: i64,\n    pub name: String,\n    pub r#type: String,\n    pub price: Decimal,\n    pub lot_size: Decimal,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n    #[sea_orm(skip)]\n    pub history: Vec<product_history::Model>,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.code,{children:"Serialize"}),", you can transform the select result into JSON directly."]}),"\n",(0,s.jsx)(n.h2,{id:"2-define-helper-aliases",children:"2. Define helper aliases"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(DeriveIden, Clone, Copy)]\npub struct Id;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Name;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Base;\n\nuse complex_product::Entity as Prod;\npub type ProdCol = <Prod as EntityTrait>::Column;\ntype ProdRel = <Prod as EntityTrait>::Relation;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This would make our code much more concise and readable."}),"\n",(0,s.jsxs)(n.p,{children:["Avoid using ",(0,s.jsx)(n.code,{children:"Alias::new"})," because it's error-prone and slightly more expensive."]}),"\n",(0,s.jsx)(n.h2,{id:"3-custom-selects",children:"3. Custom selects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn query() -> Select<complex_product::Entity> {\n    complex_product::Entity::find()\n        .select_only()\n        .tbl_col_as((Base, Id), "id")\n        .tbl_col_as((Base, Name), "name")\n        .column_as(product_type::Column::Name, "type")\n        .column_as(ProdCol::Price, "price")\n        .column_as(ProdCol::LotSize, "lot_size")\n        .column_as(ProdCol::DateAdded, "date_added")\n        .column_as(ProdCol::LastModified, "last_modified")\n        .join_as(JoinType::InnerJoin, ProdRel::BaseProduct.def(), Base)\n        .join(JoinType::InnerJoin, base_product::Relation::ProductType.def().from_alias(Base))\n        .order_by_asc(Expr::col((Base, Id)))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Our query starts from ",(0,s.jsx)(n.code,{children:"ComplexProduct"}),". We join back to ",(0,s.jsx)(n.code,{children:"BaseProduct"}),", alias it as ",(0,s.jsx)(n.code,{children:"Base"}),". We then join to ",(0,s.jsx)(n.code,{children:"ProductType"})," via ",(0,s.jsx)(n.code,{children:"Base"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ComplexProduct -> BaseProduct as Base -> ProductType\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.column_as",children:(0,s.jsx)(n.code,{children:"column_as"})})," automatically prefix the column with the table name.\n",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/entity/struct.RelationDef.html#method.from_alias",children:(0,s.jsx)(n.code,{children:"from_alias"})})," is doing the magic here, allowing us to reuse the existing Relation by overwriting the left hand side of the on condition."]}),"\n",(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.join",children:(0,s.jsx)(n.code,{children:"join"})})," method to construct complex joins in select queries. It takes any ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/entity/struct.RelationDef.html",children:(0,s.jsx)(n.code,{children:"RelationDef"})}),", and you can further customize the join conditions. You can find more examples ",(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM/docs/advanced-query/advanced-joins/#custom-join-conditions",children:"here"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"4-filter-conditions",children:"4. Filter Conditions"}),"\n",(0,s.jsx)(n.p,{children:"Let's define struct for query parameters. Again, using serde here so it can be deserialized from JSON."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Default, Deserialize)]\npub struct Query {\n    #[serde(default)]\n    pub id: Vec<i64>, // if unspecified, will be an empty vec\n    pub name: Option<String>,\n    pub r#type: Option<String>,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then, we transform the parameters into SQL where conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn condition(query: Query) -> Condition {\n    Condition::all()\n        .add_option(if !query.id.is_empty() {\n            Some(Expr::col((Base, Id)).is_in(query.id))\n        } else { None })\n        .add_option(if let Some(name) = &query.name {\n            Some(Expr::col((Base, Name)).like(name))\n        } else { None })\n        .add_option(if let Some(r#type) = &query.r#type {\n            Some(product_type::Column::Name.eq(r#type))\n        } else { None })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Bonus tip: if you're only using Postgres you can replace ",(0,s.jsx)(n.code,{children:"is_in"})," with ",(0,s.jsx)(n.code,{children:"any"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use sea_orm::sea_query::extension::postgres::PgFunc;\n\nExpr::col((Base, Id)).eq(PgFunc::any(query.id)) // WHERE base.id = ANY($N)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Combining the above functions, here is how we implement the API endpoint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub async fn query_products(db: DbConn, q: Query)\n    -> Result<Vec<ComplexProduct>, DbErr>\n{\n    query()\n        .filter(condition(q))\n        .into_model::<ComplexProduct>()\n        .all(&db)\n        .await\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"5-associated-models",children:"5. Associated models"}),"\n",(0,s.jsxs)(n.p,{children:["Suppose we have a data structure associated with each ",(0,s.jsx)(n.code,{children:"BaseProduct"})," recording its history."]}),"\n",(0,s.jsx)(n.h4,{id:"producthistory",children:(0,s.jsx)(n.code,{children:"ProductHistory"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize)]\n#[sea_orm(table_name = "product_history")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[serde(skip)]\n    pub id: i32,\n    #[serde(skip)]\n    pub product_id: i64,\n    pub from: DateTime,\n    pub until: DateTime,\n    pub name: Option<String>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's make a helper function to query the histories associated to a set of products:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn history_of(ids: Vec<i64>) -> Select<product_history::Entity> {\n    product_history::Entity::find()\n        .filter(Expr::col(product_history::Column::ProductId).is_in(ids))\n        .order_by_asc(product_history::Column::Id)\n}\n\nlet histories = history_of(products.iter().map(|s| s.id).collect::<Vec<_>>())\n    .all(&db)\n    .await?;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The final step is to associate ",(0,s.jsx)(n.code,{children:"product_history::Model"})," to ",(0,s.jsx)(n.code,{children:"ComplexProduct"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// parent should be unique and already ordered by id.\nfn associate(\n    mut parent: Vec<ComplexProduct>,\n    children: Vec<product_history::Model>,\n) -> Vec<ComplexProduct> {\n    let len = parent.len();\n    parent.dedup_by_key(|s| s.id);\n    if len != parent.len() {\n        warn!("parent is not unique.");\n    }\n\n    let parent_id_map: HashMap<i64, usize> = parent\n        .iter()\n        .enumerate()\n        .map(|(i, s)| (s.id, i))\n        .collect();\n\n    // put children into associated parent\n    for item in children {\n        if let Some(index) = parent_id_map.get(&item.product_id) {\n            parent[*index].history.push(item);\n        }\n    }\n\n    parent\n}\n\nlet products = associate(products, histories);\n'})}),"\n",(0,s.jsx)(n.p,{children:'This is sometimes called "data loader" pattern, and can be generalized with generics to work with any models.'}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM's type system encourages you to write modular and reusable code, embracing the \"Don't repeat yourself\" principle."}),"\n",(0,s.jsx)(n.p,{children:"You define the Entities and Relations once."}),"\n",(0,s.jsx)(n.p,{children:"You define the aliases and query helpers once."}),"\n",(0,s.jsxs)(n.p,{children:["You can pass the ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/query/struct.Select.html",children:(0,s.jsx)(n.code,{children:"Select<T>"})})," and ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/query/struct.Condition.html",children:(0,s.jsx)(n.code,{children:"Condition"})})," around."]}),"\n",(0,s.jsx)(n.p,{children:"You then assemble these pieces together to implement any complex API!"}),"\n",(0,s.jsx)(n.h2,{id:"rustacean-sticker-pack-",children:"Rustacean Sticker Pack \ud83e\udd80"}),"\n",(0,s.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"}),"\n",(0,s.jsx)(n.p,{children:"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."}),"\n",(0,s.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"}),"\n",(0,s.jsx)(n.li,{children:"Mascot of SeaQL: Terres the Hermit Crab"}),"\n",(0,s.jsx)(n.li,{children:"Mascot of Rust: Ferris the Crab"}),"\n",(0,s.jsx)(n.li,{children:"The Rustacean word"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,s.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,s.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},7630:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(2374);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},7705:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-148/blog/2025-01-08-sea-orm-inheritance","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-01-08-sea-orm-inheritance.md","source":"@site/blog/2025-01-08-sea-orm-inheritance.md","title":"Tutorial: Modeling Inheritance in SeaORM","description":"Introduction","date":"2025-01-08T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-148/blog/tags/news"}],"readingTime":5.89,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-01-08-sea-orm-inheritance","title":"Tutorial: Modeling Inheritance in SeaORM","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%201.0%20Banner.png","tags":["news"]},"unlisted":false,"prevItem":{"title":"What\'s new in SeaORM 1.1.7","permalink":"/preview/pr-148/blog/2025-03-08-whats-new-in-sea-orm-1.1"},"nextItem":{"title":"SeaQL Community Survey 2024 Results","permalink":"/preview/pr-148/blog/2025-01-02-community-survey-2024"}}')}}]);