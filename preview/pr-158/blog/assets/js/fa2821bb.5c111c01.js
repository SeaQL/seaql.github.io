"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[2473],{801:e=>{e.exports=JSON.parse('{"permalink":"/preview/pr-158/blog/2025-08-15-sea-query-raw-sql","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-08-15-sea-query-raw-sql.md","source":"@site/blog/2025-08-15-sea-query-raw-sql.md","title":"SeaQuery just made writing raw SQL more enjoyable","description":"You enjoy writing raw SQL queries, SeaQuery just made it better!","date":"2025-08-15T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/preview/pr-158/blog/tags/news"}],"readingTime":7.75,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-08-15-sea-query-raw-sql","title":"SeaQuery just made writing raw SQL more enjoyable","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png","tags":["news"]},"unlisted":false,"prevItem":{"title":"The road to SeaQuery 1.0","permalink":"/preview/pr-158/blog/2025-08-30-sea-query-1.0"},"nextItem":{"title":"What\'s new in SeaORM 1.1.12","permalink":"/preview/pr-158/blog/2025-06-01-whats-new-in-sea-orm-1.1"}}')},7980:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var r=s(801),a=s(4848),t=s(8453);const i={slug:"2025-08-15-sea-query-raw-sql",title:"SeaQuery just made writing raw SQL more enjoyable",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png",tags:["news"]},l=void 0,o={authorsImageUrls:[void 0]},c=[{value:"Gist",id:"gist",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Dive in",id:"dive-in",level:2},{value:"Other ideas",id:"other-ideas",level:3},{value:"More goodies",id:"more-goodies",level:2},{value:"Tuple expansion",id:"tuple-expansion",level:3},{value:"Insert Many",id:"insert-many",level:2},{value:"With Tuples",id:"with-tuples",level:3},{value:"With structs",id:"with-structs",level:3},{value:"SQLx Integration",id:"sqlx-integration",level:2},{value:"Lightweightness",id:"lightweightness",level:3},{value:"SeaQuery 1.0",id:"seaquery-10",level:2},{value:"\ud83e\udd80 Rustacean Sticker Pack",id:"-rustacean-sticker-pack",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{alt:"SeaQuery 1.0 Banner",src:"/blog/img/SeaQuery%201.0%20Banner.png"}),"\n",(0,a.jsx)(n.p,{children:"You enjoy writing raw SQL queries, SeaQuery just made it better!"}),"\n",(0,a.jsxs)(n.p,{children:["We've created a new ",(0,a.jsx)(n.code,{children:"raw_query!"})," macro with neat features to make writing raw SQL queries more ergononmic."]}),"\n",(0,a.jsxs)(n.p,{children:["The biggest headache when crafting complex queries is parameter binding, whether you use ",(0,a.jsx)(n.code,{children:"?"})," or ",(0,a.jsx)(n.code,{children:"$N"})," assigning parameters manually is laborious and error-prone."]}),"\n",(0,a.jsxs)(n.p,{children:["SeaQuery's new ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-query/1.0.0-rc.9/sea_query/index.html#4-improved-raw-sql-ergonomics",children:(0,a.jsx)(n.code,{children:"raw_query!"})})," macro is designed to solve this exact problem."]}),"\n",(0,a.jsx)(n.h2,{id:"gist",children:"Gist"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let a = 1;\nstruct B { b: i32 }\nlet b = B { b: 2 };\nlet c = "A";\nlet d = vec![3, 4, 5];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"SELECT ("size_w" + {a}) * {b.b} FROM "glyph"\n       WHERE "image" LIKE {c} AND "id" IN ({..d})"#\n);\n\nassert_eq!(\n    query.sql,\n    r#"SELECT ("size_w" + $1) * $2 FROM "glyph"\n       WHERE "image" LIKE $3 AND "id" IN ($4, $5, $6)"#\n);\nassert_eq!(\n    query.values,\n    Values(vec![1.into(), 2.into(), "A".into(), 3.into(), 4.into(), 5.into()])\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"There are several features packed into the snippet above!"}),"\n",(0,a.jsx)(n.p,{children:"Let's have a quick overview and we'll dive into the details:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["named parameter: ",(0,a.jsx)(n.code,{children:"{a}"})," injected"]}),"\n",(0,a.jsxs)(n.li,{children:["nested parameter access: ",(0,a.jsx)(n.code,{children:"{b.b}"})," inner access"]}),"\n",(0,a.jsxs)(n.li,{children:["array expansion: ",(0,a.jsx)(n.code,{children:"{..d}"})," expanded into three parameters"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"There are two more features that will be showcased later:"}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsxs)(n.li,{children:["tuple expansion: ",(0,a.jsx)(n.code,{children:"{values.0:2}"})]}),"\n",(0,a.jsxs)(n.li,{children:["repeating group: ",(0,a.jsx)(n.code,{children:"{..(values.0),}"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(n.p,{children:"While SeaQuery has long offered a way to build dynamic queries solving basically the same problem, not every one liked SeaQuery's code structure."}),"\n",(0,a.jsxs)(n.p,{children:["I recently came across this ",(0,a.jsx)(n.a,{href:"https://github.com/launchbadge/sqlx/issues/875",children:"SQLx issue"}),", and was enticed to solve it."]}),"\n",(0,a.jsxs)(n.p,{children:["I am heavily inspired by Rust's ",(0,a.jsx)(n.code,{children:"format!"})," macro and other languages' template literals for string interpolation, and figured it could probably be achieved in Rust as well!"]}),"\n",(0,a.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,a.jsxs)(n.p,{children:["First, the above cannot be implemented with standard ",(0,a.jsx)(n.code,{children:"macro_rules"})," because of caller hygiene, such that expanded code cannot access the variables in the surrounding scope. But proc macros do not have this limitation."]}),"\n",(0,a.jsx)(n.p,{children:"Second, if we want to expand an array, the number of elements cannot be known until runtime. So a compile-time approach couldn't work."}),"\n",(0,a.jsx)(n.p,{children:"Third, we have to support all of Rust's primitive and container types as well as third party data types."}),"\n",(0,a.jsx)(n.h2,{id:"dive-in",children:"Dive in"}),"\n",(0,a.jsx)(n.p,{children:"Let's take a look at what the above code expands into!"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let a = 1;\nstruct B {\n    b: i32,\n}\nlet b = B { b: 2 };\nlet c = "A";\nlet d = <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([3, 4, 5]));\n\nlet query = {\n    use sea_query::raw_sql::*;\n    let mut builder = RawSqlQueryBuilder::new(sea_query::PostgresQueryBuilder);\n    builder\n        .push_fragment("SELECT (\\"size_w\\" + ")\n        .push_parameters(1)\n        .push_fragment(") * ")\n        .push_parameters(1)\n        .push_fragment(" FROM \\"glyph\\"\\n        WHERE \\"image\\" LIKE ")\n        .push_parameters(1)\n        .push_fragment(" AND \\"id\\" IN (")\n        .push_parameters((&d).len())\n        .push_fragment(")");\n    let sql = builder.finish();\n    let mut query = seaql::query(&sql);\n    query = query.bind(&a);\n    query = query.bind(&b.b);\n    query = query.bind(&c);\n    for v in (&d).iter() {\n        query = query.bind(v);\n    }\n    query\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["I created ",(0,a.jsx)(n.code,{children:"RawSqlQueryBuilder"})," that is somewhat similar to SeaQuery's query building backend. It serializes the query string in a single pass."]}),"\n",(0,a.jsxs)(n.p,{children:["The derive macro first tokenize and parse the raw SQL to identify the splice points, and then call a special method ",(0,a.jsx)(n.code,{children:"push_parameters"})," to push a variable number of parameters. This can be numbered, i.e. for Postgres."]}),"\n",(0,a.jsx)(n.p,{children:"After finishing the SQL building part, it then proceeds to bind the parameters. This mechanism is designed around SQLx's query API."}),"\n",(0,a.jsxs)(n.p,{children:["If the variable has a spread ",(0,a.jsx)(n.code,{children:".."})," operator, we'd loop over it and bind all items."]}),"\n",(0,a.jsx)(n.h3,{id:"other-ideas",children:"Other ideas"}),"\n",(0,a.jsxs)(n.p,{children:["Originally I wanted to implement auto-expansion, meaning if the parameter is a container type, we'd expand it automagically. But there are quite a few special cases - most importantly ",(0,a.jsx)(n.code,{children:"Vec<u8>"})," is used as bytes and should be bound as a single parameter. Moreover, in Postgres you can use arrays directly, and so we can't decide whether to expand."]}),"\n",(0,a.jsx)(n.h2,{id:"more-goodies",children:"More goodies"}),"\n",(0,a.jsx)(n.h3,{id:"tuple-expansion",children:"Tuple expansion"}),"\n",(0,a.jsx)(n.p,{children:"There are two more features that'll make your life much easier."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let var = (1, "2".to_owned(), 3);\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    "SELECT {var.0}, {var.1}, {var.2}"\n);\n\nlet new_query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"SELECT {var.0:2}"#\n);\n\nassert_eq!(query, new_query);\n'})}),"\n",(0,a.jsx)(n.p,{children:"We can already support accessing tuple members, why not offer a range operator?"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:":"})," token is chosen because it somewhat resembles the Python operator. ",(0,a.jsx)(n.code,{children:"[0:2]"})," is un-natural because tuple members in Rust can only be accessed by ",(0,a.jsx)(n.code,{children:".0"}),". Feel free to offer your thoughts!"]}),"\n",(0,a.jsx)(n.p,{children:"It's not possible to automatically expand a tuple like an array because its arity (the number of elements) is not known at the time the macro is expanded. If the tuple consists of elements with a uniform type, it can be made iterable like a vector by implementing the appropriate traits. However, that approach doesn't apply in the case above, where the tuple's structure is not uniform."}),"\n",(0,a.jsx)(n.p,{children:"You can do inserts with this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let values = (1, "2", 3);\n\nlet query = sea_query::raw_query!(\n    MysqlQueryBuilder,\n    "INSERT INTO `glyph` (`aspect`, `image`, `font_size`) VALUES ({values.0:2})"\n);\nassert_eq!(\n    query.sql,\n    "INSERT INTO `glyph` (`aspect`, `image`, `font_size`) VALUES (?, ?, ?)"\n);\nassert_eq!(query.values, Values(vec![1.into(), "2".into(), 3.into()]));\n'})}),"\n",(0,a.jsx)(n.p,{children:"You may ask, then how do we insert multiple elements? Which brings us to the next feature:"}),"\n",(0,a.jsx)(n.h2,{id:"insert-many",children:"Insert Many"}),"\n",(0,a.jsxs)(n.p,{children:["When working with Rust and SQL, a common pain point is figuring out how to insert multiple rows efficiently. Writing raw SQL INSERT statements for each row is verbose, and while Postgres supports ",(0,a.jsx)(n.code,{children:"UNNEST"})," for bulk inserts, its columnar API feels awkward and error-prone."]}),"\n",(0,a.jsxs)(n.p,{children:["SeaQuery solves this by letting you build multi-row insert statements easily. With the ",(0,a.jsx)(n.code,{children:"raw_query!"})," macro, you can pass in a vector of structs or tuples and generate a single ",(0,a.jsx)(n.code,{children:"INSERT INTO .. VALUES (..) , (..) , (..)"})," query. This keeps your code clean, while still allowing you to do bulk insertions for efficiency. This solution is database agnostic so you can use it for MySQL and SQLite as well."]}),"\n",(0,a.jsx)(n.h3,{id:"with-tuples",children:"With Tuples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let values = vec![(1, "2", 3), (4, "5", 6)];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"INSERT INTO "glyph" ("aspect", "image", "font_size")\n       VALUES {..(values.0:2),}"#\n);\nassert_eq!(\n    query.sql,\n    r#"INSERT INTO "glyph" ("aspect", "image", "font_size")\n       VALUES ($1, $2, $3), ($4, $5, $6)"#\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:'To achieve this we designed the "repeating group" syntax, inspired by regex. Please let me explain:'}),"\n",(0,a.jsxs)(n.p,{children:["It's expanded upon the previous example, in which ",(0,a.jsx)(n.code,{children:"values.0:2"})," means tuple expansion. We want to repeat this tuple as a group, surrounded by parenthesis, so we wrap it with ",(0,a.jsx)(n.code,{children:"()"}),". Then we apply the same spread operator ",(0,a.jsx)(n.code,{children:".."})," to expand the vector of tuples. Finally, the trailing ",(0,a.jsx)(n.code,{children:","})," means they should be connected with ",(0,a.jsx)(n.code,{children:","}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"with-structs",children:"With structs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'struct Item {\n    a: i32,\n    b: String,\n    c: u16,\n}\n\nlet values = vec![\n    Item { a: 1, b: "2".to_owned(), c: 3 },\n    Item { a: 4, b: "5".to_owned(), c: 6 },\n];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"INSERT INTO "glyph" ("aspect", "image", "font_size")\n       VALUES {..(values.a, values.b, values.c),}"#\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is equivalent to the previous example, but uses named parameters."}),"\n",(0,a.jsx)(n.h2,{id:"sqlx-integration",children:"SQLx Integration"}),"\n",(0,a.jsxs)(n.p,{children:["SeaQuery offers tight SQLx integration. So in practice you can do (requires ",(0,a.jsx)(n.code,{children:"sqlx-utils"})," feature flag):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let mut sql;\nlet res = sea_query::sqlx::sqlite::query!(\n    sql = r#"INSERT INTO "character"\n             ("uuid", "font_size", "character")\n             VALUES {..(values.0:2),}"#\n).execute(pool).await?;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note the salient ",(0,a.jsx)(n.code,{children:"sql"})," variable. SQLx's ",(0,a.jsx)(n.code,{children:"Query"})," object can only borrow the SQL as ",(0,a.jsx)(n.code,{children:"&str"}),", and so someone has to own the ",(0,a.jsx)(n.code,{children:"String"}),". I couldn't think of a better API, suggestions welcome."]}),"\n",(0,a.jsxs)(n.p,{children:["It calls the underlying ",(0,a.jsx)(n.a,{href:"https://docs.rs/sqlx/latest/sqlx/query/struct.Query.html",children:(0,a.jsx)(n.code,{children:"Query"})}),"'s bind method directly, so no extra copy is involved. This is the lowest possible overhead!"]}),"\n",(0,a.jsx)(n.p,{children:"One final example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let mut character = Character { id: 1, font_size: 0 };\ncharacter.font_size = 18;\n\nlet res = sea_query::sqlx::sqlite::query!(\n    sql = r#"UPDATE "character"\n             SET "font_size" = {character.font_size}\n             WHERE "id" = {character.id}"#\n).execute(pool).await?;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Full example can be found ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/blob/master/examples/sqlx_sqlite/src/main.rs",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["It almost feels like a mini ORM ... although ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm",children:"SeaORM \ud83d\udc1a"})," is still highly recommended!"]}),"\n",(0,a.jsx)(n.h3,{id:"lightweightness",children:"Lightweightness"}),"\n",(0,a.jsxs)(n.p,{children:["SeaQuery without default features only has a handful of dependencies. But if you want to keep dependencies to an absolute minimum, you can depends on ",(0,a.jsx)(n.code,{children:"sea-query-derive"})," directly."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:"$ cargo tree --no-default-features -e normal,build\nsea-query-derive v1.0.0-rc.11 (proc-macro)\n\u251c\u2500\u2500 proc-macro2 v1.0.94\n\u2502   \u2514\u2500\u2500 unicode-ident v1.0.12\n\u251c\u2500\u2500 quote v1.0.40\n\u2502   \u2514\u2500\u2500 proc-macro2 v1.0.94 (*)\n\u2514\u2500\u2500 syn v2.0.100\n    \u251c\u2500\u2500 proc-macro2 v1.0.94 (*)\n    \u251c\u2500\u2500 quote v1.0.40 (*)\n    \u2514\u2500\u2500 unicode-ident v1.0.12\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then you can use it like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let sql;\nlet res: Vec<_> = sea_query_derive::raw_sql!(\n    sqlx::sqlite::query_as,\n    sql = "SELECT {var.0:2}"\n).fetch_all(pool).await?;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"seaquery-10",children:"SeaQuery 1.0"}),"\n",(0,a.jsxs)(n.p,{children:["This is just one of many new features we've added while preparing ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-08-30-sea-query-1.0/",children:"SeaQuery 1.0"}),". This is currently an ",(0,a.jsx)(n.code,{children:"rc"})," release, but we plan to finalize it soon. If you have ideas please ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/discussions/795",children:"join the discussion"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"-rustacean-sticker-pack",children:"\ud83e\udd80 Rustacean Sticker Pack"}),"\n",(0,a.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish."}),"\n",(0,a.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography"}),"\n",(0,a.jsx)(n.li,{children:"Mascots: Ferris the Crab x 3, Terres the Hermit Crab"}),"\n",(0,a.jsx)(n.li,{children:"The Rustacean wordmark"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,a.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,a.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var r=s(6540);const a={},t=r.createContext(a);function i(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);