"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[9984],{6484:(e,s,t)=>{t.d(s,{R:()=>n,x:()=>o});var r=t(2374);const a={},i=r.createContext(a);function n(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),r.createElement(i.Provider,{value:s},e.children)}},6592:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>n,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"whats-next/roadmap","title":"The Roadmap","description":"Thank you for reading the documentation up to this chapter. Excuse me for asking you again, if you find this project interesting and/or useful, please star our GitHub repo! Your support is vital to the continued development of SeaStreamer.","source":"@site/versioned_docs/version-0.2.x/05-whats-next/01-roadmap.md","sourceDirName":"05-whats-next","slug":"/whats-next/roadmap","permalink":"/preview/pr-158/SeaStreamer/docs/0.2.x/whats-next/roadmap","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.2.x/05-whats-next/01-roadmap.md","tags":[],"version":"0.2.x","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1763472397000,"sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Intra Process","permalink":"/preview/pr-158/SeaStreamer/docs/0.2.x/processors/intra-process"},"next":{"title":"The Vision","permalink":"/preview/pr-158/SeaStreamer/docs/0.2.x/whats-next/vision"}}');var a=t(8790),i=t(6484);const n={},o="The Roadmap",d={},c=[{value:"<code>sea-streamer-file</code>: File Backend",id:"sea-streamer-file-file-backend",level:2},{value:"<code>sea-streamer-redis</code>: Redis Cluster",id:"sea-streamer-redis-redis-cluster",level:2},{value:"Your proposal",id:"your-proposal",level:2}];function l(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"the-roadmap",children:"The Roadmap"})}),"\n",(0,a.jsxs)(s.p,{children:["Thank you for reading the documentation up to this chapter. Excuse me for asking you again, if you find this project interesting and/or useful, please star our ",(0,a.jsx)(s.a,{href:"https://github.com/SeaQL/sea-streamer",children:"GitHub repo"}),"! Your support is vital to the continued development of SeaStreamer."]}),"\n",(0,a.jsx)(s.p,{children:"Here are a few major components we plan to develop up next:"}),"\n",(0,a.jsxs)(s.h2,{id:"sea-streamer-file-file-backend",children:[(0,a.jsx)(s.code,{children:"sea-streamer-file"}),": File Backend"]}),"\n",(0,a.jsxs)(s.p,{children:["This is very similar to ",(0,a.jsx)(s.code,{children:"sea-streamer-stdio"}),", but the difference is ",(0,a.jsx)(s.code,{children:"sea-streamer-stdio"})," works in real-time, while ",(0,a.jsx)(s.code,{children:"sea-streamer-file"})," works in real-time and replay. That means, ",(0,a.jsx)(s.code,{children:"sea-streamer-file"})," has the ability to seek through a ",(0,a.jsx)(s.code,{children:".ss"})," (sea-stream) file and seek/rewind to a particular timestamp/offset."]}),"\n",(0,a.jsxs)(s.p,{children:["In addition, ",(0,a.jsx)(s.code,{children:"stdio"})," can only work with UTF-8 text data, while ",(0,a.jsx)(s.code,{children:"file"})," is able to work with binary data."]}),"\n",(0,a.jsx)(s.p,{children:"We might be able to commit consumer states into a local SQLite database, enabling transactional behavior."}),"\n",(0,a.jsxs)(s.h2,{id:"sea-streamer-redis-redis-cluster",children:[(0,a.jsx)(s.code,{children:"sea-streamer-redis"}),": Redis Cluster"]}),"\n",(0,a.jsxs)(s.p,{children:["Redis support has been released in ",(0,a.jsx)(s.code,{children:"sea-streamer"})," ",(0,a.jsx)(s.code,{children:"0.2"}),"! Basic stream sharding is implemented, but sharding without clustering is not very useful."]}),"\n",(0,a.jsxs)(s.p,{children:["In the future, we'd like to support Redis Cluster, right now it's pretty much a work-in-progress. It's quite a difficult task, because clients have to take responsibility when working with a cluster.\nIn Redis, shards and nodes is a dynamic M-N mapping - shards can be moved among nodes ",(0,a.jsx)(s.em,{children:"at any time"}),".\nIt makes testing much more difficult."]}),"\n",(0,a.jsx)(s.p,{children:"In Redis, consumers in the same group share the same shard, i.e. shared shard. In the future, we'd like to support 'owned shard' semantics, where each consumer will attempt to claim ownership of a shard, and other consumers in the group will not step in. This mimicks Kafka\u2019s consumer group behaviour."}),"\n",(0,a.jsx)(s.p,{children:"Let us know if you'd like to help!"}),"\n",(0,a.jsx)(s.h2,{id:"your-proposal",children:"Your proposal"}),"\n",(0,a.jsxs)(s.p,{children:["We welcome you to join our ",(0,a.jsx)(s.a,{href:"https://github.com/SeaQL/sea-streamer/discussions",children:"Discussions"})," if you have thoughts and experience!"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);