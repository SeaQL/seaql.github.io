"use strict";(self.webpackChunkseaography=self.webpackChunkseaography||[]).push([[1605],{8032:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(2374);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}},8505:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"access-control/guards","title":"Entity / Field Guards","description":"Entity / Field Guards are part of the lifecycle hooks. Guards can be used to restrict access on models or individual items.","source":"@site/docs/06-access-control/03-guards.md","sourceDirName":"06-access-control","slug":"/access-control/guards","permalink":"/preview/pr-158/Seaography/docs/access-control/guards","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Seaography/docs/06-access-control/03-guards.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1763472397000,"sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Schema Restrictions","permalink":"/preview/pr-158/Seaography/docs/access-control/schema-restrictions"},"next":{"title":"Fine-grained Filters","permalink":"/preview/pr-158/Seaography/docs/access-control/filters"}}');var o=t(8790),a=t(8032);const s={},c="Entity / Field Guards",i={},d=[];function l(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"entity--field-guards",children:"Entity / Field Guards"})}),"\n",(0,o.jsx)(n.p,{children:"Entity / Field Guards are part of the lifecycle hooks. Guards can be used to restrict access on models or individual items."}),"\n",(0,o.jsx)(n.p,{children:"Note that once a guard is triggered, the request will be denied and an error message is returned."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"BuilderContext {\n    hooks: LifecycleHooks::new(AccessControlGuard),\n    ..Default::default()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can define a struct and implement the ",(0,o.jsx)(n.code,{children:"LifecycleHooksInterface"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'struct AccessControlGuard;\n\n#[async_trait::async_trait]\nimpl LifecycleHooksInterface for AccessControlGuard {\n    fn entity_guard(\n        &self,\n        ctx: &ResolverContext,\n        entity: &str,\n        action: OperationType,\n    ) -> GuardAction {\n        match entity {\n            "FilmCategory" => GuardAction::Block(None),\n            _ => GuardAction::Allow,\n        }\n    }\n\n    fn field_guard(\n        &self,\n        ctx: &ResolverContext,\n        entity: &str,\n        field: &str,\n        action: OperationType, // \u2b05 Read, Create, Update, Delete\n    ) -> GuardAction {\n        match (entity, field, action) {\n            // \u2b07 block all access on a field\n            ("Language", "lastUpdate", _) => GuardAction::Block(None),\n            // \u2b07 block only update on a field\n            ("Language", "name", OperationType::Update) => GuardAction::Block(None),\n            // \u2b07 custom logic based on context and object value\n            ("Actor", _, _) => {\n                let permissions = ctx.data::<Permissions>().unwrap();\n                //  \u2b06 extract permission from context\n\n                let Some(actor) = ctx.parent_value.downcast_ref::<actor::Model>() else {\n                    return GuardAction::Block(Some("downcast_ref failed".into()));\n                };\n\n                if permissions.actors.contains(&actor.actor_id) {\n                    // based on context, this user is allowed to access this Actor\n                    GuardAction::Allow\n                } else {\n                    // a custom error message\n                    GuardAction::Block(Some(format!("{action:?} on actor {} denied", actor.actor_id)))\n                }\n            }\n            _ => GuardAction::Allow,\n        }\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"OperationType"})," enum covers CRUD:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"pub enum OperationType {\n    Read,\n    Create,\n    Update,\n    Delete,\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);