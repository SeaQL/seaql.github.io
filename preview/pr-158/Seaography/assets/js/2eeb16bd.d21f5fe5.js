"use strict";(self.webpackChunkseaography=self.webpackChunkseaography||[]).push([[4590],{1322:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"customizations/type-mappings","title":"Type Mappings","description":"Type Names","source":"@site/docs/05-customizations/02-type-mappings.md","sourceDirName":"05-customizations","slug":"/customizations/type-mappings","permalink":"/preview/pr-158/Seaography/docs/customizations/type-mappings","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Seaography/docs/05-customizations/02-type-mappings.md","tags":[],"version":"current","lastUpdatedBy":"Billy Chan","lastUpdatedAt":1763472397000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Field Names","permalink":"/preview/pr-158/Seaography/docs/customizations/field-names"},"next":{"title":"Pagination","permalink":"/preview/pr-158/Seaography/docs/customizations/pagination"}}');var o=t(8790),a=t(8032);const s={},r="Type Mappings",l={},p=[{value:"Type Names",id:"type-names",level:2},{value:"Type Mapping",id:"type-mapping",level:2},{value:"Type Library",id:"type-library",level:3},{value:"Custom Conversion",id:"custom-conversion",level:3},{value:"Filter Type Mappings",id:"filter-type-mappings",level:2},{value:"ILIKE",id:"ilike",level:3},{value:"Timestamp Format",id:"timestamp-format",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"type-mappings",children:"Type Mappings"})}),"\n",(0,o.jsx)(n.h2,{id:"type-names",children:"Type Names"}),"\n",(0,o.jsxs)(n.p,{children:["You can customize the names of various support types via ",(0,o.jsx)(n.code,{children:"BuilderContext"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, the Entity ",(0,o.jsx)(n.code,{children:"Actor"})," has ",(0,o.jsx)(n.code,{children:"ActorInsertInput"})," and ",(0,o.jsx)(n.code,{children:"ActorUpdateInput"})," for insert and update respectively."]}),"\n",(0,o.jsxs)(n.p,{children:["You can customize this suffix using ",(0,o.jsx)(n.code,{children:"EntityInputConfig"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'lazy_static::lazy_static! {\n    static ref CONTEXT : BuilderContext = {\n        BuilderContext {\n            entity_input: EntityInputConfig {\n                insert_suffix: "InsertInput".into(),\n                update_suffix: "UpdateInput".into(),\n                ..Default::default()\n            },\n            ..Default::default()\n        }\n    };\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"You can also customize the type name of connection objects:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'BuilderContext {\n    connection_object: ConnectionObjectConfig {\n        type_name: Box::new(|object_name: &str| -> String {\n            format!("{object_name}Connection")\n        }),\n    },\n    ..Default::default()\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"type-mapping",children:"Type Mapping"}),"\n",(0,o.jsx)(n.h3,{id:"type-library",children:"Type Library"}),"\n",(0,o.jsxs)(n.p,{children:["SeaORM support different libraries for the same column type, there are two supported date time library: ",(0,o.jsx)(n.code,{children:"chrono"})," and ",(0,o.jsx)(n.code,{children:"time"}),", and two supported decimal library ",(0,o.jsx)(n.code,{children:"rust_decimal"})," and ",(0,o.jsx)(n.code,{children:"BigDecimal"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"If your entities uses one over the other, you have to config it accordingly:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"BuilderContext {\n    types: TypesMapConfig {\n        time_library: TimeLibrary::Time | TimeLibrary::Chrono,\n        decimal_library: DecimalLibrary::Decimal | DecimalLibrary::BigDecimal,\n        ..Default::default()\n    },\n    ..Default::default()\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"custom-conversion",children:"Custom Conversion"}),"\n",(0,o.jsx)(n.p,{children:"You can override the type for individual columns, and even use custom functions for input / output conversion:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'BuilderContext {\n    types: TypesMapConfig {\n        column_options: {\n            let mut map = BTreeMap::new();\n            map.insert(\n                EntityColumnId::of::<my_entity::Entity>(&my_entity::Column::MyColumn),\n                ColumnOptions {\n                    /// used to map entity_name.column_name to a custom Type\n                    overwrite: Some(ConvertedType::BigDecimal),\n                    /// used to map entity_name.column_name input to a custom parser\n                    input_conversion: Some(Arc::new(\n                        |value: &ValueAccessor| -> SeaResult<sea_orm::Value> {\n                            Ok(..)\n                        }\n                    )),\n                    /// used to map entity_name.column_name output to a custom formatter\n                    output_conversion: Some(Arc::new(\n                        |value: &sea_orm::Value|\n                            -> async_graphql::Result<Option<async_graphql::dynamic::FieldValue<\'static>>>\n                        {\n                            Ok(..)\n                        }\n                    )),\n                    /// used to override the type of this column in input objects\n                    input_type: Some(TypeRef::STRING),\n                    /// used to override the type of this column in output objects\n                    output_type: Some(TypeRef::named_nn("MyType")),\n                }\n            );\n            map\n        }\n        ..Default::default()\n    },\n    ..Default::default()\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"filter-type-mappings",children:"Filter Type Mappings"}),"\n",(0,o.jsx)(n.p,{children:"You can also customize what operators are available on each data type."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'BuilderContext {\n    filter_types: FilterTypesMapConfig {\n        string_filter_info: FilterInfo {\n            type_name: "StringFilterInput".into(),\n            base_type: TypeRef::STRING.into(),\n            supported_operations: BTreeSet::from([\n                FilterOperation::Equals,\n                FilterOperation::NotEquals,\n                ..\n            ]),\n        },\n        ..Default::default()\n    },\n    ..Default::default()\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"You can override the filter type on individual columns and supply a custom function:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'BuilderContext {\n    filter_types: FilterTypesMapConfig {\n        overwrites: [(\n            EntityColumnId::of::<my_entity::Entity>(&my_entity::Column::MyColumn),\n            Some(FilterType::Custom("MyType".into()))\n        )].into_iter().collect(),\n        condition_functions: [(\n            EntityColumnId::of::<my_entity::Entity>(&my_entity::Column::MyColumn),\n            Box::new(|condition: Condition, object: &ObjectAccessor| -> SeaResult<Condition> {\n                // do something with condition\n                Ok(condition)\n            })\n        )].into_iter().collect(),\n        ..Default::default()\n    },\n    ..Default::default()\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"ilike",children:"ILIKE"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"BuilderContext {\n    entity_query_field: EntityQueryFieldConfig {\n        use_ilike: true,\n        ..Default::default()\n    },\n    ..Default::default()\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This enables the ",(0,o.jsx)(n.code,{children:"ilike"})," operator."]}),"\n",(0,o.jsx)(n.h2,{id:"timestamp-format",children:"Timestamp Format"}),"\n",(0,o.jsx)(n.p,{children:"You can turn on this option to use ISO format for timestamps:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"BuilderContext {\n    types: TypesMapConfig {\n        timestamp_rfc3339: true,\n        ..Default::default()\n    },\n    ..Default::default()\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Query:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"{\n    film(filters:{filmId: {eq: 1}}) {\n      nodes {\n        title\n        lastUpdate\n      }\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Result:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "film": {\n    "nodes": [\n      {\n        "title": "ACADEMY DINOSAUR",\n        "lastUpdate": "2022-11-14T10:30:09+00:00"\n      }\n    ]\n  }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8032:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(2374);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);