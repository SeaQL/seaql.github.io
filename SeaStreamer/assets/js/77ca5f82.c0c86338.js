"use strict";(self.webpackChunksea_streamer=self.webpackChunksea_streamer||[]).push([[382],{6484:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>c});var r=t(2374);const o={},n=r.createContext(o);function a(e){const s=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(n.Provider,{value:s},e.children)}},8574:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"processors/intra-process","title":"Intra Process","description":"Here is how you might organize a mid-to-large scale stream processing project. You have a number of crates implementing different processors, each depends on sea-streamer in a workspace. Now, you want to construct a downstream crate where you connect several processors together for testing.","source":"@site/versioned_docs/version-0.2.x/04-processors/02-intra-process.md","sourceDirName":"04-processors","slug":"/processors/intra-process","permalink":"/SeaStreamer/docs/0.2.x/processors/intra-process","draft":false,"unlisted":false,"editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/SeaStreamer/versioned_docs/version-0.2.x/04-processors/02-intra-process.md","tags":[],"version":"0.2.x","lastUpdatedBy":"Chris Tsang","lastUpdatedAt":1749809804000,"sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Inter Process","permalink":"/SeaStreamer/docs/0.2.x/processors/inter-process"},"next":{"title":"The Roadmap","permalink":"/SeaStreamer/docs/0.2.x/whats-next/roadmap"}}');var o=t(8790),n=t(6484);const a={},c="Intra Process",i={},l=[];function d(e){const s={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"intra-process",children:"Intra Process"})}),"\n",(0,o.jsxs)(s.p,{children:["Here is how you might organize a mid-to-large scale stream processing project. You have a number of crates implementing different processors, each depends on ",(0,o.jsx)(s.code,{children:"sea-streamer"})," in a workspace. Now, you want to construct a downstream crate where you connect several processors together for testing."]}),"\n",(0,o.jsxs)(s.p,{children:["You can execute tests involving several processors by setting Stdio's ",(0,o.jsx)(s.a,{href:"https://docs.rs/sea-streamer-stdio/*/sea_streamer_stdio/struct.StdioConnectOptions.html#method.set_loopback",children:"loopback"})," option, where messages produced will be feed back to consumers in the same process."]}),"\n",(0,o.jsxs)(s.p,{children:["Here is an illustration of the behaviour, you can check out the ",(0,o.jsx)(s.a,{href:"https://github.com/SeaQL/sea-streamer/blob/main/sea-streamer-stdio/tests/loopback.rs",children:"full example"}),". It's just ",(0,o.jsx)(s.code,{children:"cargo test"})," without any prerequisite. If the tests fail, you will be able to diagnose the problem from the stdout log."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-rust",children:'let stream = StreamKey::new("hello")?;\nlet mut options = StdioConnectOptions::default();\noptions.set_loopback(true);\nlet streamer = StdioStreamer::connect(StreamerUri::zero(), options).await?;\nlet producer = streamer.create_producer(stream.clone(), Default::default()).await?;\nlet mut consumer = streamer.create_consumer(&[stream.clone()], Default::default()).await?;\n\nfor i in 0..5 {\n    let mess = format!("{}", i);\n    producer.send(mess)?;\n}\n\nlet seq = collect(&mut consumer, 5).await;\nassert_eq!(seq, [0, 1, 2, 3, 4]);\n'})})]})}function p(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);