<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An abstract base class for defining Entities."><title>EntityTrait in sea_orm::entity - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="sea_orm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">EntityTrait</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../sea_orm/index.html"><img src="https://raw.githubusercontent.com/SeaQL/sea-query/master/docs/SeaQL icon dark.png" alt="logo"></a><h2><a href="../../sea_orm/index.html">sea_orm</a><span class="version">2.0.0-rc.32</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Entity<wbr>Trait</a></h2><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.ActiveModel" title="ActiveModel">ActiveModel</a></li><li><a href="#associatedtype.ActiveModelEx" title="ActiveModelEx">ActiveModelEx</a></li><li><a href="#associatedtype.Column" title="Column">Column</a></li><li><a href="#associatedtype.Model" title="Model">Model</a></li><li><a href="#associatedtype.ModelEx" title="ModelEx">ModelEx</a></li><li><a href="#associatedtype.PrimaryKey" title="PrimaryKey">PrimaryKey</a></li><li><a href="#associatedtype.Relation" title="Relation">Relation</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.belongs_to" title="belongs_to">belongs_to</a></li><li><a href="#method.column_tuple_in" title="column_tuple_in">column_tuple_in</a></li><li><a href="#method.delete" title="delete">delete</a></li><li><a href="#method.delete_by_id" title="delete_by_id">delete_by_id</a></li><li><a href="#method.delete_many" title="delete_many">delete_many</a></li><li><a href="#method.find" title="find">find</a></li><li><a href="#method.find_by_id" title="find_by_id">find_by_id</a></li><li><a href="#method.has_many" title="has_many">has_many</a></li><li><a href="#method.has_many_via" title="has_many_via">has_many_via</a></li><li><a href="#method.has_one" title="has_one">has_one</a></li><li><a href="#method.insert" title="insert">insert</a></li><li><a href="#method.insert_many" title="insert_many">insert_many</a></li><li><a href="#method.primary_key_identity" title="primary_key_identity">primary_key_identity</a></li><li><a href="#method.update" title="update">update</a></li><li><a href="#method.update_many" title="update_many">update_many</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In sea_<wbr>orm::<wbr>entity</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">sea_orm</a>::<wbr><a href="index.html">entity</a></div><h1>Trait <span class="trait">Entity<wbr>Trait</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub trait EntityTrait: <a class="trait" href="trait.EntityName.html" title="trait sea_orm::entity::EntityName">EntityName</a> {
    type <a href="#associatedtype.Model" class="associatedtype">Model</a>: <a class="trait" href="trait.ModelTrait.html" title="trait sea_orm::entity::ModelTrait">ModelTrait</a>&lt;Entity = Self&gt; + <a class="trait" href="trait.FromQueryResult.html" title="trait sea_orm::entity::FromQueryResult">FromQueryResult</a>;
    type <a href="#associatedtype.ModelEx" class="associatedtype">ModelEx</a>: <a class="trait" href="trait.ModelTrait.html" title="trait sea_orm::entity::ModelTrait">ModelTrait</a>&lt;Entity = Self&gt;;
    type <a href="#associatedtype.ActiveModel" class="associatedtype">ActiveModel</a>: <a class="trait" href="trait.ActiveModelBehavior.html" title="trait sea_orm::entity::ActiveModelBehavior">ActiveModelBehavior</a>&lt;Entity = Self&gt;;
    type <a href="#associatedtype.ActiveModelEx" class="associatedtype">ActiveModelEx</a>: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;;
    type <a href="#associatedtype.Column" class="associatedtype">Column</a>: <a class="trait" href="trait.ColumnTrait.html" title="trait sea_orm::entity::ColumnTrait">ColumnTrait</a>;
    type <a href="#associatedtype.Relation" class="associatedtype">Relation</a>: <a class="trait" href="trait.RelationTrait.html" title="trait sea_orm::entity::RelationTrait">RelationTrait</a>;
    type <a href="#associatedtype.PrimaryKey" class="associatedtype">PrimaryKey</a>: <a class="trait" href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait">PrimaryKeyTrait</a> + <a class="trait" href="trait.PrimaryKeyToColumn.html" title="trait sea_orm::entity::PrimaryKeyToColumn">PrimaryKeyToColumn</a>&lt;Column = Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.Column" title="type sea_orm::entity::EntityTrait::Column">Column</a>&gt;;

<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 15 methods</span></summary>    // Provided methods
    fn <a href="#method.belongs_to" class="fn">belongs_to</a>&lt;R&gt;(related: R) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;
       <span class="where">where R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.has_one" class="fn">has_one</a>&lt;R&gt;(_: R) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;
       <span class="where">where R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a> + <a class="trait" href="trait.Related.html" title="trait sea_orm::entity::Related">Related</a>&lt;Self&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.has_many" class="fn">has_many</a>&lt;R&gt;(_: R) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;
       <span class="where">where R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a> + <a class="trait" href="trait.Related.html" title="trait sea_orm::entity::Related">Related</a>&lt;Self&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.has_many_via" class="fn">has_many_via</a>&lt;R, T&gt;(_: R, rel: T) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;
       <span class="where">where R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a>,
             T: <a class="trait" href="trait.RelationTrait.html" title="trait sea_orm::entity::RelationTrait">RelationTrait</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.find" class="fn">find</a>() -&gt; <a class="struct" href="../query/struct.Select.html" title="struct sea_orm::query::Select">Select</a>&lt;Self&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_by_id" class="fn">find_by_id</a>&lt;T&gt;(values: T) -&gt; <a class="struct" href="../query/struct.Select.html" title="struct sea_orm::query::Select">Select</a>&lt;Self&gt;
       <span class="where">where T: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;&lt;Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.PrimaryKey" title="type sea_orm::entity::EntityTrait::PrimaryKey">PrimaryKey</a> as <a class="trait" href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait">PrimaryKeyTrait</a>&gt;::<a class="associatedtype" href="trait.PrimaryKeyTrait.html#associatedtype.ValueType" title="type sea_orm::entity::PrimaryKeyTrait::ValueType">ValueType</a>&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.primary_key_identity" class="fn">primary_key_identity</a>() -&gt; <a class="enum" href="enum.Identity.html" title="enum sea_orm::entity::Identity">Identity</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.column_tuple_in" class="fn">column_tuple_in</a>&lt;I&gt;(
        columns: I,
        values: &amp;[<a class="enum" href="../../sea_query/value/value_tuple/enum.ValueTuple.html" title="enum sea_query::value::value_tuple::ValueTuple">ValueTuple</a>],
        db_backend: <a class="type" href="../type.DbBackend.html" title="type sea_orm::DbBackend">DbBackend</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.92.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../query/struct.Condition.html" title="struct sea_orm::query::Condition">Condition</a>, <a class="enum" href="../error/enum.DbErr.html" title="enum sea_orm::error::DbErr">DbErr</a>&gt;
       <span class="where">where I: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.Column" title="type sea_orm::entity::EntityTrait::Column">Column</a>&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.insert" class="fn">insert</a>&lt;A&gt;(model: A) -&gt; <a class="struct" href="../query/struct.Insert.html" title="struct sea_orm::query::Insert">Insert</a>&lt;A&gt;
       <span class="where">where A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.insert_many" class="fn">insert_many</a>&lt;A, I&gt;(models: I) -&gt; <a class="struct" href="../query/struct.InsertMany.html" title="struct sea_orm::query::InsertMany">InsertMany</a>&lt;A&gt;
       <span class="where">where A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;,
             I: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = A&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.update" class="fn">update</a>&lt;A&gt;(model: A) -&gt; <a class="struct" href="../query/struct.UpdateOne.html" title="struct sea_orm::query::UpdateOne">UpdateOne</a>&lt;A&gt;
       <span class="where">where A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.update_many" class="fn">update_many</a>() -&gt; <a class="struct" href="../query/struct.UpdateMany.html" title="struct sea_orm::query::UpdateMany">UpdateMany</a>&lt;Self&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.delete" class="fn">delete</a>&lt;A&gt;(model: A) -&gt; <a class="struct" href="../query/struct.DeleteOne.html" title="struct sea_orm::query::DeleteOne">DeleteOne</a>&lt;Self&gt;
       <span class="where">where A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.delete_many" class="fn">delete_many</a>() -&gt; <a class="struct" href="../query/struct.DeleteMany.html" title="struct sea_orm::query::DeleteMany">DeleteMany</a>&lt;Self&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.delete_by_id" class="fn">delete_by_id</a>&lt;T&gt;(values: T) -&gt; <a class="struct" href="../query/struct.ValidatedDeleteOne.html" title="struct sea_orm::query::ValidatedDeleteOne">ValidatedDeleteOne</a>&lt;Self&gt;
       <span class="where">where T: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;&lt;Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.PrimaryKey" title="type sea_orm::entity::EntityTrait::PrimaryKey">PrimaryKey</a> as <a class="trait" href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait">PrimaryKeyTrait</a>&gt;::<a class="associatedtype" href="trait.PrimaryKeyTrait.html#associatedtype.ValueType" title="type sea_orm::entity::PrimaryKeyTrait::ValueType">ValueType</a>&gt;</span> { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An abstract base class for defining Entities.</p>
<p>This trait provides an API for you to inspect it’s properties</p>
<ul>
<li>Column (implemented <a href="trait.ColumnTrait.html" title="trait sea_orm::entity::ColumnTrait"><code>ColumnTrait</code></a>)</li>
<li>Relation (implemented <a href="trait.RelationTrait.html" title="trait sea_orm::entity::RelationTrait"><code>RelationTrait</code></a>)</li>
<li>Primary Key (implemented <a href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait"><code>PrimaryKeyTrait</code></a> and <a href="trait.PrimaryKeyToColumn.html" title="trait sea_orm::entity::PrimaryKeyToColumn"><code>PrimaryKeyToColumn</code></a>)</li>
</ul>
<p>This trait also provides an API for CRUD actions</p>
<ul>
<li>Select: <code>find</code>, <code>find_*</code></li>
<li>Insert: <code>insert</code>, <code>insert_*</code></li>
<li>Update: <code>update</code>, <code>update_*</code></li>
<li>Delete: <code>delete</code>, <code>delete_*</code></li>
</ul>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><section id="associatedtype.Model" class="method"><h4 class="code-header">type <a href="#associatedtype.Model" class="associatedtype">Model</a>: <a class="trait" href="trait.ModelTrait.html" title="trait sea_orm::entity::ModelTrait">ModelTrait</a>&lt;Entity = Self&gt; + <a class="trait" href="trait.FromQueryResult.html" title="trait sea_orm::entity::FromQueryResult">FromQueryResult</a></h4></section><section id="associatedtype.ModelEx" class="method"><h4 class="code-header">type <a href="#associatedtype.ModelEx" class="associatedtype">ModelEx</a>: <a class="trait" href="trait.ModelTrait.html" title="trait sea_orm::entity::ModelTrait">ModelTrait</a>&lt;Entity = Self&gt;</h4></section><section id="associatedtype.ActiveModel" class="method"><h4 class="code-header">type <a href="#associatedtype.ActiveModel" class="associatedtype">ActiveModel</a>: <a class="trait" href="trait.ActiveModelBehavior.html" title="trait sea_orm::entity::ActiveModelBehavior">ActiveModelBehavior</a>&lt;Entity = Self&gt;</h4></section><section id="associatedtype.ActiveModelEx" class="method"><h4 class="code-header">type <a href="#associatedtype.ActiveModelEx" class="associatedtype">ActiveModelEx</a>: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;</h4></section><section id="associatedtype.Column" class="method"><h4 class="code-header">type <a href="#associatedtype.Column" class="associatedtype">Column</a>: <a class="trait" href="trait.ColumnTrait.html" title="trait sea_orm::entity::ColumnTrait">ColumnTrait</a></h4></section><section id="associatedtype.Relation" class="method"><h4 class="code-header">type <a href="#associatedtype.Relation" class="associatedtype">Relation</a>: <a class="trait" href="trait.RelationTrait.html" title="trait sea_orm::entity::RelationTrait">RelationTrait</a></h4></section><section id="associatedtype.PrimaryKey" class="method"><h4 class="code-header">type <a href="#associatedtype.PrimaryKey" class="associatedtype">PrimaryKey</a>: <a class="trait" href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait">PrimaryKeyTrait</a> + <a class="trait" href="trait.PrimaryKeyToColumn.html" title="trait sea_orm::entity::PrimaryKeyToColumn">PrimaryKeyToColumn</a>&lt;Column = Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.Column" title="type sea_orm::entity::EntityTrait::Column">Column</a>&gt;</h4></section></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.belongs_to" class="method"><h4 class="code-header">fn <a href="#method.belongs_to" class="fn">belongs_to</a>&lt;R&gt;(related: R) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;<div class="where">where
    R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a>,</div></h4></section></summary><div class="docblock"><p>Construct a belongs to relation, where this table has a foreign key to
another table.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_one" class="method"><h4 class="code-header">fn <a href="#method.has_one" class="fn">has_one</a>&lt;R&gt;(_: R) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;<div class="where">where
    R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a> + <a class="trait" href="trait.Related.html" title="trait sea_orm::entity::Related">Related</a>&lt;Self&gt;,</div></h4></section></summary><div class="docblock"><p>Construct a has one relation</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_many" class="method"><h4 class="code-header">fn <a href="#method.has_many" class="fn">has_many</a>&lt;R&gt;(_: R) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;<div class="where">where
    R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a> + <a class="trait" href="trait.Related.html" title="trait sea_orm::entity::Related">Related</a>&lt;Self&gt;,</div></h4></section></summary><div class="docblock"><p>Construct a has many relation</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_many_via" class="method"><h4 class="code-header">fn <a href="#method.has_many_via" class="fn">has_many_via</a>&lt;R, T&gt;(_: R, rel: T) -&gt; <a class="struct" href="struct.RelationBuilder.html" title="struct sea_orm::entity::RelationBuilder">RelationBuilder</a>&lt;Self, R&gt;<div class="where">where
    R: <a class="trait" href="trait.EntityTrait.html" title="trait sea_orm::entity::EntityTrait">EntityTrait</a>,
    T: <a class="trait" href="trait.RelationTrait.html" title="trait sea_orm::entity::RelationTrait">RelationTrait</a>,</div></h4></section></summary><div class="docblock"><p>Construct a has many relation, with the Relation provided.
This is for the case where <code>Related&lt;Self&gt;</code> is not possible.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><h4 class="code-header">fn <a href="#method.find" class="fn">find</a>() -&gt; <a class="struct" href="../query/struct.Select.html" title="struct sea_orm::query::Select">Select</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Construct select statement to find one / all models</p>
<ul>
<li>To select columns, join tables and group by expressions, see <a href="../query/trait.QuerySelect.html" title="trait sea_orm::query::QuerySelect"><code>QuerySelect</code></a></li>
<li>To apply where conditions / filters, see <a href="../query/trait.QueryFilter.html" title="trait sea_orm::query::QueryFilter"><code>QueryFilter</code></a></li>
<li>To apply order by expressions, see <a href="../query/trait.QueryOrder.html" title="trait sea_orm::query::QueryOrder"><code>QueryOrder</code></a></li>
</ul>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake};

<span class="macro">assert_eq!</span>(
    cake::Entity::find().one(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>,
    <span class="prelude-val">Some</span>(cake::Model {
        id: <span class="number">1</span>,
        name: <span class="string">"New York Cheese"</span>.to_owned(),
    })
);

<span class="macro">assert_eq!</span>(
    cake::Entity::find().all(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>,
    [
        cake::Model {
            id: <span class="number">1</span>,
            name: <span class="string">"New York Cheese"</span>.to_owned(),
        },
        cake::Model {
            id: <span class="number">2</span>,
            name: <span class="string">"Chocolate Forest"</span>.to_owned(),
        },
    ]
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [
        Transaction::from_sql_and_values(
            DbBackend::Postgres,
            <span class="string">r#"SELECT "cake"."id", "cake"."name" FROM "cake" LIMIT $1"#</span>,
            [<span class="number">1u64</span>.into()]
        ),
        Transaction::from_sql_and_values(
            DbBackend::Postgres,
            <span class="string">r#"SELECT "cake"."id", "cake"."name" FROM "cake""#</span>,
            []
        ),
    ]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.find_by_id" class="method"><h4 class="code-header">fn <a href="#method.find_by_id" class="fn">find_by_id</a>&lt;T&gt;(values: T) -&gt; <a class="struct" href="../query/struct.Select.html" title="struct sea_orm::query::Select">Select</a>&lt;Self&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;&lt;Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.PrimaryKey" title="type sea_orm::entity::EntityTrait::PrimaryKey">PrimaryKey</a> as <a class="trait" href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait">PrimaryKeyTrait</a>&gt;::<a class="associatedtype" href="trait.PrimaryKeyTrait.html#associatedtype.ValueType" title="type sea_orm::entity::PrimaryKeyTrait::ValueType">ValueType</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Find a model by primary key</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake};

<span class="macro">assert_eq!</span>(
    cake::Entity::find_by_id(<span class="number">11</span>).all(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>,
    [cake::Model {
        id: <span class="number">11</span>,
        name: <span class="string">"Sponge Cake"</span>.to_owned(),
    }]
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"SELECT "cake"."id", "cake"."name" FROM "cake" WHERE "cake"."id" = $1"#</span>,
        [<span class="number">11i32</span>.into()]
    )]
);</code></pre></div>
<p>Find by composite key</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake_filling};

<span class="macro">assert_eq!</span>(
    cake_filling::Entity::find_by_id((<span class="number">2</span>, <span class="number">3</span>)).all(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>,
    [cake_filling::Model {
        cake_id: <span class="number">2</span>,
        filling_id: <span class="number">3</span>,
    }]
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        [
            <span class="string">r#"SELECT "cake_filling"."cake_id", "cake_filling"."filling_id" FROM "cake_filling""#</span>,
            <span class="string">r#"WHERE "cake_filling"."cake_id" = $1 AND "cake_filling"."filling_id" = $2"#</span>,
        ].join(<span class="string">" "</span>).as_str(),
        [<span class="number">2i32</span>.into(), <span class="number">3i32</span>.into()]
    )]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.primary_key_identity" class="method"><h4 class="code-header">fn <a href="#method.primary_key_identity" class="fn">primary_key_identity</a>() -&gt; <a class="enum" href="enum.Identity.html" title="enum sea_orm::entity::Identity">Identity</a></h4></section></summary><div class="docblock"><p>Get primary key as Identity</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.column_tuple_in" class="method"><h4 class="code-header">fn <a href="#method.column_tuple_in" class="fn">column_tuple_in</a>&lt;I&gt;(
    columns: I,
    values: &amp;[<a class="enum" href="../../sea_query/value/value_tuple/enum.ValueTuple.html" title="enum sea_query::value::value_tuple::ValueTuple">ValueTuple</a>],
    db_backend: <a class="type" href="../type.DbBackend.html" title="type sea_orm::DbBackend">DbBackend</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.92.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../query/struct.Condition.html" title="struct sea_orm::query::Condition">Condition</a>, <a class="enum" href="../error/enum.DbErr.html" title="enum sea_orm::error::DbErr">DbErr</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.Column" title="type sea_orm::entity::EntityTrait::Column">Column</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Construct a <code>WHERE (c1, c2, ...) IN ((v11, v12, ...), ...)</code> condition
for arbitrary columns and value tuples.</p>
<p>For databases that don’t support tuple value syntax (MSSQL, and SQLite
before 3.15 when the <code>sqlite-no-row-value-before-3_15</code> feature is
enabled), this automatically falls back to an equivalent
<code>(c1 = v11 AND c2 = v12) OR (c1 = v21 AND c2 = v22) ...</code> expression.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake, DbBackend};
<span class="kw">use </span>sea_query::IntoValueTuple;

<span class="macro">assert_eq!</span>(
    cake::Entity::find()
        .filter(cake::Entity::column_tuple_in(
            [cake::Column::Id, cake::Column::Name],
            <span class="kw-2">&amp;</span>[(<span class="number">1i32</span>, <span class="string">"a"</span>).into_value_tuple(), (<span class="number">2i32</span>, <span class="string">"b"</span>).into_value_tuple()],
            DbBackend::MySql,
        ).unwrap())
        .build(DbBackend::MySql)
        .to_string(),
    <span class="string">"SELECT `cake`.`id`, `cake`.`name` FROM `cake` WHERE (`cake`.`id`, `cake`.`name`) IN ((1, 'a'), (2, 'b'))"
</span>);
<span class="macro">assert_eq!</span>(
    cake::Entity::find()
        .filter(cake::Entity::column_tuple_in(
            [cake::Column::Id, cake::Column::Name],
            <span class="kw-2">&amp;</span>[(<span class="number">1i32</span>, <span class="string">"a"</span>).into_value_tuple(), (<span class="number">2i32</span>, <span class="string">"b"</span>).into_value_tuple()],
            DbBackend::MsSql,
        ).unwrap())
        .build(DbBackend::MsSql)
        .to_string(),
    <span class="string">"SELECT [cake].[id], [cake].[name] FROM [cake] WHERE ([cake].[id] = 1 AND [cake].[name] = 'a') OR ([cake].[id] = 2 AND [cake].[name] = 'b')"
</span>);</code></pre></div>
<p>Return <code>DbErr::Type</code> if <code>columns</code> is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><h4 class="code-header">fn <a href="#method.insert" class="fn">insert</a>&lt;A&gt;(model: A) -&gt; <a class="struct" href="../query/struct.Insert.html" title="struct sea_orm::query::Insert">Insert</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;,</div></h4></section></summary><div class="docblock"><p>Insert a model into database</p>
<h5 id="example-postgres"><a class="doc-anchor" href="#example-postgres">§</a>Example (Postgres)</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake};

<span class="kw">let </span>apple = cake::ActiveModel {
    name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
    ..Default::default()
};

<span class="kw">let </span>insert_result = cake::Entity::insert(apple).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="macro">dbg!</span>(insert_result.last_insert_id), <span class="number">15</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"INSERT INTO "cake" ("name") VALUES ($1) RETURNING "id""#</span>,
        [<span class="string">"Apple Pie"</span>.into()]
    )]
);</code></pre></div><h5 id="example-mysql"><a class="doc-anchor" href="#example-mysql">§</a>Example (MySQL)</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake};

<span class="kw">let </span>apple = cake::ActiveModel {
    name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
    ..Default::default()
};

<span class="kw">let </span>insert_result = cake::Entity::insert(apple).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(insert_result.last_insert_id, <span class="number">15</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::MySql,
        <span class="string">r#"INSERT INTO `cake` (`name`) VALUES (?)"#</span>,
        [<span class="string">"Apple Pie"</span>.into()]
    )]
);</code></pre></div>
<p>To get back inserted Model</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="macro">assert_eq!</span>(
    cake::Entity::insert(cake::ActiveModel {
        id: NotSet,
        name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
    })
    .exec_with_returning(<span class="kw-2">&amp;</span>db)
    .<span class="kw">await</span><span class="question-mark">?</span>,
    cake::Model {
        id: <span class="number">1</span>,
        name: <span class="string">"Apple Pie"</span>.to_owned(),
    }
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log()[<span class="number">0</span>].statements()[<span class="number">0</span>].sql,
    <span class="string">r#"INSERT INTO "cake" ("name") VALUES ($1) RETURNING "id", "name""#
</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.insert_many" class="method"><h4 class="code-header">fn <a href="#method.insert_many" class="fn">insert_many</a>&lt;A, I&gt;(models: I) -&gt; <a class="struct" href="../query/struct.InsertMany.html" title="struct sea_orm::query::InsertMany">InsertMany</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;,
    I: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = A&gt;,</div></h4></section></summary><div class="docblock"><p>Insert many models into database</p>
<h5 id="example-postgres-1"><a class="doc-anchor" href="#example-postgres-1">§</a>Example (Postgres)</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake};

<span class="kw">let </span>apple = cake::ActiveModel {
    name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
    ..Default::default()
};
<span class="kw">let </span>orange = cake::ActiveModel {
    name: Set(<span class="string">"Orange Scone"</span>.to_owned()),
    ..Default::default()
};

<span class="kw">let </span>insert_result = cake::Entity::insert_many::&lt;cake::ActiveModel, <span class="kw">_</span>&gt;([])
    .exec(<span class="kw-2">&amp;</span>db)
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(insert_result.last_insert_id, <span class="prelude-val">None</span>);

<span class="kw">let </span>insert_result = cake::Entity::insert_many([apple, orange]).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(insert_result.last_insert_id, <span class="prelude-val">Some</span>(<span class="number">28</span>));

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"INSERT INTO "cake" ("name") VALUES ($1), ($2) RETURNING "id""#</span>,
        [<span class="string">"Apple Pie"</span>.into(), <span class="string">"Orange Scone"</span>.into()]
    )]
);</code></pre></div><h5 id="example-mysql-1"><a class="doc-anchor" href="#example-mysql-1">§</a>Example (MySQL)</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake};

<span class="kw">let </span>apple = cake::ActiveModel {
    name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
    ..Default::default()
};
<span class="kw">let </span>orange = cake::ActiveModel {
    name: Set(<span class="string">"Orange Scone"</span>.to_owned()),
    ..Default::default()
};

<span class="kw">let </span>insert_result = cake::Entity::insert_many([apple, orange]).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(insert_result.last_insert_id, <span class="prelude-val">Some</span>(<span class="number">28</span>));

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::MySql,
        <span class="string">r#"INSERT INTO `cake` (`name`) VALUES (?), (?)"#</span>,
        [<span class="string">"Apple Pie"</span>.into(), <span class="string">"Orange Scone"</span>.into()]
    )]
);</code></pre></div>
<p>Before 1.1.3, if the active models have different column set, this method would panic.
Now, it’d attempt to fill in the missing columns with null
(which may or may not be correct, depending on whether the column is nullable):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{
    DbBackend,
    entity::<span class="kw-2">*</span>,
    query::<span class="kw-2">*</span>,
    tests_cfg::{cake, cake_filling},
};

<span class="macro">assert_eq!</span>(
    cake::Entity::insert_many([
        cake::ActiveModel {
            id: NotSet,
            name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
        },
        cake::ActiveModel {
            id: NotSet,
            name: Set(<span class="string">"Orange Scone"</span>.to_owned()),
        }
    ])
    .build(DbBackend::Postgres)
    .to_string(),
    <span class="string">r#"INSERT INTO "cake" ("name") VALUES ('Apple Pie'), ('Orange Scone')"#</span>,
);

<span class="macro">assert_eq!</span>(
    cake_filling::Entity::insert_many([
        cake_filling::ActiveModel {
            cake_id: ActiveValue::set(<span class="number">2</span>),
            filling_id: ActiveValue::NotSet,
        },
        cake_filling::ActiveModel {
            cake_id: ActiveValue::NotSet,
            filling_id: ActiveValue::set(<span class="number">3</span>),
        }
    ])
    .build(DbBackend::Postgres)
    .to_string(),
    <span class="string">r#"INSERT INTO "cake_filling" ("cake_id", "filling_id") VALUES (2, NULL), (NULL, 3)"#</span>,
);</code></pre></div>
<p>To get back inserted Models</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="macro">assert_eq!</span>(
    cake::Entity::insert_many([
        cake::ActiveModel {
            id: NotSet,
            name: Set(<span class="string">"Apple Pie"</span>.to_owned()),
        },
        cake::ActiveModel {
            id: NotSet,
            name: Set(<span class="string">"Choco Pie"</span>.to_owned()),
        },
    ])
    .exec_with_returning(<span class="kw-2">&amp;</span>db)
    .<span class="kw">await</span><span class="question-mark">?</span>,
    [
        cake::Model {
            id: <span class="number">1</span>,
            name: <span class="string">"Apple Pie"</span>.to_owned(),
        },
        cake::Model {
            id: <span class="number">2</span>,
            name: <span class="string">"Choco Pie"</span>.to_owned(),
        }
    ]
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log()[<span class="number">0</span>].statements()[<span class="number">0</span>].sql,
    <span class="string">r#"INSERT INTO "cake" ("name") VALUES ($1), ($2) RETURNING "id", "name""#
</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.update" class="method"><h4 class="code-header">fn <a href="#method.update" class="fn">update</a>&lt;A&gt;(model: A) -&gt; <a class="struct" href="../query/struct.UpdateOne.html" title="struct sea_orm::query::UpdateOne">UpdateOne</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;,</div></h4></section></summary><div class="docblock"><p>Update a model in database</p>
<ul>
<li>To apply where conditions / filters, see <a href="../query/trait.QueryFilter.html" title="trait sea_orm::query::QueryFilter"><code>QueryFilter</code></a></li>
</ul>
<h5 id="example-postgres-2"><a class="doc-anchor" href="#example-postgres-2">§</a>Example (Postgres)</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="kw">let </span>orange = fruit::ActiveModel {
    id: Set(<span class="number">1</span>),
    name: Set(<span class="string">"Orange"</span>.to_owned()),
    ..Default::default()
};

<span class="macro">assert_eq!</span>(
    fruit::Entity::update(orange.clone())
        .validate()<span class="question-mark">?
        </span>.filter(fruit::Column::Name.contains(<span class="string">"orange"</span>))
        .exec(<span class="kw-2">&amp;</span>db)
        .<span class="kw">await</span><span class="question-mark">?</span>,
    fruit::Model {
        id: <span class="number">1</span>,
        name: <span class="string">"Orange"</span>.to_owned(),
        cake_id: <span class="prelude-val">None</span>,
    }
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"UPDATE "fruit" SET "name" = $1 WHERE "fruit"."id" = $2 AND "fruit"."name" LIKE $3 RETURNING "id", "name", "cake_id""#</span>,
        [<span class="string">"Orange"</span>.into(), <span class="number">1i32</span>.into(), <span class="string">"%orange%"</span>.into()]
    )]);</code></pre></div><h5 id="example-mysql-2"><a class="doc-anchor" href="#example-mysql-2">§</a>Example (MySQL)</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="kw">let </span>orange = fruit::ActiveModel {
    id: Set(<span class="number">1</span>),
    name: Set(<span class="string">"Orange"</span>.to_owned()),
    ..Default::default()
};

<span class="macro">assert_eq!</span>(
    fruit::Entity::update(orange.clone())
        .validate()<span class="question-mark">?
        </span>.filter(fruit::Column::Name.contains(<span class="string">"orange"</span>))
        .exec(<span class="kw-2">&amp;</span>db)
        .<span class="kw">await</span><span class="question-mark">?</span>,
    fruit::Model {
        id: <span class="number">1</span>,
        name: <span class="string">"Orange"</span>.to_owned(),
        cake_id: <span class="prelude-val">None</span>,
    }
);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [
        Transaction::from_sql_and_values(
            DbBackend::MySql,
            <span class="string">r#"UPDATE `fruit` SET `name` = ? WHERE `fruit`.`id` = ? AND `fruit`.`name` LIKE ?"#</span>,
            [<span class="string">"Orange"</span>.into(), <span class="number">1i32</span>.into(), <span class="string">"%orange%"</span>.into()]
        ),
        Transaction::from_sql_and_values(
            DbBackend::MySql,
            <span class="string">r#"SELECT `fruit`.`id`, `fruit`.`name`, `fruit`.`cake_id` FROM `fruit` WHERE `fruit`.`id` = ? LIMIT ?"#</span>,
            [<span class="number">1i32</span>.into(), <span class="number">1u64</span>.into()]
        )]);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.update_many" class="method"><h4 class="code-header">fn <a href="#method.update_many" class="fn">update_many</a>() -&gt; <a class="struct" href="../query/struct.UpdateMany.html" title="struct sea_orm::query::UpdateMany">UpdateMany</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Update many models in database</p>
<ul>
<li>To apply where conditions / filters, see <a href="../query/trait.QueryFilter.html" title="trait sea_orm::query::QueryFilter"><code>QueryFilter</code></a></li>
</ul>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{
    entity::<span class="kw-2">*</span>,
    query::<span class="kw-2">*</span>,
    sea_query::{Expr, Value},
    tests_cfg::fruit,
};

<span class="kw">let </span>update_result = fruit::Entity::update_many()
    .col_expr(fruit::Column::CakeId, Expr::value(Value::Int(<span class="prelude-val">None</span>)))
    .filter(fruit::Column::Name.contains(<span class="string">"Apple"</span>))
    .exec(<span class="kw-2">&amp;</span>db)
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(update_result.rows_affected, <span class="number">5</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"UPDATE "fruit" SET "cake_id" = $1 WHERE "fruit"."name" LIKE $2"#</span>,
        [Value::Int(<span class="prelude-val">None</span>), <span class="string">"%Apple%"</span>.into()]
    )]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.delete" class="method"><h4 class="code-header">fn <a href="#method.delete" class="fn">delete</a>&lt;A&gt;(model: A) -&gt; <a class="struct" href="../query/struct.DeleteOne.html" title="struct sea_orm::query::DeleteOne">DeleteOne</a>&lt;Self&gt;<div class="where">where
    A: <a class="trait" href="trait.ActiveModelTrait.html" title="trait sea_orm::entity::ActiveModelTrait">ActiveModelTrait</a>&lt;Entity = Self&gt;,</div></h4></section></summary><div class="docblock"><p>Delete a model from database</p>
<ul>
<li>To apply where conditions / filters, see <a href="../query/trait.QueryFilter.html" title="trait sea_orm::query::QueryFilter"><code>QueryFilter</code></a></li>
</ul>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="kw">let </span>orange = fruit::ActiveModel {
    id: Set(<span class="number">3</span>),
    ..Default::default()
};

<span class="kw">let </span>delete_result = fruit::Entity::delete(orange).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(delete_result.rows_affected, <span class="number">1</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"DELETE FROM "fruit" WHERE "fruit"."id" = $1"#</span>,
        [<span class="number">3i32</span>.into()]
    )]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.delete_many" class="method"><h4 class="code-header">fn <a href="#method.delete_many" class="fn">delete_many</a>() -&gt; <a class="struct" href="../query/struct.DeleteMany.html" title="struct sea_orm::query::DeleteMany">DeleteMany</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Delete many models from database</p>
<ul>
<li>To apply where conditions / filters, see <a href="../query/trait.QueryFilter.html" title="trait sea_orm::query::QueryFilter"><code>QueryFilter</code></a></li>
</ul>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="kw">let </span>delete_result = fruit::Entity::delete_many()
    .filter(fruit::Column::Name.contains(<span class="string">"Apple"</span>))
    .exec(<span class="kw-2">&amp;</span>db)
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(delete_result.rows_affected, <span class="number">5</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"DELETE FROM "fruit" WHERE "fruit"."name" LIKE $1"#</span>,
        [<span class="string">"%Apple%"</span>.into()]
    )]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.delete_by_id" class="method"><h4 class="code-header">fn <a href="#method.delete_by_id" class="fn">delete_by_id</a>&lt;T&gt;(values: T) -&gt; <a class="struct" href="../query/struct.ValidatedDeleteOne.html" title="struct sea_orm::query::ValidatedDeleteOne">ValidatedDeleteOne</a>&lt;Self&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.92.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;&lt;Self::<a class="associatedtype" href="trait.EntityTrait.html#associatedtype.PrimaryKey" title="type sea_orm::entity::EntityTrait::PrimaryKey">PrimaryKey</a> as <a class="trait" href="trait.PrimaryKeyTrait.html" title="trait sea_orm::entity::PrimaryKeyTrait">PrimaryKeyTrait</a>&gt;::<a class="associatedtype" href="trait.PrimaryKeyTrait.html#associatedtype.ValueType" title="type sea_orm::entity::PrimaryKeyTrait::ValueType">ValueType</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Delete a model based on primary key</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::fruit};

<span class="kw">let </span>delete_result = fruit::Entity::delete_by_id(<span class="number">1</span>).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(delete_result.rows_affected, <span class="number">1</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"DELETE FROM "fruit" WHERE "fruit"."id" = $1"#</span>,
        [<span class="number">1i32</span>.into()]
    )]
);</code></pre></div>
<p>Delete by composite key</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">use </span>sea_orm::{entity::<span class="kw-2">*</span>, query::<span class="kw-2">*</span>, tests_cfg::cake_filling};

<span class="kw">let </span>delete_result = cake_filling::Entity::delete_by_id((<span class="number">2</span>, <span class="number">3</span>)).exec(<span class="kw-2">&amp;</span>db).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(delete_result.rows_affected, <span class="number">1</span>);

<span class="macro">assert_eq!</span>(
    db.into_transaction_log(),
    [Transaction::from_sql_and_values(
        DbBackend::Postgres,
        <span class="string">r#"DELETE FROM "cake_filling" WHERE "cake_filling"."cake_id" = $1 AND "cake_filling"."filling_id" = $2"#</span>,
        [<span class="number">2i32</span>.into(), <span class="number">3i32</span>.into()]
    )]
);</code></pre></div></div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.92.0/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/sea_orm/entity/base_entity/trait.EntityTrait.js" async></script></section></div></main></body></html>