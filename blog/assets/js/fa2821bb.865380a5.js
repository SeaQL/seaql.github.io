"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[2473],{801:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025-08-15-sea-query-raw-sql","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-08-15-sea-query-raw-sql.md","source":"@site/blog/2025-08-15-sea-query-raw-sql.md","title":"SeaQuery just made writing raw SQL more enjoyable","description":"You enjoy writing raw SQL queries, SeaQuery just made it better!","date":"2025-08-15T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":6.925,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-08-15-sea-query-raw-sql","title":"SeaQuery just made writing raw SQL more enjoyable","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"What\'s new in SeaORM 1.1.12","permalink":"/blog/2025-06-01-whats-new-in-sea-orm-1.1"}}')},1520:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var r=s(801),a=s(8790),t=s(7630);const i={slug:"2025-08-15-sea-query-raw-sql",title:"SeaQuery just made writing raw SQL more enjoyable",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaQuery%201.0%20Banner.png",tags:["news"]},l=void 0,o={authorsImageUrls:[void 0]},c=[{value:"Gist",id:"gist",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Challenges",id:"challenges",level:2},{value:"Dive in",id:"dive-in",level:2},{value:"Other ideas",id:"other-ideas",level:3},{value:"More goodies",id:"more-goodies",level:2},{value:"Tuple expansion",id:"tuple-expansion",level:3},{value:"Repeating Group",id:"repeating-group",level:2},{value:"SQLx Integration",id:"sqlx-integration",level:2},{value:"SeaQuery 1.0",id:"seaquery-10",level:2},{value:"Sponsor",id:"sponsor",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:4},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{alt:"SeaQuery 1.0 Banner",src:"/blog/img/SeaQuery%201.0%20Banner.png"}),"\n",(0,a.jsx)(n.p,{children:"You enjoy writing raw SQL queries, SeaQuery just made it better!"}),"\n",(0,a.jsxs)(n.p,{children:["We've created a new ",(0,a.jsx)(n.code,{children:"raw_query!"})," macro with neat features to make writing raw SQL queries more ergononmic."]}),"\n",(0,a.jsxs)(n.p,{children:["The biggest headache when crafting complex queries is parameter binding, whether you use ",(0,a.jsx)(n.code,{children:"?"})," or ",(0,a.jsx)(n.code,{children:"$N"})," assigning parameters manually is laborious and error-prone."]}),"\n",(0,a.jsxs)(n.p,{children:["SeaQuery's new ",(0,a.jsx)(n.a,{href:"https://docs.rs/sea-query/1.0.0-rc.9/sea_query/index.html#4-improved-raw-sql-ergonomics",children:(0,a.jsx)(n.code,{children:"raw_query!"})})," macro is designed to solve this exact problem."]}),"\n",(0,a.jsx)(n.h2,{id:"gist",children:"Gist"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let a = 1;\nstruct B { b: i32 }\nlet b = B { b: 2 };\nlet c = "A";\nlet d = vec![3, 4, 5];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"SELECT ("size_w" + {a}) * {b.b} FROM "glyph"\n       WHERE "image" LIKE {c} AND "id" IN ({..d})"#\n);\n\nassert_eq!(\n    query.sql,\n    r#"SELECT ("size_w" + $1) * $2 FROM "glyph"\n       WHERE "image" LIKE $3 AND "id" IN ($4, $5, $6)"#\n);\nassert_eq!(\n    query.values,\n    Values(vec![1.into(), 2.into(), "A".into(), 3.into(), 4.into(), 5.into()])\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"There are several features packed into the snippet above!"}),"\n",(0,a.jsx)(n.p,{children:"Let's have a quick overview and we'll dive into the details:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["named parameter: ",(0,a.jsx)(n.code,{children:"{a}"})," injected"]}),"\n",(0,a.jsxs)(n.li,{children:["nested parameter access: ",(0,a.jsx)(n.code,{children:"{b.b}"})," inner access"]}),"\n",(0,a.jsxs)(n.li,{children:["array expansion: ",(0,a.jsx)(n.code,{children:"{..d}"})," expanded into three parameters"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"There are two more features that will be showcased later:"}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsxs)(n.li,{children:["tuple expansion: ",(0,a.jsx)(n.code,{children:"{values.0:2}"})]}),"\n",(0,a.jsxs)(n.li,{children:["repeating group: ",(0,a.jsx)(n.code,{children:"{..(values.0),}"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,a.jsx)(n.p,{children:"While SeaQuery has long offered a way to build dynamic queries solving basically the same problem, not every one liked SeaQuery's code structure."}),"\n",(0,a.jsxs)(n.p,{children:["I recently came across this ",(0,a.jsx)(n.a,{href:"https://github.com/launchbadge/sqlx/issues/875",children:"SQLx issue"}),", and was enticed to solve it."]}),"\n",(0,a.jsxs)(n.p,{children:["I am heavily inspired by Rust's ",(0,a.jsx)(n.code,{children:"format!"})," macro and other languages' template literals for string interpolation, and figured it could probably be achieved in Rust as well!"]}),"\n",(0,a.jsx)(n.h2,{id:"challenges",children:"Challenges"}),"\n",(0,a.jsxs)(n.p,{children:["First, the above cannot be implemented with standard ",(0,a.jsx)(n.code,{children:"macro_rules"})," because of caller hygiene, such that expanded code cannot access the variables in the surrounding scope. But proc macros do not have this limitation."]}),"\n",(0,a.jsx)(n.p,{children:"Second, if we want to expand an array, the number of elements cannot be known until runtime. So a compile-time approach couldn't work."}),"\n",(0,a.jsx)(n.p,{children:"Third, we have to support all of Rust's primitive and container types as well as third party data types."}),"\n",(0,a.jsx)(n.h2,{id:"dive-in",children:"Dive in"}),"\n",(0,a.jsx)(n.p,{children:"Let's take a look at what the above code expands into!"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let a = 1;\nstruct B {\n    b: i32,\n}\nlet b = B { b: 2 };\nlet c = "A";\nlet d = <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([3, 4, 5]));\n\nlet query = {\n    use sea_query::raw_sql::*;\n    let mut builder = RawSqlQueryBuilder::new(sea_query::PostgresQueryBuilder);\n    builder\n        .push_fragment("SELECT (\\"size_w\\" + ")\n        .push_parameters(1)\n        .push_fragment(") * ")\n        .push_parameters(1)\n        .push_fragment(" FROM \\"glyph\\"\\n        WHERE \\"image\\" LIKE ")\n        .push_parameters(1)\n        .push_fragment(" AND \\"id\\" IN (")\n        .push_parameters((&d).len())\n        .push_fragment(")");\n    let sql = builder.finish();\n    let mut query = seaql::query(&sql);\n    query = query.bind(&a);\n    query = query.bind(&b.b);\n    query = query.bind(&c);\n    for v in (&d).iter() {\n        query = query.bind(v);\n    }\n    query\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["I created ",(0,a.jsx)(n.code,{children:"RawSqlQueryBuilder"})," that is somewhat similar to SeaQuery's query building backend. It serializes the query string in a single pass."]}),"\n",(0,a.jsxs)(n.p,{children:["The derive macro first tokenize and parse the raw SQL to identify the splice points, and then call a special method ",(0,a.jsx)(n.code,{children:"push_parameters"})," to push a variable number of parameters. This can be numbered, i.e. for Postgres."]}),"\n",(0,a.jsx)(n.p,{children:"After finishing the SQL building part, it then proceeds to bind the parameters. This mechanism is designed around SQLx's query API."}),"\n",(0,a.jsxs)(n.p,{children:["If the variable has a spread ",(0,a.jsx)(n.code,{children:".."})," operator, we'd loop over it and bind all items."]}),"\n",(0,a.jsx)(n.h3,{id:"other-ideas",children:"Other ideas"}),"\n",(0,a.jsxs)(n.p,{children:["Originally I wanted to implement auto-expansion, meaning if the parameter is a container type, we'd expand it automagically. But there are quite a few special cases - most importantly ",(0,a.jsx)(n.code,{children:"Vec<u8>"})," is used as bytes and should be bound as a single parameter. Moreover, in Postgres you can use arrays directly, and so we can't decide whether to expand."]}),"\n",(0,a.jsx)(n.h2,{id:"more-goodies",children:"More goodies"}),"\n",(0,a.jsx)(n.h3,{id:"tuple-expansion",children:"Tuple expansion"}),"\n",(0,a.jsx)(n.p,{children:"There are two more features that'll make your life much easier."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let var = (1, "2".to_owned(), 3);\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    "SELECT {var.0}, {var.1}, {var.2}"\n);\n\nlet new_query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"SELECT {var.0:2}"#\n);\n\nassert_eq!(query, new_query);\n'})}),"\n",(0,a.jsx)(n.p,{children:"We can already support accessing tuple members, why not offer a range operator?"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:":"})," token is chosen because it somewhat resembles the Python operator. ",(0,a.jsx)(n.code,{children:"[0:2]"})," is un-natural because tuple members in Rust can only be accessed by ",(0,a.jsx)(n.code,{children:".0"}),". Feel free to offer your thoughts!"]}),"\n",(0,a.jsx)(n.p,{children:"It's not possible to automatically expand a tuple like an array because its arity (the number of elements) is not known at the time the macro is expanded. If the tuple consists of elements with a uniform type, it can be made iterable like a vector by implementing the appropriate traits. However, that approach doesn't apply in the case above, where the tuple's structure is not uniform."}),"\n",(0,a.jsx)(n.p,{children:"You can do inserts with this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let values = (1, "2", 3);\n\nlet query = sea_query::raw_query!(\n    MysqlQueryBuilder,\n    "INSERT INTO `glyph` (`aspect`, `image`, `font_size`) VALUES ({values.0:2})"\n);\nassert_eq!(\n    query.sql,\n    "INSERT INTO `glyph` (`aspect`, `image`, `font_size`) VALUES (?, ?, ?)"\n);\nassert_eq!(query.values, Values(vec![1.into(), "2".into(), 3.into()]));\n'})}),"\n",(0,a.jsx)(n.p,{children:"You may ask, then how do we insert multiple elements? Which brings us to the next feature:"}),"\n",(0,a.jsx)(n.h2,{id:"repeating-group",children:"Repeating Group"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let values = vec![(1, "2", 3), (4, "5", 6)];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"INSERT INTO "glyph" ("aspect", "image", "font_size")\n       VALUES {..(values.0:2),}"#\n);\nassert_eq!(\n    query.sql,\n    r#"INSERT INTO "glyph" ("aspect", "image", "font_size")\n       VALUES ($1, $2, $3), ($4, $5, $6)"#\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"This syntax almost looks like regex now. Please let me explain:"}),"\n",(0,a.jsxs)(n.p,{children:["It's expanded upon the previous example, in which ",(0,a.jsx)(n.code,{children:"values.0:2"})," means tuple expansion. We want to repeat this tuple as a group, surrounded by parenthesis, so we wrap it with ",(0,a.jsx)(n.code,{children:"()"}),". Then we apply the same spread operator ",(0,a.jsx)(n.code,{children:".."})," to expand the vector of tuples. Finally, the trailing ",(0,a.jsx)(n.code,{children:","})," means they should be connected with ",(0,a.jsx)(n.code,{children:","}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This repeating group is not fully-generalized yet, but is quite flexible:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'struct Item {\n    a: i32,\n    b: String,\n    c: u16,\n}\n\nlet values = vec![\n    Item { a: 1, b: "2".to_owned(), c: 3 },\n    Item { a: 4, b: "5".to_owned(), c: 6 },\n];\n\nlet query = sea_query::raw_query!(\n    PostgresQueryBuilder,\n    r#"INSERT INTO "glyph" ("aspect", "image", "font_size")\n       VALUES {..(values.a, values.b, values.c),}"#\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is equivalent to the previous example."}),"\n",(0,a.jsx)(n.h2,{id:"sqlx-integration",children:"SQLx Integration"}),"\n",(0,a.jsxs)(n.p,{children:["SeaQuery offers tight SQLx integration. So in practice you can do (requires ",(0,a.jsx)(n.code,{children:"sqlx-utils"})," feature flag):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let mut sql;\nlet res = sea_query::sqlx::sqlite::query!(\n    sql = r#"INSERT INTO "character"\n             ("uuid", "font_size", "character")\n             VALUES {..(values.0:2),}"#\n).execute(pool).await?;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note the salient ",(0,a.jsx)(n.code,{children:"sql"})," variable. SQLx's ",(0,a.jsx)(n.code,{children:"Query"})," object can only borrow the SQL as ",(0,a.jsx)(n.code,{children:"&str"}),", and so someone has to own the ",(0,a.jsx)(n.code,{children:"String"}),". I couldn't think of a better API, suggestions welcome."]}),"\n",(0,a.jsxs)(n.p,{children:["It calls the underlying ",(0,a.jsx)(n.a,{href:"https://docs.rs/sqlx/latest/sqlx/query/struct.Query.html",children:(0,a.jsx)(n.code,{children:"Query"})}),"'s bind method directly, so no extra copy is involved. This is the lowest possible overhead!"]}),"\n",(0,a.jsx)(n.p,{children:"One final example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let mut character = Character { id: 1, font_size: 0 };\ncharacter.font_size = 18;\n\nlet res = sea_query::sqlx::sqlite::query!(\n    sql = r#"UPDATE "character"\n             SET "font_size" = {character.font_size}\n             WHERE "id" = {character.id}"#\n).execute(pool).await?;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Full example can be found ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/blob/master/examples/sqlx_sqlite/src/main.rs",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["It almost feels like a mini ORM ... although ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm",children:"SeaORM \ud83d\udc1a"})," is still highly recommended by us!"]}),"\n",(0,a.jsx)(n.h2,{id:"seaquery-10",children:"SeaQuery 1.0"}),"\n",(0,a.jsxs)(n.p,{children:["This is just one of many new features we've added while preparing ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/blob/master/CHANGELOG.md#100---pending",children:"SeaQuery 1.0"}),". This is currently an ",(0,a.jsx)(n.code,{children:"rc"})," release, if you have ideas please ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/sea-query/discussions/795",children:"join the discussion"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"sponsor",children:"Sponsor"}),"\n",(0,a.jsx)(n.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,a.jsxs)(n.p,{children:["A big shout out to our ",(0,a.jsx)(n.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"})," \ud83d\ude07:"]}),"\n",(0,a.jsx)("img",{src:"/blog/img/github-sponsors-20250812.jpg#light"}),"\n",(0,a.jsx)("img",{src:"/blog/img/github-sponsors-20250812-dark.jpg#dark"}),"\n",(0,a.jsx)(n.h4,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,a.jsx)("a",{href:"https://qdx.co/",children:(0,a.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics\u2013powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data engineering workflows."]}),"\n",(0,a.jsx)(n.h2,{id:"rustacean-sticker-pack-",children:"Rustacean Sticker Pack \ud83e\udd80"}),"\n",(0,a.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"}),"\n",(0,a.jsx)(n.p,{children:"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."}),"\n",(0,a.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"}),"\n",(0,a.jsx)(n.li,{children:"Mascot of SeaQL: Terres the Hermit Crab"}),"\n",(0,a.jsx)(n.li,{children:"Mascot of Rust: Ferris the Crab"}),"\n",(0,a.jsx)(n.li,{children:"The Rustacean word"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,a.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,a.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},7630:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var r=s(2374);const a={},t=r.createContext(a);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);