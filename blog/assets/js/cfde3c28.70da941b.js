"use strict";(globalThis.webpackChunksea_ql_blog=globalThis.webpackChunksea_ql_blog||[]).push([[9917],{2663:e=>{e.exports=JSON.parse('{"permalink":"/blog/2022-05-14-faq-01","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2022-05-14-faq-01.md","source":"@site/blog/2022-05-14-faq-01.md","title":"SeaORM FAQ.01","description":"FAQ.01 Why SeaORM does not nest objects for parent-child relation?","date":"2022-05-14T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":1.91,"hasTruncateMarker":false,"authors":[{"name":"Chris Tsang","title":"SeaQL Team","url":"https://github.com/tyt2y3","imageURL":"https://avatars.githubusercontent.com/u/1782664?v=4","key":null,"page":null}],"frontMatter":{"slug":"2022-05-14-faq-01","title":"SeaORM FAQ.01","author":"Chris Tsang","author_title":"SeaQL Team","author_url":"https://github.com/tyt2y3","author_image_url":"https://avatars.githubusercontent.com/u/1782664?v=4","tags":["news"]},"unlisted":false,"prevItem":{"title":"What\'s new in SeaORM 0.8.0","permalink":"/blog/2022-05-15-whats-new-in-0.8.0"},"nextItem":{"title":"Introducing StarfishQL","permalink":"/blog/2022-04-04-introducing-starfish-ql"}}')},7253:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=n(2663),s=n(4848),r=n(8453);const o={slug:"2022-05-14-faq-01",title:"SeaORM FAQ.01",author:"Chris Tsang",author_title:"SeaQL Team",author_url:"https://github.com/tyt2y3",author_image_url:"https://avatars.githubusercontent.com/u/1782664?v=4",tags:["news"]},i=void 0,l={authorsImageUrls:[void 0]},c=[{value:"FAQ.01 Why SeaORM does not nest objects for parent-child relation?",id:"faq01-why-seaorm-does-not-nest-objects-for-parent-child-relation",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"faq01-why-seaorm-does-not-nest-objects-for-parent-child-relation",children:"FAQ.01 Why SeaORM does not nest objects for parent-child relation?"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let cake_with_fruits: Vec<(cake::Model, Vec<fruit::Model>)> =\n    Cake::find().find_with_related(Fruit).all(db).await?;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Consider the above API, ",(0,s.jsx)(t.code,{children:"Cake"})," and ",(0,s.jsx)(t.code,{children:"Fruit"})," are two separate models."]}),"\n",(0,s.jsx)(t.p,{children:"If you come from a dynamic language, you'd probably used to:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"struct Cake {\n    id: u64,\n    fruit: Fruit,\n    ..\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"It's so convenient that you can simply:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let cake = Cake::find().one(db).await?;\nprintln!("Fruit = {}", cake.fruit.name);\n'})}),"\n",(0,s.jsx)(t.p,{children:"Sweet right? Okay so, the problem with this pattern is that it does not fit well with Rust."}),"\n",(0,s.jsxs)(t.p,{children:["Let's look at this playground: ",(0,s.jsx)(t.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6fb0a981189ace081fbb2aa04f50146b",children:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6fb0a981189ace081fbb2aa04f50146b"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"struct Parent {\n    a: u64,\n    child: Option<Child>,\n}\n\nstruct ParentWithBox {\n    a: u64,\n    child: Option<Box<Child>>,\n}\n\nstruct Child {\n    a: u64,\n    b: u64,\n    c: u64,\n    d: u64,\n}\n\nfn main() {\n    dbg!(std::mem::size_of::<Parent>());\n    dbg!(std::mem::size_of::<ParentWithBox>());\n    dbg!(std::mem::size_of::<Child>());\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"What's the output you guess?"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-log",children:"[src/main.rs:21] std::mem::size_of::<Parent>() = 48\n[src/main.rs:22] std::mem::size_of::<ParentWithBox>() = 16\n[src/main.rs:23] std::mem::size_of::<Child>() = 32\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In dynamic languages, objects are always held by pointers, and that maps to a ",(0,s.jsx)(t.code,{children:"Box"})," in Rust. In Rust, we don't put objects in ",(0,s.jsx)(t.code,{children:"Box"}),"es by default, because it forces the object to be allocated on the heap. And that is an extra cost! Because objects are always first constructed on the stack and then being copied over to the heap."]}),"\n",(0,s.jsx)(t.p,{children:"Ref:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://users.rust-lang.org/t/how-to-create-large-objects-directly-in-heap/26405",children:"https://users.rust-lang.org/t/how-to-create-large-objects-directly-in-heap/26405"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/PoignardAzur/placement-by-return/blob/placement-by-return/text/0000-placement-by-return.md",children:"https://github.com/PoignardAzur/placement-by-return/blob/placement-by-return/text/0000-placement-by-return.md"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["We face the dilemma where we either put the object on the stack and waste some space (it takes up 48 bytes no matter ",(0,s.jsx)(t.code,{children:"child"})," is ",(0,s.jsx)(t.code,{children:"None"})," or not) or put the object in a box and waste some cycles."]}),"\n",(0,s.jsx)(t.p,{children:"If you are new to Rust, all these might be unfamiliar, but a Rust programmer has to consciously make decisions over memory management, and we don't want to make decisions on behalf of our users."}),"\n",(0,s.jsx)(t.p,{children:"That said, there were proposals to add API with this style to SeaORM, and we might implement that in the future. Hopefully this would shed some light on the matter meanwhile."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(6540);const s={},r=a.createContext(s);function o(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);