"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[879],{7331:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025-09-16-sea-orm-2.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-09-16-sea-orm-2.0.md","source":"@site/blog/2025-09-16-sea-orm-2.0.md","title":"A Sneak Peek at SeaORM 2.0","description":"SeaORM 1.0 debuted on 2024-08-04. Over the past year, we\'ve shipped 16 minor releases - staying true to our promise of delivering new features without compromising stability.","date":"2025-09-16T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":15.74,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-09-16-sea-orm-2.0","title":"A Sneak Peek at SeaORM 2.0","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"The road to SeaQuery 1.0","permalink":"/blog/2025-08-30-sea-query-1.0"}}')},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var t=a(6540);const s={},r=t.createContext(s);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(r.Provider,{value:n},e.children)}},9149:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});var t=a(7331),s=a(4848),r=a(8453);const i={slug:"2025-09-16-sea-orm-2.0",title:"A Sneak Peek at SeaORM 2.0",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},l=void 0,o={authorsImageUrls:[void 0]},c=[{value:"1.0 New Features",id:"10-new-features",level:2},{value:"Nested Select",id:"nested-select",level:3},{value:"PartialModel -&gt; ActiveModel",id:"partialmodel---activemodel",level:3},{value:"Insert active models with non-uniform column sets",id:"insert-active-models-with-non-uniform-column-sets",level:3},{value:"Implement <code>DeriveValueType</code> for enum strings",id:"implement-derivevaluetype-for-enum-strings",level:3},{value:"Support Postgres PgVector &amp; IpNetwork",id:"support-postgres-pgvector--ipnetwork",level:3},{value:"2.0 New Features",id:"20-new-features",level:2},{value:"Nested Select on any Model",id:"nested-select-on-any-model",level:3},{value:"Wrapper type as primary key",id:"wrapper-type-as-primary-key",level:3},{value:"Multi-part unique keys",id:"multi-part-unique-keys",level:3},{value:"Allow missing fields when using <code>ActiveModel::from_json</code>",id:"allow-missing-fields-when-using-activemodelfrom_json",level:3},{value:"2.0 Overhaul",id:"20-overhaul",level:2},{value:"Overhauled <code>Entity::insert_many</code>",id:"overhauled-entityinsert_many",level:3},{value:"Overhauled <code>ConnectionTrait</code> API",id:"overhauled-connectiontrait-api",level:3},{value:"Removing panics from APIs",id:"removing-panics-from-apis",level:3},{value:"2.0 Exciting New Features",id:"20-exciting-new-features",level:2},{value:"Raw SQL macro",id:"raw-sql-macro",level:3},{value:"Find Model by raw SQL",id:"find-model-by-raw-sql",level:4},{value:"Find custom Model by raw SQL",id:"find-custom-model-by-raw-sql",level:4},{value:"Paginate raw SQL query",id:"paginate-raw-sql-query",level:4},{value:"Role Based Access Control",id:"role-based-access-control",level:3},{value:"SeaORM RBAC",id:"seaorm-rbac",level:4},{value:"\ud83d\udda5\ufe0f SeaORM Pro: Professional Admin Panel",id:"\ufe0f-seaorm-pro-professional-admin-panel",level:2},{value:"More to come",id:"more-to-come",level:2},{value:"Sponsors",id:"sponsors",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:3},{value:"GitHub Sponsors",id:"github-sponsors",level:3},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM 1.0 debuted on 2024-08-04. Over the past year, we've shipped 16 minor releases - staying true to our promise of delivering new features without compromising stability."}),"\n",(0,s.jsxs)(n.p,{children:["If you haven't been following every update, here's a quick tour of some quality-of-life improvements you can start using right now. Otherwise, you can skip to the ",(0,s.jsx)(n.a,{href:"#20-new-features",children:"2.0 section"}),"."]}),"\n",(0,s.jsx)(n.p,{children:'While building the new features in 1.0, we bent over backwards to avoid breaking changes, which meant leaving in a few bits that aren\'t exactly elegant, intuitive, or frankly, "footgun".'}),"\n",(0,s.jsx)(n.p,{children:"To make SeaORM friendlier and more intuitive for newcomers (and a little kinder to seasoned users too), we've decided it's time for a 2.0 release - one that embraces necessary breaking changes to clean things up and set a stronger foundation for the future."}),"\n",(0,s.jsx)(n.h2,{id:"10-new-features",children:"1.0 New Features"}),"\n",(0,s.jsx)(n.h3,{id:"nested-select",children:"Nested Select"}),"\n",(0,s.jsxs)(n.p,{children:["This is the most requested feature by far, and we've implemented nested select in SeaORM. We've added nested ",(0,s.jsx)(n.code,{children:"alias"})," and ActiveEnum support too."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use sea_orm::DerivePartialModel;\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity", from_query_result)]\nstruct CakeWithFruit {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    fruit: Option<Fruit>,\n}\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "fruit::Entity", from_query_result)]\nstruct Fruit {\n    id: i32,\n    name: String,\n}\n\nlet cakes: Vec<CakeWithFruit> = cake::Entity::find()\n    .left_join(fruit::Entity)\n    .into_partial_model()\n    .all(db)\n    .await?;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"partialmodel---activemodel",children:"PartialModel -> ActiveModel"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DerivePartialModel"})," got another extension to derive ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/latest/sea_orm/entity/trait.IntoActiveModel.html",children:(0,s.jsx)(n.code,{children:"IntoActiveModel"})})," as well. Absent attributes will be filled with ",(0,s.jsx)(n.code,{children:"NotSet"}),". This allows you to have a cake and eat it!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity", into_active_model)]\nstruct PartialCake {\n    id: i32,\n    name: String,\n}\n\nlet partial_cake = PartialCake {\n    id: 12,\n    name: "Lemon Drizzle".to_owned(),\n};\n\n// this is now possible:\nassert_eq!(\n    cake::ActiveModel {\n        ..partial_cake.into_active_model()\n    },\n    cake::ActiveModel {\n        id: Set(12),\n        name: Set("Lemon Drizzle".to_owned()),\n        ..Default::default()\n    }\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"insert-active-models-with-non-uniform-column-sets",children:"Insert active models with non-uniform column sets"}),"\n",(0,s.jsxs)(n.p,{children:["Insert many now allows active models to have different column sets. Previously, it'd panic when encountering this. Missing columns will be filled with ",(0,s.jsx)(n.code,{children:"NULL"}),". This makes seeding data a seamless operation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let apple = cake_filling::ActiveModel {\n    cake_id: ActiveValue::set(2),\n    filling_id: ActiveValue::NotSet,\n};\nlet orange = cake_filling::ActiveModel {\n    cake_id: ActiveValue::NotSet,\n    filling_id: ActiveValue::set(3),\n};\nassert_eq!(\n    Insert::<cake_filling::ActiveModel>::new()\n        .add_many([apple, orange])\n        .build(DbBackend::Postgres)\n        .to_string(),\n    r#"INSERT INTO "cake_filling" ("cake_id", "filling_id") VALUES (2, NULL), (NULL, 3)"#,\n);\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"implement-derivevaluetype-for-enum-strings",children:["Implement ",(0,s.jsx)(n.code,{children:"DeriveValueType"})," for enum strings"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DeriveValueType"})," now supports ",(0,s.jsx)(n.code,{children:"enum"})," types. It offers a simpler alternative to ",(0,s.jsx)(n.code,{children:"DeriveActiveEnum"})," for client-side enums backed by string database types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(DeriveValueType)]\n#[sea_orm(value_type = "String")]\npub enum Tag {\n    Hard,\n    Soft,\n}\n\n// `from_str` defaults to `std::str::FromStr::from_str`\nimpl std::str::FromStr for Tag {\n    type Err = sea_orm::sea_query::ValueTypeErr;\n    fn from_str(s: &str) -> Result<Self, Self::Err> { .. }\n}\n\n// `to_str` defaults to `std::string::ToString::to_string`.\nimpl std::fmt::Display for Tag {\n    fn fmt(&self, f: &mut std::fmt::Formatter<\'_>) -> std::fmt::Result { .. }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"support-postgres-pgvector--ipnetwork",children:"Support Postgres PgVector & IpNetwork"}),"\n",(0,s.jsxs)(n.p,{children:["Under feature flag ",(0,s.jsx)(n.code,{children:"postgres-vector"})," / ",(0,s.jsx)(n.code,{children:"with-ipnetwork"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = "demo_table")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub embedding: PgVector,\n    pub ipaddress: IpNetwork,\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"20-new-features",children:"2.0 New Features"}),"\n",(0,s.jsx)(n.p,{children:"These are small touch-ups, but added-up can make great differences."}),"\n",(0,s.jsx)(n.h3,{id:"nested-select-on-any-model",children:"Nested Select on any Model"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2642",children:"#2642"})," Wait... we've seen this before? No, there is a small detail here: now every Model can be used in nested select! This requires a small breaking change to basically derive ",(0,s.jsx)(n.code,{children:"PartialModelTrait"})," on regular ",(0,s.jsx)(n.code,{children:"Model"}),"s. And also notice the removed ",(0,s.jsx)(n.code,{children:"from_query_result"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use sea_orm::DerivePartialModel;\n\n#[derive(DerivePartialModel)]\n#[sea_orm(entity = "cake::Entity")] // <- from_query_result not needed\nstruct CakeWithFruit {\n    id: i32,\n    name: String,\n    #[sea_orm(nested)]\n    fruit: Option<fruit::Model>, // <- this is just a regular Model\n}\n\nlet cakes: Vec<CakeWithFruit> = cake::Entity::find()\n    .left_join(fruit::Entity)\n    .into_partial_model()\n    .all(db)\n    .await?;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"wrapper-type-as-primary-key",children:"Wrapper type as primary key"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2643",children:"#2643"})," Wrapper type derived with ",(0,s.jsx)(n.code,{children:"DeriveValueType"})," can now be used as primary key. Now you can embrace Rust's type system to make your code more robust!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "my_value_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: MyInteger,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveValueType)]\npub struct MyInteger(pub i32);\n// only for i8 | i16 | i32 | i64 | u8 | u16 | u32 | u64\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multi-part-unique-keys",children:"Multi-part unique keys"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2651",children:"#2651"})," You can now define unique keys that span multiple columns in Entity."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "lineitem")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique_key = "item")]\n    pub order_id: i32,\n    #[sea_orm(unique_key = "item")]\n    pub cake_id: i32,\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let stmts = Schema::new(backend).create_index_from_entity(lineitem::Entity);\n\nassert_eq!(\n    stmts[0],\n    Index::create()\n        .name("idx-lineitem-item")\n        .table(lineitem::Entity)\n        .col(lineitem::Column::OrderId)\n        .col(lineitem::Column::CakeId)\n        .unique()\n        .take()\n);\n\nassert_eq!(\n    backend.build(stmts[0]),\n    r#"CREATE UNIQUE INDEX "idx-lineitem-item" ON "lineitem" ("order_id", "cake_id")"#\n);\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"allow-missing-fields-when-using-activemodelfrom_json",children:["Allow missing fields when using ",(0,s.jsx)(n.code,{children:"ActiveModel::from_json"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2599",children:"#2599"})," Improved utility of ",(0,s.jsx)(n.code,{children:"ActiveModel::from_json"})," when dealing with inputs probably coming from REST APIs."]}),"\n",(0,s.jsx)(n.p,{children:"Consider the following Entity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]\n#[sea_orm(table_name = "cake")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,      // <- not nullable\n    pub name: String,\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Previously, the following would result in error ",(0,s.jsx)(n.code,{children:'missing field "id"'}),". The usual solution is to add ",(0,s.jsx)(n.code,{children:"#[serde(skip_deserializing)]"})," to the Model."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'assert!(\n    cake::ActiveModel::from_json(json!({\n        "name": "Apple Pie",\n    })).is_err();\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now, the above will just work. The ActiveModel will be partially filled:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'assert_eq!(\n    cake::ActiveModel::from_json(json!({\n        "name": "Apple Pie",\n    }))\n    .unwrap(),\n    cake::ActiveModel {\n        id: NotSet,\n        name: Set("Apple Pie".to_owned()),\n    }\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["How it works under the hood? It's actually ",(0,s.jsx)(n.a,{href:"http://localhost:3000/blog/2025-06-01-whats-new-in-sea-orm-1.1/#added-default_values-to-activemodeltrait",children:"quite interesting"}),". This requires a small breaking to the trait bound of the method."]}),"\n",(0,s.jsx)(n.h2,{id:"20-overhaul",children:"2.0 Overhaul"}),"\n",(0,s.jsxs)(n.h3,{id:"overhauled-entityinsert_many",children:["Overhauled ",(0,s.jsx)(n.code,{children:"Entity::insert_many"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2628",children:"#2628"})," We've received many issue reports around the ",(0,s.jsx)(n.code,{children:"insert_many"})," API. After careful examination, I made a number of changes in 2.0:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"removed APIs that can panic"}),"\n",(0,s.jsxs)(n.li,{children:["new helper struct ",(0,s.jsx)(n.code,{children:"InsertMany"}),", ",(0,s.jsx)(n.code,{children:"last_insert_id"})," is now ",(0,s.jsx)(n.code,{children:"Option<Value>"})]}),"\n",(0,s.jsxs)(n.li,{children:["on empty iterator, ",(0,s.jsx)(n.code,{children:"None"})," or ",(0,s.jsx)(n.code,{children:"vec![]"})," is returned on exec operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TryInsert"})," API is unchanged"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Previously, ",(0,s.jsx)(n.code,{children:"insert_many"})," shares the same helper struct with ",(0,s.jsx)(n.code,{children:"insert_one"}),", which led to an awkard API."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let res = Bakery::insert_many(std::iter::empty())\n    .on_empty_do_nothing() // <- you needed to add this\n    .exec(db)\n    .await;\n\nassert!(matches!(res, Ok(TryInsertResult::Empty)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, ",(0,s.jsx)(n.code,{children:"last_insert_id"})," is ",(0,s.jsx)(n.code,{children:"Option<Value>"})," for ",(0,s.jsx)(n.code,{children:"InsertMany"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct InsertManyResult<A: ActiveModelTrait>\n{\n    pub last_insert_id: Option<<PrimaryKey<A> as PrimaryKeyTrait>::ValueType>,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Which means the awkardness is removed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let res = Entity::insert_many::<ActiveModel, _>([]).exec(db).await;\n\nassert_eq!(res?.last_insert_id, None); // insert nothing return None\n\nlet res = Entity::insert_many([ActiveModel { id: Set(1) }, ActiveModel { id: Set(2) }])\n    .exec(db)\n    .await;\n\nassert_eq!(res?.last_insert_id, Some(2)); // insert something return Some\n"})}),"\n",(0,s.jsx)(n.p,{children:"Same on conflict API as before:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let res = Entity::insert_many([ActiveModel { id: Set(3) }, ActiveModel { id: Set(4) }])\n    .on_conflict_do_nothing()\n    .exec(db)\n    .await;\n\nassert!(matches!(conflict_insert, Ok(TryInsertResult::Conflicted)));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Exec with returning now returns a ",(0,s.jsx)(n.code,{children:"Vec<Model>"}),", so it feels intuitive:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'assert!(\n    Entity::insert_many::<ActiveModel, _>([])\n        .exec_with_returning(db)\n        .await?\n        .is_empty() // no footgun, nice\n);\n\nassert_eq!(\n    Entity::insert_many([\n        ActiveModel {\n            id: NotSet,\n            value: Set("two".into()),\n        }\n    ])\n    .exec_with_returning(db)\n    .await\n    .unwrap(),\n    [\n        Model {\n            id: 2,\n            value: "two".into(),\n        }\n    ]\n);\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"overhauled-connectiontrait-api",children:["Overhauled ",(0,s.jsx)(n.code,{children:"ConnectionTrait"})," API"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2657",children:"#2657"}),"\nWe overhauled the ",(0,s.jsx)(n.code,{children:"ConnectionTrait"})," API. ",(0,s.jsx)(n.code,{children:"execute"}),", ",(0,s.jsx)(n.code,{children:"query_one"}),", ",(0,s.jsx)(n.code,{children:"query_all"}),", ",(0,s.jsx)(n.code,{children:"stream"})," now takes in SeaQuery statement instead of raw SQL statement."]}),"\n",(0,s.jsx)(n.p,{children:"So you don't have to access the backend to build the query yourself."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// old\nlet query: SelectStatement = Entity::find().filter(..).into_query();\nlet backend = self.db.get_database_backend();\nlet stmt = backend.build(&query);\nlet rows = self.db.query_all(stmt).await?;\n\n// new\nlet query: SelectStatement = Entity::find().filter(..).into_query();\nlet rows = self.db.query_all(&query).await?;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A new set of methods ",(0,s.jsx)(n.code,{children:"execute_raw"}),", ",(0,s.jsx)(n.code,{children:"query_one_raw"}),", ",(0,s.jsx)(n.code,{children:"query_all_raw"}),", ",(0,s.jsx)(n.code,{children:"stream_raw"})," is added, so you can still do the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let backend = self.db.get_database_backend();\nlet stmt = backend.build(&query);\n\n// new\nlet rows = self.db.query_all_raw(stmt).await?;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"removing-panics-from-apis",children:"Removing panics from APIs"}),"\n",(0,s.jsxs)(n.p,{children:["SeaORM has a large API surface. We've already removed a great number of ",(0,s.jsx)(n.code,{children:"unwrap"}),'s from the codebase in 1.0, but some panics due to "mis-use of API" can still happen.']}),"\n",(0,s.jsx)(n.p,{children:"Once again, we've tried to remove the remaining panics."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2630",children:"#2630"})," Added new error variant ",(0,s.jsx)(n.code,{children:"BackendNotSupported"}),'. Previously, it panics with e.g. "Database backend doesn\'t support RETURNING"']}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let result = cake::Entity::insert_many([])\n    .exec_with_returning_keys(db)\n    .await;\n\nif db.support_returning() {\n    // Postgres and SQLite\n    assert_eq!(result.unwrap(), []);\n} else {\n    // MySQL\n    assert!(matches!(result, Err(DbErr::BackendNotSupported { .. })));\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2627",children:"#2627"})," Added new error variant ",(0,s.jsx)(n.code,{children:"PrimaryKeyNotSet"}),'. Previously, it panics with "PrimaryKey is not set"']}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"assert!(matches!(\n    Update::one(cake::ActiveModel {\n        ..Default::default()\n    })\n    .exec(&db)\n    .await,\n    Err(DbErr::PrimaryKeyNotSet { .. })\n));\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2634",children:"#2634"})," Remove panics in ",(0,s.jsx)(n.code,{children:"Schema::create_enum_from_active_enum"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn create_enum_from_active_enum<A>(&self) -> Option<TypeCreateStatement>\n// method can now return None\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2628",children:"#2628"})," Remove panickable APIs from insert"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"    /// Add a Model to `Insert`\n    ///\n    /// # Panics\n    ///\n    /// Panics if the rows have different column sets from what've previously been cached in the query statement\n  - pub fn add<M>(mut self, m: M) -> Self\n"})}),"\n",(0,s.jsx)(n.h2,{id:"20-exciting-new-features",children:"2.0 Exciting New Features"}),"\n",(0,s.jsx)(n.p,{children:"We've planned some exciting new features for SeaORM too."}),"\n",(0,s.jsx)(n.h3,{id:"raw-sql-macro",children:"Raw SQL macro"}),"\n",(0,s.jsxs)(n.p,{children:["While already explained in detail in a ",(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-08-15-sea-query-raw-sql/",children:"previous blog post"}),", we've integrated the ",(0,s.jsx)(n.code,{children:"raw_sql!"})," macro nicely into SeaORM."]}),"\n",(0,s.jsx)(n.p,{children:"It's not a ground-breaking new feature, but it does unlock exciting new ways to use SeaORM. After all, SeaORM isn't just an ORM; it's a flexible SQL toolkit you can tailour to your own programming style. Use it as a backend-agnostic SQLx wrapper, SeaQuery with built-in connection management, or a lightweight ORM with enchanted raw SQL. The choice is yours!"}),"\n",(0,s.jsx)(n.h4,{id:"find-model-by-raw-sql",children:"Find Model by raw SQL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let id = 1;\n\nlet cake: Option<cake::Model> = cake::Entity::find()\n    .from_raw_sql(raw_sql!(\n        Postgres,\n        r#"SELECT "cake"."id", "cake"."name" FROM "cake" WHERE "id" = {id}"#\n    ))\n    .one(&db)\n    .await?;\n'})}),"\n",(0,s.jsx)(n.h4,{id:"find-custom-model-by-raw-sql",children:"Find custom Model by raw SQL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(FromQueryResult)]\nstruct Cake {\n    name: String,\n    #[sea_orm(nested)]\n    bakery: Option<Bakery>,\n}\n\n#[derive(FromQueryResult)]\nstruct Bakery {\n    #[sea_orm(alias = "bakery_name")]\n    name: String,\n}\n\nlet cake_ids = [2, 3, 4]; // expanded by the `..` operator\n\nlet cake: Option<Cake> = Cake::find_by_statement(raw_sql!(\n    Sqlite,\n    r#"SELECT "cake"."name", "bakery"."name" AS "bakery_name"\n       FROM "cake"\n       LEFT JOIN "bakery" ON "cake"."bakery_id" = "bakery"."id"\n       WHERE "cake"."id" IN ({..cake_ids})"#\n))\n.one(db)\n.await?;\n'})}),"\n",(0,s.jsx)(n.h4,{id:"paginate-raw-sql-query",children:"Paginate raw SQL query"}),"\n",(0,s.jsxs)(n.p,{children:["You can paginate ",(0,s.jsx)(n.a,{href:"https://docs.rs/sea-orm/*/sea_orm/struct.SelectorRaw.html",children:(0,s.jsx)(n.code,{children:"SelectorRaw"})})," and fetch ",(0,s.jsx)(n.code,{children:"Model"})," in batch."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let ids = vec![1, 2, 3, 4];\n\nlet mut cake_pages = cake::Entity::find()\n    .from_raw_sql(raw_sql!(\n        Postgres,\n        r#"SELECT "cake"."id", "cake"."name" FROM "cake" WHERE "id" IN ({..ids})"#\n    ))\n    .paginate(db, 10);\n\nwhile let Some(cakes) = cake_pages.fetch_and_next().await? {\n    // Do something on cakes: Vec<cake::Model>\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"role-based-access-control",children:"Role Based Access Control"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/pull/2683",children:"#2683"})," We will cover this in detail in a future blog post, but here's a sneak peek."]}),"\n",(0,s.jsx)(n.h4,{id:"seaorm-rbac",children:"SeaORM RBAC"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["A hierarchical RBAC engine that is table scoped","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"a user has 1 (and only 1) role"}),"\n",(0,s.jsxs)(n.li,{children:["a role has a set of permissions on a set of resources","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"permissions here are CRUD operations and resources are tables"}),"\n",(0,s.jsx)(n.li,{children:"but the engine is generic so can be used for other things"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"roles have hierarchy, and can inherit permissions from multiple roles"}),"\n",(0,s.jsxs)(n.li,{children:["there is a wildcard ",(0,s.jsx)(n.code,{children:"*"})," (opt-in) to grant all permissions or resources"]}),"\n",(0,s.jsx)(n.li,{children:"individual users can have rules override"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"A set of Entities to load / store the access control rules to / from database"}),"\n",(0,s.jsx)(n.li,{children:"A query auditor that dissect queries for necessary permissions (implemented in SeaQuery)"}),"\n",(0,s.jsxs)(n.li,{children:["Integration of RBAC into SeaORM in form of ",(0,s.jsx)(n.code,{children:"RestrictedConnection"}),".\nIt implements ",(0,s.jsx)(n.code,{children:"ConnectionTrait"}),", behaves like a normal connection, but will audit all queries and perform permission check before execution,\nand reject them accordingly. All Entity operations except raw SQL are supported.\nComplex nested joins, ",(0,s.jsx)(n.code,{children:"INSERT INTO SELECT FROM"}),", and even CTE queries are supported."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// load rules from database\ndb_conn.load_rbac().await?;\n\n// admin can create bakery\nlet db: RestrictedConnection = db_conn.restricted_for(admin)?;\nlet seaside_bakery = bakery::ActiveModel {\n    name: Set("SeaSide Bakery".to_owned()),\n    ..Default::default()\n};\nassert!(Bakery::insert(seaside_bakery).exec(&db).await.is_ok());\n\n// manager cannot create bakery\nlet db: RestrictedConnection = db_conn.restricted_for(manager)?;\nassert!(matches!(\n    Bakery::insert(bakery::ActiveModel::default())\n        .exec(&db)\n        .await,\n    Err(DbErr::AccessDenied { .. })\n));\n\n// transaction works too\nlet txn: RestrictedTransaction = db.begin().await?;\n\nbaker::Entity::insert(baker::ActiveModel {\n    name: Set("Master Baker".to_owned()),\n    bakery_id: Set(Some(1)),\n    ..Default::default()\n})\n.exec(&txn)\n.await?;\n\ntxn.commit().await?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-seaorm-pro-professional-admin-panel",children:"\ud83d\udda5\ufe0f SeaORM Pro: Professional Admin Panel"}),"\n",(0,s.jsx)("img",{src:"/blog/img/sea-orm-pro-light.png#light"}),"\n",(0,s.jsx)("img",{src:"/blog/img/sea-orm-pro-dark.png#dark"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/sea-orm-pro/",children:"SeaORM Pro"})," is an admin panel solution allowing you to quickly and easily launch an admin panel for your application - frontend development skills not required, but certainly nice to have!"]}),"\n",(0,s.jsx)(n.p,{children:"Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full CRUD"}),"\n",(0,s.jsx)(n.li,{children:"Built on React + GraphQL"}),"\n",(0,s.jsx)(n.li,{children:"Built-in GraphQL resolver"}),"\n",(0,s.jsx)(n.li,{children:"Customize the UI with simple TOML"}),"\n",(0,s.jsx)(n.li,{children:"RBAC (coming soon with SeaORM 2.0)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"more-to-come",children:"More to come"}),"\n",(0,s.jsx)(n.p,{children:"SeaORM\u202f2.0 is shaping up to be our most significant release yet - with a few breaking changes, plenty of enhancements, and a clear focus on developer experience. We'll unpack everything in the posts to come, so keep an eye out for the next update!"}),"\n",(0,s.jsx)(n.p,{children:"If you have suggestions on breaking changes, you are welcome to post them in the discussions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/discussions/2548",children:"Wanted breaking changes in SeaORM"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sponsors",children:"Sponsors"}),"\n",(0,s.jsx)(n.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,s.jsx)(n.h3,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,s.jsx)("a",{href:"https://qdx.co/",children:(0,s.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics\u2013powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data intensive applications."]}),"\n",(0,s.jsx)(n.h3,{id:"github-sponsors",children:"GitHub Sponsors"}),"\n",(0,s.jsxs)(n.p,{children:["A big shout out to our ",(0,s.jsx)(n.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"})," \ud83d\ude07:"]}),"\n",(0,s.jsx)("div",{class:"row",children:(0,s.jsx)("div",{class:"col col--12 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--lg",href:"https://github.com/subscribepro",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/8466133?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Subscribe Pro"})})]})})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)("div",{class:"row",children:[(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/holly-hacker",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/13605369?u=9566a44f2d869f337a4909836487bb4a29c23b72&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Variant9"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/ryanswrt",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/87781?u=10a9d256e741f905f3dd2cf641de8b325720732e&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Ryan Swart"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/OteroRafael",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/175388115?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"OteroRafael"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/higumachan",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1011298?u=de4c2f0d0929c2c6dc433981912f794d0e50f2cd&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Yuta Hinokuma"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/wh7f",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/59872041?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"wh7f"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcson909",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/16665353?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"MS"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/numeusxyz",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/82152211?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Numeus"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/data-intuitive",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/15045722?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Data Intuitive"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/caido-community",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/168573261?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Caido Community"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcusbuffett",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1834328?u=fd066d99cf4a6333bfb3927d1c756af4bb8baf7e&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Marcus Buffett"})})]})})]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)("div",{class:"row",children:[(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/yuly3",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/25814001?u=4b57756e7d8060e48262a9edba687927fe7934a6&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"MasakiMiyazaki"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/kallydev",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/36319157?u=5be882aa4dbe7eea97b1a80a6473857369146df6&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"KallyDev"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/manfredcml",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/27536502?u=b71636bdabbc698458b32e2ac05c5771ad41097e&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Manfred Lee"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/tugascript",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/64930104?u=ad9f63e8e221dbe71bf23de59e3611c99cda1181&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Afonso Barracha"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/deansheather",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/11241812?u=260538c7d8b8c3c5350dba175ebb8294358441e0&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Dean Sheather"})})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"rustacean-sticker-pack-",children:"Rustacean Sticker Pack \ud83e\udd80"}),"\n",(0,s.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"}),"\n",(0,s.jsx)(n.p,{children:"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."}),"\n",(0,s.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"}),"\n",(0,s.jsx)(n.li,{children:"Mascot of SeaQL: Terres the Hermit Crab"}),"\n",(0,s.jsx)(n.li,{children:"Mascot of Rust: Ferris the Crab"}),"\n",(0,s.jsx)(n.li,{children:"The Rustacean word"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,s.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,s.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);