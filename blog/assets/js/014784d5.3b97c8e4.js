"use strict";(globalThis.webpackChunksea_ql_blog=globalThis.webpackChunksea_ql_blog||[]).push([[1944],{1814:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025-11-11-sea-orm-2.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-11-11-sea-orm-2.0.md","source":"@site/blog/2025-11-11-sea-orm-2.0.md","title":"SeaORM 2.0: Strongly-Typed Column","description":"In our last post, we introduced a new Entity format - designed to be more concise, more readable, and easy to write by hand.","date":"2025-11-11T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":9.87,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-11-11-sea-orm-2.0","title":"SeaORM 2.0: Strongly-Typed Column","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"prevItem":{"title":"What\'s new in SeaORM Pro 2.0","permalink":"/blog/2025-11-21-whats-new-in-seaormpro-2.0"},"nextItem":{"title":"SeaORM 2.0: Entity First Workflow","permalink":"/blog/2025-10-30-sea-orm-2.0"}}')},4373:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});var t=a(1814),s=a(4848),r=a(8453);const o={slug:"2025-11-11-sea-orm-2.0",title:"SeaORM 2.0: Strongly-Typed Column",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},i=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Bye-bye CamelCase",id:"bye-bye-camelcase",level:2},{value:"<code>COLUMN</code> Constant",id:"column-constant",level:3},{value:"Type-Aware Helper Methods",id:"type-aware-helper-methods",level:3},{value:"<code>Column</code> as typed value",id:"column-as-typed-value",level:3},{value:"Opt-in Only",id:"opt-in-only",level:3},{value:"More Entity Enhancements",id:"more-entity-enhancements",level:2},{value:"Related Fields",id:"related-fields",level:3},{value:"Entity Loader Paginator",id:"entity-loader-paginator",level:3},{value:"Added <code>delete_by_key</code>",id:"added-delete_by_key",level:3},{value:"Self-Referencing Relations",id:"self-referencing-relations",level:3},{value:"Entity Loader",id:"entity-loader",level:4},{value:"Model Loader",id:"model-loader",level:4},{value:"Unix Timestamp Column Type",id:"unix-timestamp-column-type",level:3},{value:"Entity-First Workflow",id:"entity-first-workflow",level:3},{value:"\ud83e\udded Instant GraphQL API",id:"-instant-graphql-api",level:2},{value:"\ud83d\udda5\ufe0f SeaORM Pro: Admin Panel",id:"\ufe0f-seaorm-pro-admin-panel",level:2},{value:"\ud83c\udf1f Sponsors",id:"-sponsors",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:4},{value:"GitHub Sponsors",id:"github-sponsors",level:4},{value:"\ud83e\udd80 Rustacean Sticker Pack",id:"-rustacean-sticker-pack",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,s.jsxs)(n.p,{children:["In our last post, we introduced a ",(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-10-20-sea-orm-2.0/",children:"new Entity format"})," - designed to be more concise, more readable, and easy to write by hand."]}),"\n",(0,s.jsxs)(n.p,{children:["We've also added a new ",(0,s.jsx)(n.code,{children:"COLUMN"})," constant to make it more ergonomic, along with other enhancements."]}),"\n",(0,s.jsx)(n.h2,{id:"bye-bye-camelcase",children:"Bye-bye CamelCase"}),"\n",(0,s.jsxs)(n.p,{children:["Previously, column names in queries had to be written in ",(0,s.jsx)(n.code,{children:"CamelCase"}),". This was because the Column type was defined as an enum, it's simpler for the type system and faster to compile than generating a struct per column, but at the cost of losing column\u2011specific type information."]}),"\n",(0,s.jsxs)(n.p,{children:["Our new design keeps compilation fast while restoring stronger type guarantees. As a bonus, it eliminates the need for ",(0,s.jsx)(n.code,{children:"CamelCase"})," and even saves a keystroke."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// old\nuser::Entity::find().filter(user::Column::Name.contains("Bob"))\n\n// new\nuser::Entity::find().filter(user::COLUMN.name.contains("Bob"))\n\n// compile error: the trait `From<{integer}>` is not implemented for `String`\nuser::Entity::find().filter(user::COLUMN.name.like(2))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Under the hood, each ",(0,s.jsx)(n.code,{children:"Column"})," value is wrapped in a byte-sized struct ",(0,s.jsx)(n.code,{children:"TypeAwareColumn"}),". This wrapper is generic over ",(0,s.jsx)(n.code,{children:"Entity"}),", so whether a table has 1 column or 100, the compile\u2011time cost stays roughly the same."]}),"\n",(0,s.jsxs)(n.h3,{id:"column-constant",children:[(0,s.jsx)(n.code,{children:"COLUMN"})," Constant"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct NumericColumn<E: EntityTrait>(pub E::Column);\n\nimpl<E: EntityTrait> NumericColumn<E> {\n    pub fn eq<V>(v: V) -> Expr { .. }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="user.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "user")]\npub struct Model {\n    ..\n}\n\n// expands into following:\n\npub struct TypedColumn {\n    pub id: NumericColumn<Entity>,\n    pub name: StringColumn<Entity>,\n    pub date_of_birth: DateLikeColumn<Entity>,\n}\n\npub const COLUMN: TypedColumn = TypedColumn {\n    id: NumericColumn(Column::Id),\n    name: StringColumn(Column::Name),\n    date_of_birth: DateLikeColumn(Column::DateOfBirth),\n};\n\nimpl Entity {\n    pub const COLUMN: TypedColumn = COLUMN;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"type-aware-helper-methods",children:"Type-Aware Helper Methods"}),"\n",(0,s.jsxs)(n.p,{children:["Each column type wrapper exposes a set of methods that's relevant for the column's type. For example ",(0,s.jsx)(n.code,{children:"StringColumn::contains"})," and ",(0,s.jsx)(n.code,{children:"ArrayColumn::contains"})," are distinct methods that do the right thing!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'Entity::COLUMN.name.contains("Bob") // WHERE "name" LIKE \'%Bob%\'\n\n// tags is Vec<String>\nEntity::COLUMN.tags.contains(vec!["awesome"]) // WHERE "tags" @> ARRAY [\'awesome\']\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Right now there are a set of types: ",(0,s.jsx)(n.code,{children:"BoolColumn"}),", ",(0,s.jsx)(n.code,{children:"NumericColumn"}),", ",(0,s.jsx)(n.code,{children:"StringColumn"}),", ",(0,s.jsx)(n.code,{children:"BytesColumn"}),", ",(0,s.jsx)(n.code,{children:"JsonColumn"}),", ",(0,s.jsx)(n.code,{children:"DateLikeColumn"}),", ",(0,s.jsx)(n.code,{children:"TimeLikeColumn"}),", ",(0,s.jsx)(n.code,{children:"DateTimeLikeColumn"}),", ",(0,s.jsx)(n.code,{children:"UuidColumn"}),", ",(0,s.jsx)(n.code,{children:"IpNetworkColumn"}),", and more relevant methods can be added, feel free to make sugguestions."]}),"\n",(0,s.jsxs)(n.h3,{id:"column-as-typed-value",children:[(0,s.jsx)(n.code,{children:"Column"})," as typed value"]}),"\n",(0,s.jsx)(n.p,{children:"One advantage of this design is that Columns are values: you can pass them into functions, combine with reflection, and build safe dynamic queries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// returns an Expression fragment that can be used to build queries\nfn filter_by_column(col: post::Column) -> Expr {\n    col.eq("attribute")\n}\n\n// get an integer from a model depends on runtime condition\nfn get_value_from(model: &post::Model, col: post::Column) {\n    let value: i32 = model.get(col).unwrap();\n    // do something on value\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"opt-in-only",children:"Opt-in Only"}),"\n",(0,s.jsxs)(n.p,{children:["These new structs are generated only when using the new ",(0,s.jsx)(n.code,{children:"#[sea_orm::model]"})," or ",(0,s.jsx)(n.code,{children:"#[sea_orm::compact_model]"})," macros. This keeps the change fully backwards\u2011compatible, and you incur no cost if you don't use them."]}),"\n",(0,s.jsx)(n.h2,{id:"more-entity-enhancements",children:"More Entity Enhancements"}),"\n",(0,s.jsx)(n.p,{children:"A big thanks to early-adopters who provided feedback to improve SeaORM 2.0."}),"\n",(0,s.jsx)(n.h3,{id:"related-fields",children:"Related Fields"}),"\n",(0,s.jsxs)(n.p,{children:["The nested types for ",(0,s.jsx)(n.code,{children:"HasOne"})," and ",(0,s.jsx)(n.code,{children:"HasMany"})," have been changed from transparent type aliases to wrapper types. This makes it possible to distinguish between a relation that hasn\u2019t been loaded and one that has loaded but yielded no models."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum HasOne<E: EntityTrait> {\n    #[default]\n    Unloaded,\n    NotFound,\n    Loaded(Box<<E as EntityTrait>::ModelEx>),\n}\n\npub enum HasMany<E: EntityTrait> {\n    #[default]\n    Unloaded,\n    Loaded(Vec<<E as EntityTrait>::ModelEx>),\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We've added a range of methods to the wrapper type to make it feel as transparent as possible. The goal is to reduce friction while still preserving the benefits of a strong type system."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// len() / is_empty() methods\nassert_eq!(users[0].posts.len(), 2);\nassert!(!users[0].posts.is_empty());\n\n// impl PartialEq\nassert_eq!(users[0].posts, [post_1, post_2]);\n\n// this creates HasOne::Loaded(Box<profile::ModelEx>)\nprofile: HasOne::loaded(profile::Model {\n    id: 1,\n    picture: "jpeg".into(),\n    ..\n})\n'})}),"\n",(0,s.jsx)(n.h3,{id:"entity-loader-paginator",children:"Entity Loader Paginator"}),"\n",(0,s.jsxs)(n.p,{children:["Entity Loader now supports pagination. It has the same API as a regular ",(0,s.jsx)(n.code,{children:"Select"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let paginator = user::Entity::load()\n    .with(profile::Entity)\n    .order_by_asc(user::COLUMN.id)\n    .paginate(db, 10);\n\nlet users: Vec<user::ModelEx> = paginator.fetch().await?;\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"added-delete_by_key",children:["Added ",(0,s.jsx)(n.code,{children:"delete_by_key"})]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to ",(0,s.jsx)(n.code,{children:"find_by_key"}),", now the ",(0,s.jsx)(n.code,{children:"delete_by_key"})," convenience method is also added:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'user::Entity::delete_by_email("bob@spam.com").exec(db).await?\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"delete_by_*"})," methods now return ",(0,s.jsx)(n.code,{children:"DeleteOne"})," instead of ",(0,s.jsx)(n.code,{children:"DeleteMany"}),".\nIt doesn't change normal ",(0,s.jsx)(n.code,{children:"exec"})," usage, but would change return type of ",(0,s.jsx)(n.code,{children:"exec_with_returning"})," to ",(0,s.jsx)(n.code,{children:"Option<Model>"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn delete_by_id<T>(values: T) -> DeleteMany<Self>         // old\n\nfn delete_by_id<T>(values: T) -> ValidatedDeleteOne<Self> // new\n"})}),"\n",(0,s.jsx)(n.h3,{id:"self-referencing-relations",children:"Self-Referencing Relations"}),"\n",(0,s.jsxs)(n.p,{children:["Let's say we have a ",(0,s.jsx)(n.code,{children:"staff"})," table, where each staff has a manager that they report to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="staff.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "staff")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    pub reports_to_id: Option<i32>,\n    #[sea_orm(\n        self_ref,\n        relation_enum = "ReportsTo",\n        relation_reverse = "Manages",\n        from = "reports_to_id",\n        to = "id"\n    )]\n    pub reports_to: HasOne<Entity>,\n    #[sea_orm(self_ref, relation_enum = "Manages", relation_reverse = "ReportsTo")]\n    pub manages: HasMany<Entity>,\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"entity-loader",children:"Entity Loader"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let staff = staff::Entity::load()\n    .with(staff::Relation::ReportsTo)\n    .with(staff::Relation::Manages)\n    .all(db)\n    .await?;\n\nassert_eq!(staff[0].name, "Alan");\nassert_eq!(staff[0].reports_to, None);\nassert_eq!(staff[0].manages[0].name, "Ben");\nassert_eq!(staff[0].manages[1].name, "Alice");\n\nassert_eq!(staff[1].name, "Ben");\nassert_eq!(staff[1].reports_to.as_ref().unwrap().name, "Alan");\nassert!(staff[1].manages.is_empty());\n\nassert_eq!(staff[2].name, "Alice");\nassert_eq!(staff[2].reports_to.as_ref().unwrap().name, "Alan");\nassert!(staff[2].manages.is_empty());\n\nassert_eq!(staff[3].name, "Elle");\nassert_eq!(staff[3].reports_to, None);\nassert!(staff[3].manages.is_empty());\n'})}),"\n",(0,s.jsx)(n.h4,{id:"model-loader",children:"Model Loader"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let staff = staff::Entity::find().all(db).await?;\n\nlet reports_to = staff\n    .load_self(staff::Entity, staff::Relation::ReportsTo, db)\n    .await?;\n\nassert_eq!(staff[0].name, "Alan");\nassert_eq!(reports_to[0], None);\n\nassert_eq!(staff[1].name, "Ben");\nassert_eq!(reports_to[1].as_ref().unwrap().name, "Alan");\n\nassert_eq!(staff[2].name, "Alice");\nassert_eq!(reports_to[2].as_ref().unwrap().name, "Alan");\n\nassert_eq!(staff[3].name, "Elle");\nassert_eq!(reports_to[3], None);\n'})}),"\n",(0,s.jsx)(n.p,{children:"It can work in reverse too."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let manages = staff\n    .load_self_many(staff::Entity, staff::Relation::Manages, db)\n    .await?;\n\nassert_eq!(staff[0].name, "Alan");\nassert_eq!(manages[0].len(), 2);\nassert_eq!(manages[0][0].name, "Ben");\nassert_eq!(manages[0][1].name, "Alice");\n\nassert_eq!(staff[1].name, "Ben");\nassert_eq!(manages[1].len(), 0);\n\nassert_eq!(staff[2].name, "Alice");\nassert_eq!(manages[2].len(), 0);\n\nassert_eq!(staff[3].name, "Elle");\nassert_eq!(manages[3].len(), 0);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"unix-timestamp-column-type",children:"Unix Timestamp Column Type"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes it may be desirable (or no choice but) to store a timestamp as ",(0,s.jsx)(n.code,{children:"i64"})," in database, but mapping it to a ",(0,s.jsx)(n.code,{children:"DateTimeUtc"})," in application code."]}),"\n",(0,s.jsxs)(n.p,{children:["We've created a new set of ",(0,s.jsx)(n.code,{children:"UnixTimestamp"})," wrapper types that does this transparently:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "access_log")]\npub struct Model {\n    .. // with `chrono` crate\n    pub ts: ChronoUnixTimestamp,\n    pub ms: ChronoUnixTimestampMillis,\n    .. // with `time` crate\n    pub ts: TimeUnixTimestamp,\n    pub ms: TimeUnixTimestampMillis,\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let now = ChronoUtc::now();\nlet log = access_log::ActiveModel {\n    ts: Set(now.into()),\n    ..Default::default()\n}\n.insert(db)\n.await?;\n\nassert_eq!(log.ts.timestamp(), now.timestamp());\n"})}),"\n",(0,s.jsx)(n.h3,{id:"entity-first-workflow",children:"Entity-First Workflow"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SchemaBuilder"})," can now be used in migrations."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[async_trait::async_trait]\nimpl MigrationTrait for Migration {\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        let db = manager.get_connection();\n\n        db.get_schema_builder()\n            .register(user::Entity)\n            .apply(db) // or sync(db)\n            .await\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"-instant-graphql-api",children:"\ud83e\udded Instant GraphQL API"}),"\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"}),", the Entities you wrote can ",(0,s.jsx)(n.em,{children:"instantly"})," be exposed as a GraphQL schema, with full CRUD, filtering and pagination. No extra macros, no Entity re-generation is needed!"]}),"\n",(0,s.jsx)(n.p,{children:"With SeaORM and Seaography, you can prototype quickly and stay in the flow. The Entity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "user")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(unique)]\n    pub email: String,\n    #[sea_orm(has_one)]\n    pub profile: HasOne<super::profile::Entity>,\n    #[sea_orm(has_many)]\n    pub posts: HasMany<super::post::Entity>,\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Instantly turned into a GraphQL type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type User {\n  id: Int!\n  name: String!\n  email: String!\n  profile: Profile\n  post(\n    filters: PostFilterInput\n    orderBy: PostOrderInput\n    pagination: PaginationInput\n  ): PostConnection!\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-seaorm-pro-admin-panel",children:"\ud83d\udda5\ufe0f SeaORM Pro: Admin Panel"}),"\n",(0,s.jsx)("img",{src:"/blog/img/sea-orm-pro-light.png#light"}),"\n",(0,s.jsx)("img",{src:"/blog/img/sea-orm-pro-dark.png#dark"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm-pro",children:"SeaORM Pro"})," is an admin panel solution allowing you to quickly and easily launch an admin panel for your application - frontend development skills not required, but certainly nice to have!"]}),"\n",(0,s.jsx)(n.p,{children:"SeaORM Pro has been updated to support the latest features in SeaORM 2.0."}),"\n",(0,s.jsx)(n.p,{children:"Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full CRUD"}),"\n",(0,s.jsx)(n.li,{children:"Built on React + GraphQL"}),"\n",(0,s.jsx)(n.li,{children:"Built-in GraphQL resolver"}),"\n",(0,s.jsx)(n.li,{children:"Customize the UI with TOML config"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-09-30-sea-orm-rbac/",children:"Role Based Access Control"})," ",(0,s.jsx)(n.em,{children:"(new in 2.0)"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"-sponsors",children:"\ud83c\udf1f Sponsors"}),"\n",(0,s.jsx)(n.h4,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,s.jsx)("a",{href:"https://qdx.co/",children:(0,s.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics-powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data intensive applications."]}),"\n",(0,s.jsx)(n.h4,{id:"github-sponsors",children:"GitHub Sponsors"}),"\n",(0,s.jsx)(n.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,s.jsxs)(n.p,{children:["A big shout out to our ",(0,s.jsx)(n.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"}),":"]}),"\n",(0,s.jsxs)("div",{class:"row margin-left--sm",children:[(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/ryanswrt",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/87781?u=10a9d256e741f905f3dd2cf641de8b325720732e&v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/OteroRafael",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/175388115?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/higumachan",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1011298?u=de4c2f0d0929c2c6dc433981912f794d0e50f2cd&v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/wh7f",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/59872041?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcson909",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/16665353?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/numeusxyz",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/82152211?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/data-intuitive",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/15045722?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/caido-community",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/168573261?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcusbuffett",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1834328?v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/sanctusgee",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/2237695?v=4"})})})]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)("div",{class:"row margin-left--sm",children:[(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/yuly3",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/25814001?u=4b57756e7d8060e48262a9edba687927fe7934a6&v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/kallydev",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/36319157?u=5be882aa4dbe7eea97b1a80a6473857369146df6&v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/manfredcml",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/27536502?u=b71636bdabbc698458b32e2ac05c5771ad41097e&v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/tugascript",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/64930104?u=ad9f63e8e221dbe71bf23de59e3611c99cda1181&v=4"})})}),(0,s.jsx)("div",{class:"avatar",children:(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/deansheather",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/11241812?u=260538c7d8b8c3c5350dba175ebb8294358441e0&v=4"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"-rustacean-sticker-pack",children:"\ud83e\udd80 Rustacean Sticker Pack"}),"\n",(0,s.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish."}),"\n",(0,s.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography"}),"\n",(0,s.jsx)(n.li,{children:"Mascots: Ferris the Crab x 3, Terres the Hermit Crab"}),"\n",(0,s.jsx)(n.li,{children:"The Rustacean wordmark"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,s.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,s.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>i});var t=a(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);