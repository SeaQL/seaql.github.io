"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[9140],{5781:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025-11-25-sea-orm-2.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-11-25-sea-orm-2.0.md","source":"@site/blog/2025-11-25-sea-orm-2.0.md","title":"SeaORM 2.0: Nested ActiveModel and Cascade Operations","description":"In our last post, we introduced a Smart Entity Loader that made querying multi-path relations into nested models simple and efficient. That solved the read side of the problem.","date":"2025-11-25T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":15.87,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-11-25-sea-orm-2.0","title":"SeaORM 2.0: Nested ActiveModel and Cascade Operations","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"prevItem":{"title":"A walk-through of SeaORM 2.0","permalink":"/blog/2025-12-05-sea-orm-2.0"},"nextItem":{"title":"What\'s new in SeaORM Pro 2.0","permalink":"/blog/2025-11-21-whats-new-in-seaormpro-2.0"}}')},7050:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});var n=a(5781),s=a(4848),i=a(8453);const o={slug:"2025-11-25-sea-orm-2.0",title:"SeaORM 2.0: Nested ActiveModel and Cascade Operations",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},r=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Gist",id:"gist",level:2},{value:"Unfolding",id:"unfolding",level:3},{value:"Relational Dependency",id:"relational-dependency",level:2},{value:"Has One / Belongs To",id:"has-one--belongs-to",level:3},{value:"Has Many",id:"has-many",level:3},{value:"Many to Many",id:"many-to-many",level:3},{value:"Note",id:"note",level:4},{value:"Change Detection",id:"change-detection",level:2},{value:"Cascade Delete",id:"cascade-delete",level:2},{value:"Weak Belongs To",id:"weak-belongs-to",level:3},{value:"Idempotence",id:"idempotence",level:2},{value:"Tips",id:"tips",level:3},{value:"Backwards Compatibility",id:"backwards-compatibility",level:2},{value:"\ud83e\udded Instant GraphQL API",id:"-instant-graphql-api",level:2},{value:"\ud83d\udda5\ufe0f SeaORM Pro: Admin Panel",id:"\ufe0f-seaorm-pro-admin-panel",level:2},{value:"\ud83c\udf1f Sponsors",id:"-sponsors",level:2},{value:"Gold Sponsor",id:"gold-sponsor",level:4},{value:"GitHub Sponsors",id:"github-sponsors",level:4},{value:"\ud83e\udd80 Rustacean Sticker Pack",id:"-rustacean-sticker-pack",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,s.jsxs)(t.p,{children:["In our last post, we introduced a ",(0,s.jsx)(t.a,{href:"https://www.sea-ql.org/blog/2025-10-20-sea-orm-2.0/",children:"Smart Entity Loader"})," that made querying multi-path relations into nested models simple and efficient. That solved the read side of the problem."]}),"\n",(0,s.jsx)(t.p,{children:"With nested ActiveModel, you can now do the reverse: persist a nested object back into the database in one operation. SeaORM walks the tree, detects changes, constructs the insert and update statements, and executes them in the correct order to respect foreign key dependencies."}),"\n",(0,s.jsx)(t.h2,{id:"gist",children:"Gist"}),"\n",(0,s.jsx)(t.p,{children:"The following operation saves a new set of user + profile + post + tag + post_tag into the database atomically:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let user = user::ActiveModel::builder()\n    .set_name("Bob")\n    .set_email("bob@sea-ql.org")\n    .set_profile(profile::ActiveModel::builder().set_picture("image.jpg"))\n    .add_post(\n        post::ActiveModel::builder()\n            .set_title("Nice weather")\n            .add_tag(tag::ActiveModel::builder().set_tag("sunny")),\n    )\n    .save(db)\n    .await?;\n'})}),"\n",(0,s.jsx)(t.h3,{id:"unfolding",children:"Unfolding"}),"\n",(0,s.jsx)(t.p,{children:"This builder pattern constructs the following object tree:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'user::ActiveModelEx {\n    name: Set("Bob".into()),\n    email: Set("bob@sea-ql.org".into()),\n    profile: HasOneModel::Set(profile::ActiveModelEx {\n        picture: Set("image.jpg".into()),\n        ..Default::default()\n    }),\n    posts: HasManyModel::Append(post::ActiveModelEx {\n        title: Set("Nice weather".into()),\n        tags: HasManyModel::Append(tag::ActiveModel {\n            tag: Set("sunny".into()),\n            ..Default::default()\n        }),\n        ..Default::default()\n    }),\n    ..Default::default()\n}\n.save(db)\n.await?\n'})}),"\n",(0,s.jsx)(t.p,{children:".. which is equivalent to doing the following manually:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let txn = db.begin().await?;\n\n// insert a user\nlet user = user::ActiveModelEx {\n    name: Set("Bob".into()),\n    email: Set("bob@sea-ql.org".into()),\n    ..Default::default()\n}.insert(&txn).await?;\n\n// profile belongs_to user (1-1)\nlet profile = profile::ActiveModelEx {\n    user_id: Set(user.id),\n    picture: Set("image.jpg".into()),\n    ..Default::default()\n}.insert(&txn).await?;\n\n// post belongs_to user (1-N)\nlet post = post::ActiveModelEx {\n    user_id: Set(user.id),\n    title: Set("Nice weather".into()),\n    ..Default::default()\n}.insert(&txn).await?;\n\n// insert a tag\nlet tag = tag::ActiveModel {\n    tag: Set("sunny".into()),\n    ..Default::default()\n}\n.insert(&txn)\n.await?;\n\n// associate tag to post\npost_tag::ActiveModel {\n    post_id: Set(post.id),\n    tag_id: Set(tag.id),\n}\n.insert(&txn)\n.await?;\n\ntxn.commit().await?;\n'})}),"\n",(0,s.jsx)(t.h2,{id:"relational-dependency",children:"Relational Dependency"}),"\n",(0,s.jsx)(t.p,{children:"The core of the problem lies in figuring the foreign key relations between Entities and executing the queries in the correct order. SeaORM supports the following:"}),"\n",(0,s.jsx)(t.h3,{id:"has-one--belongs-to",children:"Has One / Belongs To"}),"\n",(0,s.jsx)(t.p,{children:"User 1-1 Profile"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="user.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "user")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(has_one)]\n    pub profile: HasOne<super::profile::Entity>,\n    ..\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["There is a ",(0,s.jsx)(t.code,{children:"unique"})," key on ",(0,s.jsx)(t.code,{children:"user_id"}),", making this relation one-to-one."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="profile.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "profile")]\npub struct Model {\n    #[sea_orm(unique)]\n    pub user_id: i32,\n    #[sea_orm(belongs_to, from = "user_id", to = "id")]\n    pub user: HasOne<super::user::Entity>,\n    ..\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Since ",(0,s.jsx)(t.code,{children:"profile"})," belongs to ",(0,s.jsx)(t.code,{children:"user"}),", the user has to be inserted first to obtain it's ",(0,s.jsx)(t.code,{children:"id"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"In SeaORM, it doesn't matter which way the model is nested, it will be executed in the correct order."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'// also okay:\nprofile::ActiveModel::builder()\n    .set_user(\n        user::ActiveModel::builder()\n            .set_name("Alice")\n            .set_email("alice@rust-lang.org"),\n    )\n    .set_picture("image.jpg")\n    .save(db)\n    .await?;\n'})}),"\n",(0,s.jsx)(t.h3,{id:"has-many",children:"Has Many"}),"\n",(0,s.jsx)(t.p,{children:"User 1-N Post"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "post")]\npub struct Model {\n    pub user_id: i32,\n    #[sea_orm(belongs_to, from = "user_id", to = "id")]\n    pub author: HasOne<super::user::Entity>,\n    ..\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"This is very similar to 1-1, with the nested model being a vector instead of option."}),"\n",(0,s.jsxs)(t.p,{children:["There are two possible actions: ",(0,s.jsx)(t.code,{children:"Replace"})," and ",(0,s.jsx)(t.code,{children:"Append"}),". The default action is append, which is non-destructive."]}),"\n",(0,s.jsx)(t.p,{children:"Let's say Bob has written a new blog post, there is no reason having to query all posts bob has written; we can simply do the following:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'// query user, but no posts\nlet bob = user::Entity::load().filter_by_email("bob@sea-ql.org").one(db).await?.unwrap();\n\nlet mut bob.into_active_model();\nbob.posts.push(post::ActiveModel::builder().set_title("Another weekend"));\nbob.save(db).await?; // INSERT INTO post ..\n'})}),"\n",(0,s.jsxs)(t.p,{children:["However, sometimes we do want an empty vector to mean 'delete all', or we want to specify the ",(0,s.jsx)(t.em,{children:"exact"})," set of children. Then we can use ",(0,s.jsx)(t.code,{children:"Replace"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"bob.posts.replace_all([]); // delete all\nbob.posts.replace_all([post_1]); // retain only this post\n"})}),"\n",(0,s.jsx)(t.p,{children:"This will result in the following actions, where posts other than post 1 will be deleted:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"SELECT FROM post WHERE user_id = bob.id\nDELETE FROM post WHERE id = 2\n"})}),"\n",(0,s.jsx)(t.h3,{id:"many-to-many",children:"Many to Many"}),"\n",(0,s.jsx)(t.p,{children:"Post M-N Tag"}),"\n",(0,s.jsx)(t.p,{children:"Many-to-many relations are essential when modeling complex schemas. A unique feature of SeaORM is that it models many-to-many relations as a first-class construct, so you don't need to think about the junction table."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="post.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "post")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub title: String,\n    #[sea_orm(has_many, via = "post_tag")] // \u2b05 specify junction table\n    pub tags: HasMany<super::tag::Entity>,\n    ..\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="post_tag.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "post_tag")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)] // \u2b05 composite key\n    pub post_id: i32,\n    #[sea_orm(primary_key, auto_increment = false)] // \u2b05 composite key\n    pub tag_id: i32,\n    #[sea_orm(belongs_to, from = "post_id", to = "id")] // \u2b05 belongs to both\n    pub post: Option<super::post::Entity>,\n    #[sea_orm(belongs_to, from = "tag_id", to = "id")] // \u2b05 belongs to both\n    pub tag: Option<super::tag::Entity>,\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="tag.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "tag")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)]\n    pub tag: String,\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"M-N relations is not just 1-N + 1-1, it actually breaks away from the notion. Let's look at the following example, insert a new post with 2 tags:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'// Insert one tag for later use\nlet sunny = tag::ActiveModel::builder().set_tag("sunny").save(db).await?;\n\n// Insert a new post with 2 tags\nlet post = post::ActiveModel::builder()\n    .set_title("A sunny day")\n    .set_user(bob)\n    .add_tag(sunny) // an existing tag\n    .add_tag(tag::ActiveModel::builder().set_tag("outdoor")) // a new tag\n    .save(db) // new tag will be created and associcated to the new post\n    .await?;\n'})}),"\n",(0,s.jsx)(t.p,{children:"Which results in the following actions:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"INSERT INTO post (user_id, title) VALUES (bob.id, 'A sunny day') RETURNING id\nINSERT INTO tag (tag) VALUES ('outdoor') RETURNING id\nINSERT INTO post_tag (post_id, tag_id) VALUES (post.id, sunny.id) (post.id, outdoor.id)\n"})}),"\n",(0,s.jsx)(t.p,{children:'Their relation is no longer "belongs to", they are just associated with each other.\nRemoving tags from post does not delete the tags, but only the associations in the junction table.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"post.tags.replace_all([outdoor]); // let's say we remove the tag sunny\n"})}),"\n",(0,s.jsx)(t.p,{children:"Results in:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"DELETE FROM post_tag WHERE (post_id, tag_id) IN ((post.id, sunny.id))\n"})}),"\n",(0,s.jsx)(t.p,{children:"One more example to make this easier to grasp: in a Film M-N Actor relation, deleting a film does not delete its actors, since they can still appear in other films."}),"\n",(0,s.jsx)(t.h4,{id:"note",children:"Note"}),"\n",(0,s.jsx)(t.p,{children:"SeaORM also supports using a surrogate primary key on the junction table, though a composite primary key is recommended."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="film_actor.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "film_actor")]\npub struct Model {\n    #[sea_orm(primary_key)] // \u2b05 normal primary key\n    pub id: i32,\n    #[sea_orm(unique_key = "film_actor")] // \u2b05 unique key\n    pub film_id: i32,\n    #[sea_orm(unique_key = "film_actor")] // \u2b05 unique key\n    pub actor_id: i32,\n    #[sea_orm(belongs_to, from = "film_id", to = "id")]\n    pub film: HasOne<super::film::Entity>,\n    #[sea_orm(belongs_to, from = "actor_id", to = "id")]\n    pub actor: HasOne<super::actor::Entity>,\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"change-detection",children:"Change Detection"}),"\n",(0,s.jsx)(t.p,{children:"Let's go back to the basics, in SeaORM every Model is backed by an ActiveModel:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="post.rs"',children:"pub struct ModelEx {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub user_id: i32,\n    pub title: String,\n    pub author: HasOne<super::user::Entity>,\n    pub tags: HasMany<super::tag::Entity>,\n}\n\n// generated by macro:\npub struct ActiveModelEx {\n    #[sea_orm(primary_key)]\n    pub id: ActiveValue<i32>,\n    pub user_id: ActiveValue<i32>,\n    pub title: ActiveValue<String>,\n    pub author: HasOneModel<super::user::Entity>,\n    pub tags: HasManyModel<super::tag::Entity>,\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Each ",(0,s.jsx)(t.code,{children:"ActiveValue"})," is a tri-state."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub enum ActiveValue<V>\n{\n    Set(V),\n    Unchanged(V),\n    NotSet,\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This allows SeaORM to keep track of what's changed. When you first query a fresh Model from database, the default state is ",(0,s.jsx)(t.code,{children:"Unchanged"}),". When you perform some change in code, the state will be changed to ",(0,s.jsx)(t.code,{children:"Set"}),". So when you run ",(0,s.jsx)(t.code,{children:"save"}),", ",(0,s.jsx)(t.em,{children:"only the changed columns"})," are updated."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let post = post::Entity::find_by_id(22).one(db).await?.unwrap(); // Model\nlet mut post = post.into_active_model(); // ActiveModel\npost.title = Set(\"The weather changed!\");\npost.save(db).await?; // UPDATE post SET title = '..' WHERE id = 22\n"})}),"\n",(0,s.jsx)(t.p,{children:"This has two advantages: it avoids over-updating, reducing the amount of data sent over the wire. More importantly, multiple API endpoints can safely update different column sets without risk of race conditions and without relying on transactions or locking mechanisms."}),"\n",(0,s.jsx)(t.p,{children:"This concept is extended to nested ActiveModels, allowing SeaORM to walk the nested object tree and determine which sub-tree has been changed and requires updating."}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'let mut bob: user::ActiveModel = ..;\n\n// update post title\nbob.posts[0].title = Set("Lorem ipsum dolor sit amet".into());\n// update post comment\nbob.posts[0].comments[0].comment = Set("nice post! I learnt a lot".into());\n// add a new comment too\nbob.posts[1].comments.push(\n    comment::ActiveModel::builder().set_comment("interesting!")\n);\nbob.save(db).await?;\n'})}),"\n",(0,s.jsx)(t.p,{children:"Results in:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"BEGIN TRANSACTION\n\nUPDATE post SET title = '..' WHERE id = post.id\nUPDATE comment SET comment = '..' WHERE id = comment.id\nINSERT INTO comment (post_id, comment) VALUES (post.id. '..')\n\nCOMMIT\n"})}),"\n",(0,s.jsx)(t.p,{children:"It's a lot to take in, but once you build a clear mental model of SeaORM's concepts and mechanisms, you'll find yourself far more productive!"}),"\n",(0,s.jsxs)(t.p,{children:["You can find all the techniques described in this blog post in a ",(0,s.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/examples/quickstart/src/main.rs",children:"single-file example application"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"cascade-delete",children:"Cascade Delete"}),"\n",(0,s.jsxs)(t.p,{children:["If the relations are defined with ",(0,s.jsx)(t.code,{children:"ON DELETE CASCADE"}),", this problem does not exist. However, SeaORM can also perform cascade deletes on the client side. It applies the same rules described above, but in reverse."]}),"\n",(0,s.jsx)(t.p,{children:"For example, Post belongs to User. All posts must be deleted before the user; otherwise, the SQL operation will fail."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let user_4 = user::Entity::find_by_id(4).one(db).await?.unwrap();\n\nuser_4.cascade_delete(db).await?; // equivalent to below\nuser_4.into_ex().delete(db).await?;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"-- query the profile belonging to user\nSELECT FROM profile INNER JOIN user ON user.id = profile.user_id WHERE user.id = 4 LIMIT 1\n-- delete the profile, if exist\nDELETE FROM profile WHERE profile.id = 2\n-- query the posts belonging to user\nSELECT FROM post INNER JOIN user ON user.id = post.user_id WHERE user.id = 4\n-- query the comments belonging to post\nSELECT FROM comment INNER JOIN post ON post.id = comment.post_id WHERE post.id = 7\n-- delete the comments, if exist\nDELETE FROM comment WHERE comment.id = 5\n-- query the post's tags\nSELECT FROM post_tag INNER JOIN post ON post_tag.post_id = post.id WHERE post.id = 7\n-- delete the post-tag associations\nDELETE FROM post_tag WHERE (post_id, tag_id) IN ((7, 2), (7, 3), (7, 4))\n-- post has no dependents, safe to delete now\nDELETE FROM post WHERE post.id = 7\n-- user has no dependents, safe to delete now\nDELETE FROM user WHERE user.id = 4\n"})}),"\n",(0,s.jsx)(t.h3,{id:"weak-belongs-to",children:"Weak Belongs To"}),"\n",(0,s.jsx)(t.p,{children:"There is one more special case of the Belongs To relation not yet mentioned: weak 1-N associations, where an entity may have an owner, but is not strictly required."}),"\n",(0,s.jsx)(t.p,{children:"To give an example, Post 1-N Attachment. However users can upload attachments before drafting posts, thus some attachments may have no associated posts."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="attachment.rs"',children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "attachment")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub post_id: Option<i32>, // this is nullable\n    pub file: String,\n    #[sea_orm(belongs_to, from = "post_id", to = "id")]\n    pub post: HasOne<super::post::Entity>,\n}\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"// this post has attachment_2\nlet post_1 = post::Entity::find_by_id(1).one(db).await?.unwrap();\npost_1.cascade_delete(db).await?;\n\n// post_id of attachment will be set to null, instead of deleting the attachment\nlet attachment_2 = attachment::Entity::find_by_id(2).one(db).await?.unwrap();\nassert!(attachment_2.post_id.is_none());\n"})}),"\n",(0,s.jsx)(t.h2,{id:"idempotence",children:"Idempotence"}),"\n",(0,s.jsxs)(t.p,{children:["The general rule of thumb is idempotence: saving an ActiveModel a second time should be a no-op.\nUnless you use ",(0,s.jsx)(t.code,{children:"replace"})," or ",(0,s.jsx)(t.code,{children:"delete"}),", no delete will be executed."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let post = post.save(db).await?;\nlet post = post.save(db).await?; // no-op, as all fields are unchanged\n"})}),"\n",(0,s.jsx)(t.p,{children:"The ActiveModel you provides is a snapshot of the desired final state of the data, and SeaORM should ensure that it ends up that way. This can be complicated, so please report any bugs."}),"\n",(0,s.jsx)(t.h3,{id:"tips",children:"Tips"}),"\n",(0,s.jsxs)(t.p,{children:["Keeping track of whether to use ",(0,s.jsx)(t.code,{children:"insert"})," or ",(0,s.jsx)(t.code,{children:"update"}),' can be hard, unless the intended action is "create new from scratch". Use ',(0,s.jsx)(t.code,{children:"save"})," as the default, and let SeaORM decide when to execute ",(0,s.jsx)(t.code,{children:"insert"})," or ",(0,s.jsx)(t.code,{children:"update"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"(If you already find these concepts familiar, it's no surprise that it's called ActiveModel.)"}),"\n",(0,s.jsx)(t.h2,{id:"backwards-compatibility",children:"Backwards Compatibility"}),"\n",(0,s.jsxs)(t.p,{children:["All the 2.0 features introduced in this post are fully backwards compatible with 1.0, since only new types and methods have been added: ",(0,s.jsx)(t.code,{children:"ActiveModelEx"}),", ",(0,s.jsx)(t.code,{children:"HasOneModel"}),", ",(0,s.jsx)(t.code,{children:"HasManyModel"})," and a few methods. ",(0,s.jsx)(t.code,{children:"ActiveModel"})," continues to behave exactly as before."]}),"\n",(0,s.jsxs)(t.p,{children:["However, due to the macros needing the relations' attributes to generate the implementations, these features are only available to ",(0,s.jsx)(t.code,{children:"#[sea_orm::model]"}),", but not ",(0,s.jsx)(t.code,{children:"#[sea_orm::compact_model]"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"-instant-graphql-api",children:"\ud83e\udded Instant GraphQL API"}),"\n",(0,s.jsxs)(t.p,{children:["With ",(0,s.jsx)(t.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"}),", the Entities you wrote can ",(0,s.jsx)(t.em,{children:"instantly"})," be exposed as a GraphQL schema, with full CRUD, filtering and pagination. No extra macros, no Entity re-generation is needed!"]}),"\n",(0,s.jsx)(t.p,{children:"With SeaORM and Seaography, you can prototype quickly and stay in the flow. The Entity:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "user")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(unique)]\n    pub email: String,\n    #[sea_orm(has_one)]\n    pub profile: HasOne<super::profile::Entity>,\n    #[sea_orm(has_many)]\n    pub posts: HasMany<super::post::Entity>,\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Instantly turned into a GraphQL type:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:"type User {\n  id: Int!\n  name: String!\n  email: String!\n  profile: Profile\n  post(\n    filters: PostFilterInput\n    orderBy: PostOrderInput\n    pagination: PaginationInput\n  ): PostConnection!\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-seaorm-pro-admin-panel",children:"\ud83d\udda5\ufe0f SeaORM Pro: Admin Panel"}),"\n",(0,s.jsx)("img",{src:"/blog/img/sea-orm-pro-light.png#light"}),"\n",(0,s.jsx)("img",{src:"/blog/img/sea-orm-pro-dark.png#dark"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm-pro",children:"SeaORM Pro"})," is an admin panel solution allowing you to quickly and easily launch an admin panel for your application - frontend development skills not required, but certainly nice to have!"]}),"\n",(0,s.jsx)(t.p,{children:"SeaORM Pro has been updated to support the latest features in SeaORM 2.0."}),"\n",(0,s.jsx)(t.p,{children:"Features:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Full CRUD"}),"\n",(0,s.jsx)(t.li,{children:"Built on React + GraphQL"}),"\n",(0,s.jsx)(t.li,{children:"Built-in GraphQL resolver"}),"\n",(0,s.jsx)(t.li,{children:"Customize the UI with TOML config"}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://www.sea-ql.org/blog/2025-09-30-sea-orm-rbac/",children:"Role Based Access Control"})," ",(0,s.jsx)(t.em,{children:"(new in 2.0)"})]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"-sponsors",children:"\ud83c\udf1f Sponsors"}),"\n",(0,s.jsx)(t.h4,{id:"gold-sponsor",children:"Gold Sponsor"}),"\n",(0,s.jsx)("a",{href:"https://qdx.co/",children:(0,s.jsx)("img",{src:"https://www.sea-ql.org/static/sponsors/QDX.svg",width:"128"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://qdx.co/",children:"QDX"})," pioneers quantum dynamics-powered drug discovery, leveraging AI and supercomputing to accelerate molecular modeling.\nWe're grateful to QDX for sponsoring the development of SeaORM, the SQL toolkit that powers their data intensive applications."]}),"\n",(0,s.jsx)(t.h4,{id:"github-sponsors",children:"GitHub Sponsors"}),"\n",(0,s.jsx)(t.p,{children:"If you feel generous, a small donation will be greatly appreciated, and goes a long way towards sustaining the organization."}),"\n",(0,s.jsxs)(t.p,{children:["A big shout out to our ",(0,s.jsx)(t.a,{href:"https://github.com/sponsors/SeaQL",children:"GitHub sponsors"}),":"]}),"\n",(0,s.jsxs)("div",{class:"row",children:[(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/sanctusgee",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/2237695?u=c46344d34b510cb2aea10d4ee2c349277802e408&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Godwin Effiong"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/ryanswrt",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/87781?u=10a9d256e741f905f3dd2cf641de8b325720732e&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Ryan Swart"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/OteroRafael",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/175388115?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"OteroRafael"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/higumachan",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1011298?u=de4c2f0d0929c2c6dc433981912f794d0e50f2cd&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Yuta Hinokuma"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/wh7f",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/59872041?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"wh7f"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcson909",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/16665353?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"MS"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/numeusxyz",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/82152211?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Numeus"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/data-intuitive",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/15045722?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Data Intuitive"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/caido-community",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/168573261?v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Caido Community"})})]})}),(0,s.jsx)("div",{class:"col col--6 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--md",href:"https://github.com/marcusbuffett",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/1834328?u=fd066d99cf4a6333bfb3927d1c756af4bb8baf7e&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Marcus Buffett"})})]})})]}),"\n",(0,s.jsxs)("div",{class:"row",children:[(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/yuly3",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/25814001?u=4b57756e7d8060e48262a9edba687927fe7934a6&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"MasakiMiyazaki"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/kallydev",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/36319157?u=5be882aa4dbe7eea97b1a80a6473857369146df6&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"KallyDev"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/manfredcml",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/27536502?u=b71636bdabbc698458b32e2ac05c5771ad41097e&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Manfred Lee"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/tugascript",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/64930104?u=ad9f63e8e221dbe71bf23de59e3611c99cda1181&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Afonso Barracha"})})]})}),(0,s.jsx)("div",{class:"col col--4 margin-bottom--md",children:(0,s.jsxs)("div",{class:"avatar",children:[(0,s.jsx)("a",{class:"avatar__photo-link avatar__photo avatar__photo--sm",href:"https://github.com/deansheather",children:(0,s.jsx)("img",{src:"https://avatars.githubusercontent.com/u/11241812?u=260538c7d8b8c3c5350dba175ebb8294358441e0&v=4"})}),(0,s.jsx)("div",{class:"avatar__intro",children:(0,s.jsx)("div",{class:"avatar__name",children:"Dean Sheather"})})]})})]}),"\n",(0,s.jsx)(t.h2,{id:"-rustacean-sticker-pack",children:"\ud83e\udd80 Rustacean Sticker Pack"}),"\n",(0,s.jsx)(t.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish."}),"\n",(0,s.jsx)(t.p,{children:"Sticker Pack Contents:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography"}),"\n",(0,s.jsx)(t.li,{children:"Mascots: Ferris the Crab x 3, Terres the Hermit Crab"}),"\n",(0,s.jsx)(t.li,{children:"The Rustacean wordmark"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,s.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,s.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var n=a(6540);const s={},i=n.createContext(s);function o(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);