"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[4241],{2166:e=>{e.exports=JSON.parse('{"permalink":"/blog/2026-02-25-sea-orm-x","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2026-02-25-sea-orm-x.md","source":"@site/blog/2026-02-25-sea-orm-x.md","title":"SeaORM 2.0 with SQL Server Support","description":"SeaORM X is a proprietary extension of SeaORM with first-class Microsoft SQL Server support. It covers the same API surface, with the full test suite and examples ported to MSSQL. With SeaORM 2.0, SeaORM X has been rebuilt on top of it: every improvement in the open-source release ships to MSSQL users too.","date":"2026-02-25T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":7.74,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2026-02-25-sea-orm-x","title":"SeaORM 2.0 with SQL Server Support","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"SeaORM now supports Arrow & Parquet","permalink":"/blog/2026-02-22-sea-orm-arrow"}}')},3021:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var a=t(2166),i=t(4848),s=t(8453);const r={slug:"2026-02-25-sea-orm-x",title:"SeaORM 2.0 with SQL Server Support",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What&#39;s in SeaORM X",id:"whats-in-seaorm-x",level:2},{value:"1. Native MSSQL Driver via SQLz with Connection Pooling",id:"1-native-mssql-driver-via-sqlz-with-connection-pooling",level:3},{value:"2. Nested Transactions via Savepoints",id:"2-nested-transactions-via-savepoints",level:3},{value:"3. Automatic Schema Rewriting",id:"3-automatic-schema-rewriting",level:3},{value:"4. <code>OUTPUT</code> Clause for <code>RETURNING</code>",id:"4-output-clause-for-returning",level:3},{value:"5. Automatic <code>IDENTITY_INSERT</code> Handling",id:"5-automatic-identity_insert-handling",level:3},{value:"6. Tuple <code>IN</code> Fallback for MSSQL",id:"6-tuple-in-fallback-for-mssql",level:3},{value:"7. i64 / i32 Type Coercion",id:"7-i64--i32-type-coercion",level:3},{value:"8. Schema-First and Entity-First Workflows",id:"8-schema-first-and-entity-first-workflows",level:3},{value:"9. <code>execute_unprepared</code> via Raw TDS Batch",id:"9-execute_unprepared-via-raw-tds-batch",level:3},{value:"10. Built on SeaORM 2.0",id:"10-built-on-seaorm-20",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Getting Access",id:"getting-access",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.sea-ql.org/SeaORM-X/",children:"SeaORM X"})," is a proprietary extension of SeaORM with first-class Microsoft SQL Server support. It covers the same API surface, with the full test suite and examples ported to MSSQL. With SeaORM 2.0, SeaORM X has been rebuilt on top of it: every improvement in the open-source release ships to MSSQL users too."]}),"\n",(0,i.jsxs)(n.p,{children:["If you are building enterprise software on SQL Server, you can ",(0,i.jsx)(n.a,{href:"https://forms.office.com/r/1MuRPJmYBR",children:"request commercial access"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"whats-in-seaorm-x",children:"What's in SeaORM X"}),"\n",(0,i.jsx)(n.h3,{id:"1-native-mssql-driver-via-sqlz-with-connection-pooling",children:"1. Native MSSQL Driver via SQLz with Connection Pooling"}),"\n",(0,i.jsxs)(n.p,{children:["SeaORM X ships a full ",(0,i.jsx)(n.code,{children:"ConnectionPool"})," driver for SQL Server (",(0,i.jsx)(n.code,{children:"mssql://"})," URI scheme) built on top of the SQLz/TDS stack. You get the same ",(0,i.jsx)(n.code,{children:"Database::connect(url)"})," ergonomics as MySQL, PostgreSQL, and SQLite: no separate client setup required."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let db = Database::connect("mssql://user:pass@localhost:1433?trustCertificate=true").await?;\n'})}),"\n",(0,i.jsx)(n.p,{children:"The underlying SQLz pool is a parallel implementation of SQLx's pool architecture applied to SQL Server. It supports the same lifecycle hooks as SQLx:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"after_connect"}),": initialize a freshly opened connection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"before_acquire"}),": validate an idle connection before handing it out"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"after_release"}),": clean up before returning a connection to the pool"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["All standard ",(0,i.jsx)(n.code,{children:"PoolOptions"})," settings are supported: ",(0,i.jsx)(n.code,{children:"max_connections"}),", ",(0,i.jsx)(n.code,{children:"min_connections"}),", ",(0,i.jsx)(n.code,{children:"acquire_timeout"}),", ",(0,i.jsx)(n.code,{children:"max_lifetime"}),", ",(0,i.jsx)(n.code,{children:"idle_timeout"}),", ",(0,i.jsx)(n.code,{children:"test_before_acquire"}),", etc."]}),"\n",(0,i.jsx)(n.h3,{id:"2-nested-transactions-via-savepoints",children:"2. Nested Transactions via Savepoints"}),"\n",(0,i.jsx)(n.p,{children:"SQLz tracks transaction depth as a counter on the connection and maps it to MSSQL's savepoint syntax transparently:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Depth"}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"begin"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"commit"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.code,{children:"rollback"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0 \u2192 1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BEGIN TRAN"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"COMMIT TRAN"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ROLLBACK TRAN"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"n \u2192 n+1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SAVE TRAN _sqlz_savepoint_n"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.em,{children:"(no-op: SQL Server releases savepoints implicitly)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ROLLBACK TRAN _sqlz_savepoint_n"})})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"db.transaction(|tx| tx.transaction(|tx2| ...))"})," gives correct nested rollback semantics: rolling back an inner block unwinds only to the savepoint, leaving the outer transaction intact."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let txn = db.begin().await?;\n\n{\n    let txn = txn.begin().await?;\n    let _ = bakery::ActiveModel { name: Set("Nested Bakery".to_owned()), .. }.save(&txn).await?;\n    assert_eq!(Bakery::find().all(&txn).await?.len(), 3);\n\n    {\n        let txn = txn.begin().await?;\n        let _ = bakery::ActiveModel { name: Set("Rock n Roll Bakery".to_owned()), .. }.save(&txn).await?;\n        assert_eq!(Bakery::find().all(&txn).await?.len(), 4);\n        // txn dropped here without commit: rolls back to savepoint\n    }\n    assert_eq!(Bakery::find().all(&txn).await?.len(), 3);\n\n    {\n        let txn = txn.begin().await?;\n        let _ = bakery::ActiveModel { name: Set("Rock n Roll Bakery".to_owned()), .. }.save(&txn).await?;\n        txn.commit().await?;\n    }\n    txn.commit().await?;\n}\n\nassert_eq!(Bakery::find().all(&txn).await?.len(), 4);\ntxn.commit().await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"BEGIN TRAN\n  SAVE TRAN _sqlz_savepoint_1\n    SAVE TRAN _sqlz_savepoint_2\n    ROLLBACK TRAN _sqlz_savepoint_2   -- drop without commit\n    SAVE TRAN _sqlz_savepoint_2\n    -- (savepoint 2 released implicitly on commit)\n  -- (savepoint 1 released implicitly on commit)\nCOMMIT TRAN\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(n.code,{children:"Transaction"})," is dropped without an explicit commit, SQLz spawns a local async task to execute ",(0,i.jsx)(n.code,{children:"ROLLBACK"})," immediately and marks the connection as ",(0,i.jsx)(n.code,{children:"RollingBack"}),". Any subsequent use of that connection awaits the rollback task before proceeding, making cleanup deterministic rather than deferred to an arbitrary future await point."]}),"\n",(0,i.jsx)(n.h3,{id:"3-automatic-schema-rewriting",children:"3. Automatic Schema Rewriting"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ConnectionTrait"})," gains a ",(0,i.jsx)(n.code,{children:"get_schema()"})," hook. When a connection is configured with a non-default schema (e.g. ",(0,i.jsx)(n.code,{children:"dbo"}),", ",(0,i.jsx)(n.code,{children:"sales"}),"), SeaORM X automatically prefixes every outgoing statement with that schema. No manual ",(0,i.jsx)(n.code,{children:"[schema].[table]"})," boilerplate in application code."]}),"\n",(0,i.jsxs)(n.p,{children:["The rewriting is backed by the ",(0,i.jsx)(n.code,{children:"OverrideTableSchema"})," trait, implemented for every sea-query statement type. Schema rewriting propagates recursively into subqueries, JOINs, and CTE branches."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// specify schema other than dbo\nlet db = Database::connect(\n    "mssql://user:pass@localhost:1433/my_db?currentSchema=my_schema").await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let related = cake::Entity::find()\n    .has_related(filling::Entity, filling::Column::Name.eq("Marmalade"))\n    .all(db)\n    .await?;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT [cake].[id], [cake].[name] FROM [my_schema].[cake]\nWHERE EXISTS(SELECT 1 FROM [my_schema].[filling]\n  INNER JOIN [my_schema].[cake_filling] ON [cake_filling].[filling_id] = [filling].[id]\n  WHERE [filling].[name] = 'Marmalade'\n  AND [cake].[id] = [cake_filling].[cake_id])\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-output-clause-for-returning",children:["4. ",(0,i.jsx)(n.code,{children:"OUTPUT"})," Clause for ",(0,i.jsx)(n.code,{children:"RETURNING"})]}),"\n",(0,i.jsxs)(n.p,{children:["SeaORM X maps SeaORM's ",(0,i.jsx)(n.code,{children:"RETURNING"})," semantics to MSSQL's ",(0,i.jsx)(n.code,{children:"OUTPUT"})," syntax:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"INSERT"})," \u2192 ",(0,i.jsx)(n.code,{children:"OUTPUT INSERTED.*"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DELETE"})," \u2192 ",(0,i.jsx)(n.code,{children:"OUTPUT DELETED.*"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Constraint violations (",(0,i.jsx)(n.code,{children:"UniqueConstraintViolation"}),", ",(0,i.jsx)(n.code,{children:"ForeignKeyConstraintViolation"}),") surfacing through the ",(0,i.jsx)(n.code,{children:"OUTPUT"})," path are caught and returned as typed ",(0,i.jsx)(n.code,{children:"DbErr"})," variants, not raw driver errors."]}),"\n",(0,i.jsxs)(n.h3,{id:"5-automatic-identity_insert-handling",children:["5. Automatic ",(0,i.jsx)(n.code,{children:"IDENTITY_INSERT"})," Handling"]}),"\n",(0,i.jsxs)(n.p,{children:["When inserting a model with an explicit primary-key value on an auto-increment column, SeaORM X automatically wraps the statement in ",(0,i.jsx)(n.code,{children:"SET IDENTITY_INSERT ON/OFF"}),": no manual SQL required."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// From tests/empty_insert_tests.rs\nlet seaside_bakery = bakery::ActiveModel {\n    name: Set("SeaSide Bakery".to_owned()),\n    profit_margin: Set(10.4),\n    ..Default::default() // id not set: normal insert\n};\nBakery::insert(seaside_bakery).exec(db).await?;\n\nlet double_seaside_bakery = bakery::ActiveModel {\n    id: Set(1), // explicit PK: triggers IDENTITY_INSERT automatically\n    name: Set("SeaSide Bakery".to_owned()),\n    profit_margin: Set(10.4),\n    ..Default::default()\n};\nlet res = Bakery::insert_many([double_seaside_bakery])\n    .on_conflict_do_nothing()\n    .exec(db)\n    .await;\nassert!(matches!(res, Ok(TryInsertResult::Conflicted)));\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Normal insert: no IDENTITY_INSERT\nINSERT INTO [bakery] ([name], [profit_margin]) OUTPUT [INSERTED].[id] VALUES ('SeaSide Bakery', 10.4)\n\n-- Explicit PK insert: wrapped automatically\nSET IDENTITY_INSERT [bakery] ON;\nINSERT INTO [bakery] ([id], [name], [profit_margin]) OUTPUT [INSERTED].[id] VALUES (1, 'SeaSide Bakery', 10.4);\nSET IDENTITY_INSERT [bakery] OFF\n-- PK conflict \u2192 returned as TryInsertResult::Conflicted, not a panic\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"6-tuple-in-fallback-for-mssql",children:["6. Tuple ",(0,i.jsx)(n.code,{children:"IN"})," Fallback for MSSQL"]}),"\n",(0,i.jsxs)(n.p,{children:["MSSQL does not support tuple value syntax (",(0,i.jsx)(n.code,{children:"(c1, c2) IN ((v1, v2), ...)"}),"). SeaORM X adds ",(0,i.jsx)(n.code,{children:"EntityTrait::column_tuple_in()"}),", which expands to ",(0,i.jsx)(n.code,{children:"(c1 = v1 AND c2 = v2) OR ..."})," when targeting MSSQL."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'cake::Entity::find()\n    .filter(cake::Entity::column_tuple_in(\n        [cake::Column::Id, cake::Column::Name],\n        &[(1i32, "a").into_value_tuple(), (2i32, "b").into_value_tuple()],\n        DbBackend::MySql,\n    ).unwrap())\n    .build(DbBackend::MySql)\n    .to_string();\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- MySQL: native tuple syntax:\nSELECT `cake`.`id`, `cake`.`name` FROM `cake`\nWHERE (`cake`.`id`, `cake`.`name`) IN ((1, 'a'), (2, 'b'))\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'cake::Entity::find()\n    .filter(cake::Entity::column_tuple_in(\n        [cake::Column::Id, cake::Column::Name],\n        &[(1i32, "a").into_value_tuple(), (2i32, "b").into_value_tuple()],\n        DbBackend::MsSql,\n    ).unwrap())\n    .build(DbBackend::MsSql)\n    .to_string();\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- MSSQL: automatically expands to AND/OR:\nSELECT [cake].[id], [cake].[name] FROM [cake]\nWHERE ([cake].[id] = 1 AND [cake].[name] = 'a') OR ([cake].[id] = 2 AND [cake].[name] = 'b')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"7-i64--i32-type-coercion",children:"7. i64 / i32 Type Coercion"}),"\n",(0,i.jsxs)(n.p,{children:["MSSQL returns ",(0,i.jsx)(n.code,{children:"INT"})," columns as ",(0,i.jsx)(n.code,{children:"i32"})," at the wire level. SeaORM X handles the coercion transparently: no schema changes or manual casting required."]}),"\n",(0,i.jsx)(n.h3,{id:"8-schema-first-and-entity-first-workflows",children:"8. Schema-First and Entity-First Workflows"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Schema-first:"})," point ",(0,i.jsx)(n.code,{children:"sea-orm-cli generate entity"})," at an existing MSSQL database and get ready-to-compile Rust entity files."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:'sea-orm-cli generate entity \\\n  --database-url "mssql://sa:pass@localhost/AdventureWorksLT2016" \\\n  --database-schema "SalesLT"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Generated address.rs\n#[sea_orm(schema_name = "SalesLT", table_name = "Address")]\npub struct Model {\n    #[sea_orm(column_name = "AddressID", primary_key)]\n    pub address_id: i32,\n    #[sea_orm(column_name = "AddressLine1")]\n    pub address_line1: String,\n    pub rowguid: Uuid,\n    // ...\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Entity-first:"})," define entities in Rust and let SeaORM sync the schema to the database. Tables, columns, unique keys, and foreign keys are created in topological order: no manual migration file needed."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Requires the `schema-sync` feature flag\ndb.get_schema_builder()\n    .register(order::Entity)\n    .register(store::Entity)\n    .sync(db)\n    .await?;\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"9-execute_unprepared-via-raw-tds-batch",children:["9. ",(0,i.jsx)(n.code,{children:"execute_unprepared"})," via Raw TDS Batch"]}),"\n",(0,i.jsxs)(n.p,{children:["For DDL and migration scenarios, ",(0,i.jsx)(n.code,{children:"execute_unprepared"})," uses the raw TDS ",(0,i.jsx)(n.code,{children:"execute_batch"})," path rather than prepared statements. This preserves temp-table visibility across statement batches: a common requirement for MSSQL migration and stored-procedure patterns that break under prepared statement isolation."]}),"\n",(0,i.jsx)(n.h3,{id:"10-built-on-seaorm-20",children:"10. Built on SeaORM 2.0"}),"\n",(0,i.jsx)(n.p,{children:"Because SeaORM X tracks the open-source release, all SeaORM 2.0 improvements are available to MSSQL users. Highlights:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"New entity format"}),": a dense, readable layout with relations declared inline on the model struct, generated with ",(0,i.jsx)(n.code,{children:"--entity-format dense"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[sea_orm::model]\n#[sea_orm(table_name = "post")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub user_id: i32,\n    #[sea_orm(belongs_to, from = "user_id", to = "id")]\n    pub author: HasOne<super::user::Entity>,\n    #[sea_orm(has_many, via = "post_tag")]\n    pub tags: HasMany<super::tag::Entity>,\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Smart Entity Loader"}),": automatically chooses JOIN for 1-1 and the data-loader pattern for 1-N, eliminating the N+1 problem in nested queries."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nested ActiveModel persistence"}),": insert an entire object graph (user \u2192 profile 1-1, posts 1-N, tags M-N) in a single ",(0,i.jsx)(n.code,{children:".save(db).await?"})," call."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Strongly-typed columns"}),": ",(0,i.jsx)(n.code,{children:'Cake::COLUMN.name.contains("chocolate")'})," with methods specific to the column type."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Injection-safe ",(0,i.jsx)(n.code,{children:"raw_sql!"})," macro"]}),": use ",(0,i.jsx)(n.code,{children:"{param}"})," interpolation and ",(0,i.jsx)(n.code,{children:"{..array}"})," expansion in raw SQL without opening the door to SQL injection."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"DerivePartialModel"})," with ",(0,i.jsx)(n.code,{children:"#[sea_orm(nested)]"})]}),": select only the fields you need across joins and map them into typed partial structs, preventing overfetching."]}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsx)(n.p,{children:"SQLz is a purpose-built SQL Server driver, not a full SQLx port. Known gaps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No compile-time query checking."})," SQLx's ",(0,i.jsx)(n.code,{children:"sqlx::query!"})," macro verifies SQL against a live database at compile time. SQLz has no equivalent; queries are checked at runtime only."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No custom type encoding/decoding."})," SQLx supports user-defined ",(0,i.jsx)(n.code,{children:"Encode"}),"/",(0,i.jsx)(n.code,{children:"Decode"})," implementations for arbitrary Rust types. SQLz ships a fixed set of supported types (primitives, ",(0,i.jsx)(n.code,{children:"uuid"}),", ",(0,i.jsx)(n.code,{children:"Decimal"}),", ",(0,i.jsx)(n.code,{children:"BigDecimal"}),", ",(0,i.jsx)(n.code,{children:"chrono"}),", ",(0,i.jsx)(n.code,{children:"time"}),", ",(0,i.jsx)(n.code,{children:"serde_json"}),") behind feature flags. Adding a new wire type requires changes inside SQLz itself."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getting-access",children:"Getting Access"}),"\n",(0,i.jsx)(n.p,{children:"SeaORM X is a commercial offering for teams that need SQL Server support in Rust without leaving the SeaORM ecosystem. It has been tested against complex schemas including Sakila and AdventureWorks, and is used in production by companies today."}),"\n",(0,i.jsx)(n.p,{children:"The practical upside for teams already on SeaORM: there is no second API to learn or maintain. Queries, relations, transactions all carry over unchanged. Developers can be productive on day one, and adding SQL Server to an existing multi-database project does not require parallel ORM maintenance or separate migration tooling."}),"\n",(0,i.jsx)(n.p,{children:"For greenfield projects on legacy MSSQL schemas, the CLI codegen eliminates the mechanical work of writing entity files by hand."}),"\n",(0,i.jsxs)(n.p,{children:["SeaORM X is distributed under a commercial license. To evaluate it or discuss access for your team, ",(0,i.jsx)(n.a,{href:"https://forms.office.com/r/1MuRPJmYBR",children:"request access here"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);