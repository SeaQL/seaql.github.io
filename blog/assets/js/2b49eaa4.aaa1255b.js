"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[9503],{2851:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025-10-30-sea-orm-2.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-10-30-sea-orm-2.0.md","source":"@site/blog/2025-10-30-sea-orm-2.0.md","title":"SeaORM 2.0: Entity First Workflow","description":"In our last post, we introduced a new Entity format - designed to be more concise, more readable, and easy to write by hand.","date":"2025-10-30T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":5.92,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-10-30-sea-orm-2.0","title":"SeaORM 2.0: Entity First Workflow","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"SeaORM 2.0: New Entity Format","permalink":"/blog/2025-10-20-sea-orm-2.0"}}')},5717:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var i=t(2851),a=t(4848),o=t(8453);const s={slug:"2025-10-30-sea-orm-2.0",title:"SeaORM 2.0: Entity First Workflow",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},r=void 0,l={authorsImageUrls:[void 0]},d=[{value:"What&#39;s Entity first?",id:"whats-entity-first",level:2},{value:"Unfolding",id:"unfolding",level:2},{value:"Resolving Entity Relations",id:"resolving-entity-relations",level:3},{value:"Schema Sync in Action",id:"schema-sync-in-action",level:2},{value:"Adding Table",id:"adding-table",level:3},{value:"Adding Columns",id:"adding-columns",level:3},{value:"Rename Column",id:"rename-column",level:3},{value:"Add Foreign Key",id:"add-foreign-key",level:3},{value:"Add Unique Key",id:"add-unique-key",level:3},{value:"Remove Unique Key",id:"remove-unique-key",level:3},{value:"Footnotes",id:"footnotes",level:3},{value:"GraphQL API",id:"graphql-api",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,a.jsxs)(n.p,{children:["In our last post, we introduced a ",(0,a.jsx)(n.a,{href:"https://www.sea-ql.org/blog/2025-10-20-sea-orm-2.0/",children:"new Entity format"})," - designed to be more concise, more readable, and easy to write by hand."]}),"\n",(0,a.jsx)(n.p,{children:"With this format, you can embrace an Entity\u2011first workflow: stay focused on your domain model without getting bogged down in database tables or migration scripts."}),"\n",(0,a.jsxs)(n.p,{children:["And the best part? Pair it with ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"})," and you'll have a working GraphQL API instantly - meaning you can skip writing most of the backend logic code until much later in your project's lifecycle."]}),"\n",(0,a.jsx)(n.p,{children:"This combination keeps you in the flow, and lets you focus on what really matters: building apps."}),"\n",(0,a.jsx)(n.h2,{id:"whats-entity-first",children:"What's Entity first?"}),"\n",(0,a.jsx)(n.p,{children:"SeaORM used to adopt a schema\u2011first approach: meaning you design database tables and write migration scripts first, then generate entities from that schema."}),"\n",(0,a.jsx)(n.p,{children:"Entity\u2011first flips the flow: you hand-write the entity files, and let SeaORM generates the tables and foreign keys for you."}),"\n",(0,a.jsxs)(n.p,{children:["All you have to do is to add the following to your ",(0,a.jsx)(n.code,{children:"main.rs"})," right after creating the database connection:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let db = &Database::connect(db_url).await?;\n// synchronizes database schema with entity definitions\ndb.get_schema_registry("my_crate::entity::*").sync(db).await?;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This requires two feature flags ",(0,a.jsx)(n.code,{children:"schema-sync"})," and ",(0,a.jsx)(n.code,{children:"entity-registry"}),", and we're going to explain what they do."]}),"\n",(0,a.jsx)(n.h2,{id:"unfolding",children:"Unfolding"}),"\n",(0,a.jsxs)(n.p,{children:["The above function ",(0,a.jsx)(n.code,{children:"get_schema_registry"})," desugars into the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"db.get_schema_builder()\n    .register(comment::Entity)\n    .register(post::Entity)\n    .register(profile::Entity)\n    .register(user::Entity)\n    .sync(db)\n    .await?;\n"})}),"\n",(0,a.jsx)(n.p,{children:"You might be wondering: how can SeaORM recognize my entities when, at compile time, the SeaORM crate itself has no knowledge of them?"}),"\n",(0,a.jsxs)(n.p,{children:["Rest assured, there's no source\u2011file scanning or other hacks involved - this is powered by the brilliant ",(0,a.jsx)(n.a,{href:"https://docs.rs/inventory/latest/inventory/",children:(0,a.jsx)(n.code,{children:"inventory"})})," crate. The ",(0,a.jsx)(n.code,{children:"inventory"})," crate works by registering items (called plugins) into linker-collected sections."]}),"\n",(0,a.jsxs)(n.p,{children:["At compile-time, each ",(0,a.jsx)(n.code,{children:"Entity"})," module registers itself to the global ",(0,a.jsx)(n.code,{children:"inventory"})," along with their module paths and some metadata. On runtime, SeaORM then filters the Entities you requested and construct a ",(0,a.jsx)(n.code,{children:"SchemaBuilder"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"EntityRegistry"})," is completely optional and just adds extra convenience, it's perfectly fine for you to ",(0,a.jsx)(n.code,{children:"register"})," Entities manually like above."]}),"\n",(0,a.jsx)(n.h3,{id:"resolving-entity-relations",children:"Resolving Entity Relations"}),"\n",(0,a.jsxs)(n.p,{children:["If you remember from the previous post, you'll notice that ",(0,a.jsx)(n.code,{children:"comment"})," has a foreign key referencing ",(0,a.jsx)(n.code,{children:"post"}),". Since SQLite doesn't allow adding foreign keys after the fact, the ",(0,a.jsx)(n.code,{children:"post"})," table must be created before the ",(0,a.jsx)(n.code,{children:"comment"})," table."]}),"\n",(0,a.jsx)(n.p,{children:"This is where SeaORM shines: it automatically builds a dependency graph from your entities and determines the correct topological order to create the tables, so you don't have to keep track of them in your head."}),"\n",(0,a.jsx)(n.h2,{id:"schema-sync-in-action",children:"Schema Sync in Action"}),"\n",(0,a.jsxs)(n.p,{children:["The second feature, ",(0,a.jsx)(n.code,{children:"schema-sync"}),", compares the in\u2011memory entity definitions with the live database schema, detects missing tables, columns, and keys, and creates them idempotently - no matter how many times you run ",(0,a.jsx)(n.code,{children:"sync"}),", the schema converges to the same state."]}),"\n",(0,a.jsx)(n.p,{children:"Let's walk through the different scenarios:"}),"\n",(0,a.jsx)(n.h3,{id:"adding-table",children:"Adding Table"}),"\n",(0,a.jsxs)(n.p,{children:["Let's say you added a new Entity under ",(0,a.jsx)(n.code,{children:"mod.rs"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"//! `SeaORM` Entity, @generated by sea-orm-codegen 2.0.0-rc.14\n\npub mod prelude;\n\npub mod post;\npub mod upvote; // \u2b05 new entity module\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The next time you ",(0,a.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'CREATE TABLE "upvote" ( "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, .. )\n'})}),"\n",(0,a.jsx)(n.p,{children:"This will create the table along with any foreign keys."}),"\n",(0,a.jsx)(n.h3,{id:"adding-columns",children:"Adding Columns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'mod profile {\n    use sea_orm::entity::prelude::*;\n\n    #[sea_orm::model]\n    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n    #[sea_orm(table_name = "profile")]\n    pub struct Model {\n        #[sea_orm(primary_key)]\n        pub id: i32,\n        pub picture: String,\n        pub date_of_birth: Option<DateTimeUtc>, // \u2b05 new column\n    }\n\n    impl ActiveModelBehavior for ActiveModel {}\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The next time you ",(0,a.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'ALTER TABLE "profile" ADD COLUMN "date_of_birth" timestamp with time zone\n'})}),"\n",(0,a.jsxs)(n.p,{children:["How about adding a non-nullable column? You can set a ",(0,a.jsx)(n.code,{children:"default_value"})," or ",(0,a.jsx)(n.code,{children:"default_expr"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[sea_orm(default_value = 0)]\npub post_count: i32,\n\n// this doesn\'t work in SQLite\n#[sea_orm(default_expr = "Expr::current_timestamp()")]\npub updated_at: DateTimeUtc,\n'})}),"\n",(0,a.jsx)(n.h3,{id:"rename-column",children:"Rename Column"}),"\n",(0,a.jsx)(n.p,{children:"If you only want to rename the field name in code, you can simply remap the column name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'pub struct Model {\n    ..\n    #[sea_orm(column_name = "date_of_birth")]\n    pub dob: Option<DateTimeUtc>, // \u2b05 renamed for brevity\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This doesn't involve any schema change."}),"\n",(0,a.jsx)(n.p,{children:"If you want to actually rename the column, then you have to add a special attribute. Note that you can't simply change the field name, as this will be recognized as adding a new column."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'pub struct Model {\n    ..\n    #[sea_orm(renamed_from = "date_of_birth")] // \u2b05 special annotation\n    pub dob: Option<DateTimeUtc>,\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The next time you ",(0,a.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'ALTER TABLE "profile" RENAME COLUMN "date_of_birth" TO "dob"\n'})}),"\n",(0,a.jsx)(n.p,{children:"Nice, isn't it?"}),"\n",(0,a.jsx)(n.h3,{id:"add-foreign-key",children:"Add Foreign Key"}),"\n",(0,a.jsx)(n.p,{children:"Let's say we create a new table with a foreign key:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'mod upvote {\n    use sea_orm::entity::prelude::*;\n\n    #[sea_orm::model]\n    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n    #[sea_orm(table_name = "upvote")]\n    pub struct Model {\n        #[sea_orm(primary_key, auto_increment = false)]\n        pub post_id: i32,\n        #[sea_orm(belongs_to, from = "post_id", to = "id")]\n        pub post: HasOne<super::post::Entity>,\n        ..\n    }\n\n    impl ActiveModelBehavior for ActiveModel {}\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'CREATE TABLE "upvote" (\n    "post_id" integer NOT NULL PRIMARY KEY,\n    ..\n    FOREIGN KEY ("post_id") REFERENCES "post" ("id")\n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If however, the ",(0,a.jsx)(n.code,{children:"post"})," relation is added after the table has been created, then the foreign key couldn't be created for SQLite. The relational query would still work, but functions completely client-side."]}),"\n",(0,a.jsx)(n.h3,{id:"add-unique-key",children:"Add Unique Key"}),"\n",(0,a.jsx)(n.p,{children:"Now, let's say we've forgotten to add a unique constraint on user name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'mod user {\n    use sea_orm::entity::prelude::*;\n\n    #[sea_orm::model]\n    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n    #[sea_orm(table_name = "user")]\n    pub struct Model {\n        #[sea_orm(primary_key)]\n        pub id: i32,\n        #[sea_orm(unique)] // \u2b05 add unique key\n        pub name: String,\n        #[sea_orm(unique)]\n        pub email: String,\n        ..\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The next time you ",(0,a.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'CREATE UNIQUE INDEX "idx-user-name" ON "user" ("name")\n'})}),"\n",(0,a.jsx)(n.p,{children:"As mentioned in the previous blog post, you'll also get a shorthand method generated on the Entity for free:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'user::Entity::find_by_name("Bob")..\n'})}),"\n",(0,a.jsx)(n.h3,{id:"remove-unique-key",children:"Remove Unique Key"}),"\n",(0,a.jsx)(n.p,{children:"Well, you've changed your mind and want to remove the unique constraint on user name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    // no annotation\n    pub name: String,\n    #[sea_orm(unique)]\n    pub email: String,\n    ..\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The next time you ",(0,a.jsx)(n.code,{children:"cargo run"}),", you'll see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:'DROP INDEX "idx-user-name"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"footnotes",children:"Footnotes"}),"\n",(0,a.jsxs)(n.p,{children:["Note that in general schema sync would not attempt to do any destructive actions, so meaning no ",(0,a.jsx)(n.code,{children:"DROP"})," on table, column and foreign keys. Dropping index is an exception here."]}),"\n",(0,a.jsxs)(n.p,{children:["Every time when the application starts, a full schema discovery is done. It's not recommended to enable this in production, and so this is gated behind a feature flag ",(0,a.jsx)(n.code,{children:"schema-sync"})," that can be turned off depending on build profile."]}),"\n",(0,a.jsx)(n.h2,{id:"graphql-api",children:"GraphQL API"}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"}),", the Entities you wrote can instantly be exposed as a GraphQL schema, with full CRUD, filtering and pagination. The GraphQL data loader is actually more powerful, as it allows nesting relations with arbitrary complexity."]}),"\n",(0,a.jsx)(n.p,{children:"With SeaORM and Seaography, you can prototype quickly and stay in the flow. And because Seaography is highly customizable, you can gradually shift resolver logic into your own implementation as the application evolves, and layer access control on top before the project goes to production."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(6540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);