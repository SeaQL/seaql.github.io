"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[6535],{8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var t=s(6540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}},9467:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>o});var t=s(9757),r=s(4848),a=s(8453);const i={slug:"2025-12-12-sea-orm-2.0",title:"How we made SeaORM synchronous",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},c=void 0,l={authorsImageUrls:[void 0]},o=[{value:"Gist",id:"gist",level:2},{value:"Async -&gt; Sync",id:"async---sync",level:2},{value:"1. <code>async</code> / <code>await</code>",id:"1-async--await",level:3},{value:"2. <code>#[main]</code> / <code>#[test]</code>",id:"2-main--test",level:3},{value:"3. <code>async_trait</code>",id:"3-async_trait",level:3},{value:"4. <code>Send + Sync</code>",id:"4-send--sync",level:3},{value:"5. <code>BoxFuture</code>",id:"5-boxfuture",level:3},{value:"6. <code>Box::pin(async move { .. })</code>",id:"6-boxpinasync-move---",level:3},{value:"7. <code>Mutex</code>",id:"7-mutex",level:3},{value:"<code>std::sync::Mutex::lock()</code>",id:"stdsyncmutexlock",level:4},{value:"<code>tokio::sync::Mutex::lock().await</code>",id:"tokiosyncmutexlockawait",level:4},{value:"8. <code>Stream</code>",id:"8-stream",level:3},{value:"<code>Box&lt;dyn Stream&gt;</code>",id:"boxdyn-stream",level:4},{value:"<code>impl Stream</code> bounds",id:"impl-stream-bounds",level:4},{value:"<code>impl Stream for</code>",id:"impl-stream-for",level:4},{value:"<code>TryStreamExt</code>",id:"trystreamext",level:4},{value:"9. File / Network I/O",id:"9-file--network-io",level:3},{value:"Conclusion: SQLite + SeaORM Sync = \u26a1",id:"conclusion-sqlite--seaorm-sync--",level:2},{value:"SeaORM 2.0 RC",id:"seaorm-20-rc",level:2},{value:"\ud83e\udd80 Rustacean Sticker Pack",id:"-rustacean-sticker-pack",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,r.jsx)(n.p,{children:"SeaORM began as Rust's first async\u2011first ORM. Now we've come full circle with a synchronous crate: perfect for building lightweight CLI programs with SQLite."}),"\n",(0,r.jsx)(n.p,{children:"In this post, we'll share how we ported a complex library like SeaORM, the tricks we learnt along the way, and the steps we're taking to keep it maintainable for the long run."}),"\n",(0,r.jsx)(n.h2,{id:"gist",children:"Gist"}),"\n",(0,r.jsxs)(n.p,{children:["We took an approach of translation: we wrote a ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/build-tools/make-sync.sh",children:"script"})," to convert async functions into synchronous ones. (It's more than a simple find\u2011and\u2011replace.)"]}),"\n",(0,r.jsxs)(n.p,{children:["The script would read the ",(0,r.jsx)(n.code,{children:"src"})," directory and rewrite that into a new crate ",(0,r.jsx)(n.a,{href:"http://crates.io/crates/sea-orm-sync",children:(0,r.jsx)(n.code,{children:"sea-orm-sync"})}),". This crate isn't a fork: it will be continually rebased on sea-orm, inheriting all new features and bug fixes."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"sea-orm-sync"})," supports the entire SeaORM's API surface, including recent features like Entity Loader, Nested ActiveModel and Entity-First workflow."]}),"\n",(0,r.jsx)(n.h2,{id:"async---sync",children:"Async -> Sync"}),"\n",(0,r.jsxs)(n.p,{children:["At a high level, async Rust can be seen as a more complex form of sync Rust. So converting an async program is possible by stripping out the runtime and removing all ",(0,r.jsx)(n.code,{children:"async"})," / ",(0,r.jsx)(n.code,{children:"await"})," usage."]}),"\n",(0,r.jsxs)(n.p,{children:["However, you can't always go from sync to async. Async Rust tightens lifetime rules and introduces ",(0,r.jsx)(n.code,{children:"Send"})," / ",(0,r.jsx)(n.code,{children:"Sync"})," requirements for futures and async closures, so existing sync code may fail those constraints."]}),"\n",(0,r.jsx)(n.p,{children:"Now, let's go from all the necessary conversions, in order of complexity:"}),"\n",(0,r.jsxs)(n.h3,{id:"1-async--await",children:["1. ",(0,r.jsx)(n.code,{children:"async"})," / ",(0,r.jsx)(n.code,{children:"await"})]}),"\n",(0,r.jsxs)(n.p,{children:["Removing all ",(0,r.jsx)(n.code,{children:"async"})," and ",(0,r.jsx)(n.code,{children:".await"})," keywords will almost make it compile."]}),"\n",(0,r.jsxs)(n.h3,{id:"2-main--test",children:["2. ",(0,r.jsx)(n.code,{children:"#[main]"})," / ",(0,r.jsx)(n.code,{children:"#[test]"})]}),"\n",(0,r.jsxs)(n.p,{children:["Simply remove ",(0,r.jsx)(n.code,{children:"tokio"})," / ",(0,r.jsx)(n.code,{children:"async-std"})," from Cargo and remove ",(0,r.jsx)(n.code,{children:"#[tokio::main]"}),". Then replace ",(0,r.jsx)(n.code,{children:"#[tokio::test]"})," with ",(0,r.jsx)(n.code,{children:"#[test]"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"3-async_trait",children:["3. ",(0,r.jsx)(n.code,{children:"async_trait"})]}),"\n",(0,r.jsxs)(n.p,{children:["Simply remove ",(0,r.jsx)(n.code,{children:"#[async_trait]"})," usage and it's Cargo dependency."]}),"\n",(0,r.jsxs)(n.h3,{id:"4-send--sync",children:["4. ",(0,r.jsx)(n.code,{children:"Send + Sync"})]}),"\n",(0,r.jsxs)(n.p,{children:["Most ",(0,r.jsx)(n.code,{children:"Send"})," and ",(0,r.jsx)(n.code,{children:"Sync"})," in trait bounds can be removed."]}),"\n",(0,r.jsxs)(n.h3,{id:"5-boxfuture",children:["5. ",(0,r.jsx)(n.code,{children:"BoxFuture"})]}),"\n",(0,r.jsxs)(n.p,{children:["If you've used ",(0,r.jsx)(n.code,{children:"BoxFuture"})," you can use the following shim:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(not(feature = "sync"))]\ntype BoxFuture<\'a, T> = Pin<Box<dyn Future<Output = T> + Send + \'a>>;\n\n#[cfg(feature = "sync")]\ntype BoxFuture<\'a, T> = T;\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"6-boxpinasync-move---",children:["6. ",(0,r.jsx)(n.code,{children:"Box::pin(async move { .. })"})]}),"\n",(0,r.jsxs)(n.p,{children:["Function signature: ",(0,r.jsx)(n.code,{children:"FnOnce() -> Pin<Box<dyn Future<Output = Result<T, E>> + Send + 'c>>"})," can simply be ",(0,r.jsx)(n.code,{children:"FnOnce() -> Result<T, E>"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="async"',children:"async fn transaction<F, T, E>(&self, _callback: F) -> Result<T, TransactionError<E>>\nwhere\n    F: for<'c> FnOnce(\n            &'c DatabaseTransaction,\n        ) -> Pin<Box<dyn Future<Output = Result<T, E>> + Send + 'c>>\n        + Send,\n    T: Send,\n    E: std::fmt::Display + std::fmt::Debug + Send,\n{}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="sync"',children:"fn transaction<F, T, E>(&self, _callback: F) -> Result<T, TransactionError<E>>\nwhere\n    F: for<'c> FnOnce(&'c DatabaseTransaction) -> Result<T, E>,\n    E: std::fmt::Display + std::fmt::Debug,\n{}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Usage: Async futures can be simply converted to ",(0,r.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="async"',children:'db\n    .transaction::<_, _, DbErr>(|txn| {\n        Box::pin(async move {\n            let bakeries = Bakery::find()\n                .filter(bakery::Column::Name.contains("Bakery"))\n                .all(txn)\n                .await?;\n\n            Ok(())\n        })\n    })\n    .await?\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="sync"',children:'db\n    .transaction::<_, _, DbErr>(|txn| {\n        let bakeries = Bakery::find()\n            .filter(bakery::Column::Name.contains("Bakery"))\n            .all(txn)?;\n\n        Ok(())\n    })?\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"7-mutex",children:["7. ",(0,r.jsx)(n.code,{children:"Mutex"})]}),"\n",(0,r.jsxs)(n.p,{children:["The semantic difference in ",(0,r.jsx)(n.code,{children:"lock()"})," between a synchronous mutex (",(0,r.jsx)(n.code,{children:"std::sync::Mutex"}),") and an asynchronous mutex (",(0,r.jsx)(n.code,{children:"tokio::sync::Mutex"})," or ",(0,r.jsx)(n.code,{children:"async_std::sync::Mutex"}),") is crucial."]}),"\n",(0,r.jsx)(n.h4,{id:"stdsyncmutexlock",children:(0,r.jsx)(n.code,{children:"std::sync::Mutex::lock()"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn lock(&self) -> LockResult<MutexGuard<T>>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Fallible: Returns a Result because the lock can be poisoned."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Poisoning happens if a thread panics while holding the lock."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"tokiosyncmutexlockawait",children:(0,r.jsx)(n.code,{children:"tokio::sync::Mutex::lock().await"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"async fn lock(&self) -> MutexGuard<'_, T>\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Infallible: always succeeds and returns a guard"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"In async world mutexes don't get poisoned. A panic inside a task would abort the task, but would not affect other tasks. This is actually a problem in async Rust as a task can fail silently"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In practice, we did:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(not(feature = "sync"))]\nlet conn = *self.conn.lock().await;\n\n#[cfg(feature = "sync")]\nlet conn = *self.conn.lock().map_err(|_| DbErr::MutexPoisonError)?;\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"8-stream",children:["8. ",(0,r.jsx)(n.code,{children:"Stream"})]}),"\n",(0,r.jsxs)(n.p,{children:["This is the biggest discrepency between sync and async Rust. Simply put, ",(0,r.jsx)(n.code,{children:"Stream"})," is the async version of ",(0,r.jsx)(n.code,{children:"Iterator"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"Iterator"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"Stream"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Definition"}),(0,r.jsx)(n.td,{children:"Synchronous iterator"}),(0,r.jsx)(n.td,{children:"Asynchronous iterator"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Trait method"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fn next(&mut self) -> Option<Item>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Item>>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Consumption"}),(0,r.jsxs)(n.td,{children:["Call ",(0,r.jsx)(n.code,{children:".next()"})," repeatedly"]}),(0,r.jsxs)(n.td,{children:["Call ",(0,r.jsx)(n.code,{children:".next().await"})," repeatedly (via ",(0,r.jsx)(n.code,{children:"StreamExt"}),")"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Blocking vs yielding"}),(0,r.jsx)(n.td,{children:"Produces items immediately, blocks until ready"}),(0,r.jsx)(n.td,{children:"Produces items asynchronously, yields if not ready"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Use cases"}),(0,r.jsx)(n.td,{children:"Iterating over collections"}),(0,r.jsx)(n.td,{children:"Reading database rows"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Usage"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"for x in iter { ... }"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"while let Some(x) = stream.next().await { ... }"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Stream"})," occurs in many places throughout the SeaORM API. The ",(0,r.jsx)(n.code,{children:"Stream"})," trait is replaced by the ",(0,r.jsx)(n.code,{children:"Iterator"})," trait."]}),"\n",(0,r.jsx)(n.h4,{id:"boxdyn-stream",children:(0,r.jsx)(n.code,{children:"Box<dyn Stream>"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[cfg(not(feature = \"sync\"))]\ntype PinBoxStream<'a> = Pin<Box<dyn Stream<Item = Result<QueryResult, DbErr>> + 'a + Send>>;\n\n#[cfg(feature = \"sync\")]\ntype PinBoxStream<'a> = Box<dyn Iterator<Item = Result<QueryResult, DbErr>> + 'a>;\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"impl-stream-bounds",children:[(0,r.jsx)(n.code,{children:"impl Stream"})," bounds"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="async"',children:"async fn stream<'a: 'b, 'b, C>(self, db: &'a C)\n-> Result<impl Stream<Item = Result<E::Model, DbErr>> + 'b + Send, DbErr>\nwhere\n    C: ConnectionTrait + StreamTrait + Send,\n{}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="sync"',children:"fn stream<'a: 'b, 'b, C>(self, db: &'a C)\n-> Result<impl Iterator<Item = Result<E::Model, DbErr>> + 'b, DbErr>\nwhere\n    C: ConnectionTrait + StreamTrait,\n{}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"impl-stream-for",children:(0,r.jsx)(n.code,{children:"impl Stream for"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(not(feature = "sync"))]\nimpl Stream for TransactionStream<\'_> {\n    type Item = Result<QueryResult, DbErr>;\n\n    fn poll_next(\n        self: Pin<&mut Self>,\n        cx: &mut std::task::Context<\'_>,\n    ) -> Poll<Option<Self::Item>> {\n        Pin::new(self.stream).poll_next(cx)\n    }\n}\n\n#[cfg(feature = "sync")]\nimpl Iterator for TransactionStream<\'_> {\n    type Item = Result<QueryResult, DbErr>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.stream.next()\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"trystreamext",children:(0,r.jsx)(n.code,{children:"TryStreamExt"})}),"\n",(0,r.jsxs)(n.p,{children:["There is no equivalent to ",(0,r.jsx)(n.code,{children:"TryStreamExt"})," in Rust's standard library, luckily it's very easy to make a shim:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"while let Some(item) = stream.try_next().await? {\n    let item: fruit::ActiveModel = item.into();\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub trait TryIterator<T, E> {\n    fn try_next(&mut self) -> Result<Option<T>, E>;\n}\n\nimpl<I, T, E> TryIterator<T, E> for I\nwhere\n    I: Iterator<Item = Result<T, E>>,\n{\n    fn try_next(&mut self) -> Result<Option<T>, E> {\n        self.next().transpose() // Option<Result<T>> becomes Result<Option<T>>\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"9-file--network-io",children:"9. File / Network I/O"}),"\n",(0,r.jsxs)(n.p,{children:["This is very application specific. In SeaORM's case, the external I/O is handled by ",(0,r.jsx)(n.code,{children:"rusqlite"})," and ",(0,r.jsx)(n.code,{children:"sqlx"})," respectively. Their APIs differ significantly, that's why we have written ",(0,r.jsx)(n.code,{children:"sea-query-sqlx"})," and ",(0,r.jsx)(n.code,{children:"sea-query-rusqlite"})," to align them."]}),"\n",(0,r.jsxs)(n.p,{children:["For HTTP requests, you can simply use the sync and async versions of ",(0,r.jsx)(n.code,{children:"Client"})," in different contexts."]}),"\n",(0,r.jsx)(n.p,{children:"For file I/O, the API difference between sync and async Rust is very small."}),"\n",(0,r.jsx)(n.h2,{id:"conclusion-sqlite--seaorm-sync--",children:"Conclusion: SQLite + SeaORM Sync = \u26a1"}),"\n",(0,r.jsxs)(n.p,{children:["You can now use ",(0,r.jsx)(n.code,{children:"sea-orm-sync"})," in CLI programs, and only bringing in small number of additional dependencies compared to having to bring in the async ecosystem."]}),"\n",(0,r.jsxs)(n.p,{children:["In fact, the compilation time speaks for itself. The async version of ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/examples/quickstart/src/main.rs",children:"quickstart"})," took 30 seconds to compile, while the ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/blob/master/sea-orm-sync/examples/quickstart/src/main.rs",children:"sync version"})," only took 15 seconds!"]}),"\n",(0,r.jsxs)(n.p,{children:["Right now only ",(0,r.jsx)(n.code,{children:"rusqlite"})," is supported, but SeaORM's entire API surface is available. It's a breeze to add SQLite query capabilities to CLI programs where async would be overkill."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let db = &sea_orm::Database::connect("sqlite::memory:")?;\n\n// Setup the database: create tables\ndb.get_schema_registry("sea_orm_quickstart::*").sync(db)?;\n\ninfo!("Create user Bob with a profile:");\nlet bob = user::ActiveModel::builder()\n    .set_name("Bob")\n    .set_email("bob@sea-ql.org")\n    .set_profile(profile::ActiveModel::builder().set_picture("Tennis"))\n    .insert(db)?;\n\ninfo!("Query user with profile in a single query:");\nlet bob = user::Entity::load()\n    .filter_by_id(bob.id)\n    .with(profile::Entity)\n    .one(db)?\n    .expect("Not found");\nassert_eq!(bob.name, "Bob");\nassert_eq!(bob.profile.as_ref().unwrap().picture, "Tennis");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"seaorm-20-rc",children:"SeaORM 2.0 RC"}),"\n",(0,r.jsx)(n.p,{children:"SeaORM 2.0 is shaping up to be our most significant release yet - with a few breaking changes, plenty of enhancements, and a clear focus on developer experience."}),"\n",(0,r.jsxs)(n.p,{children:["SeaORM 2.0 has reached its release candidate phase. We'd love for you to try it out and help shape the final release by ",(0,r.jsx)(n.a,{href:"https://github.com/SeaQL/sea-orm/discussions/2548",children:"sharing your feedback"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"-rustacean-sticker-pack",children:"\ud83e\udd80 Rustacean Sticker Pack"}),"\n",(0,r.jsx)(n.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish."}),"\n",(0,r.jsx)(n.p,{children:"Sticker Pack Contents:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography"}),"\n",(0,r.jsx)(n.li,{children:"Mascots: Ferris the Crab x 3, Terres the Hermit Crab"}),"\n",(0,r.jsx)(n.li,{children:"The Rustacean wordmark"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,r.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,r.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},9757:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025-12-12-sea-orm-2.0","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-12-12-sea-orm-2.0.md","source":"@site/blog/2025-12-12-sea-orm-2.0.md","title":"How we made SeaORM synchronous","description":"SeaORM began as Rust\'s first async\u2011first ORM. Now we\'ve come full circle with a synchronous crate: perfect for building lightweight CLI programs with SQLite.","date":"2025-12-12T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":6.97,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2025-12-12-sea-orm-2.0","title":"How we made SeaORM synchronous","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"A walk-through of SeaORM 2.0","permalink":"/blog/2025-12-05-sea-orm-2.0"}}')}}]);