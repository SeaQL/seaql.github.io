"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[4640],{2063:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=n(7935),s=n(4848),a=n(8453);const r={slug:"2026-02-28-sea-orm-sync",title:"Tutorial: let's make a program resumable with SQLite",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png",tags:["news"]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The Problem",id:"the-problem",level:2},{value:"The Workload: Pi Spigot",id:"the-workload-pi-spigot",level:2},{value:"The State Machine Pattern",id:"the-state-machine-pattern",level:2},{value:"Integrating with SeaORM + rusqlite",id:"integrating-with-seaorm--rusqlite",level:2},{value:"Step 1: Define the State Entity",id:"step-1-define-the-state-entity",level:3},{value:"Step 2: Serialize and Deserialize",id:"step-2-serialize-and-deserialize",level:3},{value:"Step 3: Checkpoint in a Transaction",id:"step-3-checkpoint-in-a-transaction",level:3},{value:"Step 4: Resume on Startup",id:"step-4-resume-on-startup",level:3},{value:"Putting It Together",id:"putting-it-together",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"\ud83e\udd80 Rustacean Sticker Pack",id:"-rustacean-sticker-pack",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{alt:"SeaORM 2.0 Banner",src:"/blog/img/SeaORM%202.0%20Banner.png"}),"\n",(0,s.jsx)(t.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,s.jsx)(t.p,{children:"You have a program that runs for a long time. A batch job, a simulation, a data pipeline. It runs for hours, and then it crashes. You have to start it again and it begins from zero."}),"\n",(0,s.jsx)(t.p,{children:"The fix is checkpointing: periodically saving the program's state so it can resume from where it left off. A SQLite database is a natural choice for this. It's a single file, requires no server, and supports transactions (so your checkpoint is atomic)."}),"\n",(0,s.jsx)(t.p,{children:"In this tutorial we'll wire up checkpointing with SeaORM's sync API and rusqlite. The state is defined as a SeaORM entity, persisted transactionally, and reconstructed on restart. No async runtime, no handwritten SQL."}),"\n",(0,s.jsx)(t.h2,{id:"the-workload-pi-spigot",children:"The Workload: Pi Spigot"}),"\n",(0,s.jsx)(t.p,{children:"We need a computation that takes a long time and produces results incrementally. Here we use the Rabinowitz\u2013Wagon pi spigot algorithm as demonstration."}),"\n",(0,s.jsx)(t.p,{children:'The algorithm computes decimal digits of pi one at a time, using only integer arithmetic. Each iteration mutates the internal state, and may or may not produce a digit. So "I completed iteration N, therefore I have N digits" is not true.'}),"\n",(0,s.jsx)(t.p,{children:"This makes it a good test case for checkpointing. You can't just save the digit count and recompute from there: you need the full internal state."}),"\n",(0,s.jsx)(t.h2,{id:"the-state-machine-pattern",children:"The State Machine Pattern"}),"\n",(0,s.jsx)(t.p,{children:"Any computation that can be modeled as a state machine can be made resumable. The recipe:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"new()        \u2192 initialize fresh state\nstep()       \u2192 advance one iteration, mutating &mut self\nfinalize()   \u2192 flush any buffered output\nto_state()   \u2192 serialize self into a database row\nfrom_state() \u2192 deserialize a database row back into self\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"step()"})," is the core loop body. Call it repeatedly to drive the computation forward. ",(0,s.jsx)(t.code,{children:"to_state()"})," and ",(0,s.jsx)(t.code,{children:"from_state()"})," handle persistence: save the internal state and resume from it later."]}),"\n",(0,s.jsx)(t.p,{children:"The checkpoint frequency is a param you control. Checkpoint every step and you lose almost no work on crash, but pay the IO cost every iteration. Checkpoint every 1000 steps and crashes cost you up to 1000 steps of rework, but the overhead is negligible."}),"\n",(0,s.jsx)(t.h2,{id:"integrating-with-seaorm--rusqlite",children:"Integrating with SeaORM + rusqlite"}),"\n",(0,s.jsxs)(t.p,{children:["Now let's wire this pattern into a real database. SeaORM 2.0 ships a sync API (crate ",(0,s.jsx)(t.a,{href:"https://docs.rs/sea-orm-sync",children:(0,s.jsx)(t.code,{children:"sea-orm-sync"})}),") backed by ",(0,s.jsx)(t.a,{href:"https://docs.rs/rusqlite",children:"rusqlite"}),". The API surface is compatible with ",(0,s.jsx)(t.code,{children:"sea-orm"}),", just without any ",(0,s.jsx)(t.code,{children:"async"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"step-1-define-the-state-entity",children:"Step 1: Define the State Entity"}),"\n",(0,s.jsx)(t.p,{children:"Map every mutable field of the computation to a column:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",metastring:'title="state.rs"',children:'use sea_orm::entity::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[sea_orm::model]\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = "state")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub digits: u32,\n    pub boxes: JsonVec,\n    pub i: u32,\n    pub nines: u32,\n    pub predigit: u8,\n    pub have_predigit: bool,\n    pub count: u32,\n    pub result: String,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, FromJsonQueryResult)]\npub struct JsonVec(pub Vec<u32>);\n\nimpl ActiveModelBehavior for ActiveModel {}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"digits"}),' is the primary key: it identifies which computation this checkpoint belongs to (i.e. "compute 10000 digits of pi"). ',(0,s.jsx)(t.code,{children:"boxes"})," holds the algorithm's working array as a JSON column via ",(0,s.jsx)(t.code,{children:"FromJsonQueryResult"}),", since SQLite has no native array type. The rest are scalars: iteration counter, buffered-nine count, the held predigit, and the digits emitted so far."]}),"\n",(0,s.jsx)(t.h3,{id:"step-2-serialize-and-deserialize",children:"Step 2: Serialize and Deserialize"}),"\n",(0,s.jsxs)(t.p,{children:["The computation struct itself has no dependency on SeaORM: it uses plain ",(0,s.jsx)(t.code,{children:"Vec<u32>"}),", ",(0,s.jsx)(t.code,{children:"u32"}),", ",(0,s.jsx)(t.code,{children:"String"}),". Two glue functions convert between this struct and the entity model. This keeps the core algorithm pure and testable; the entire persistence layer can be gated behind a feature flag so that the library can work without ",(0,s.jsx)(t.code,{children:"sea-orm"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"The conversion functions:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"fn from_state(s: state::Model) -> Self {\n    Self {\n        digits: s.digits,\n        boxes: s.boxes.0,\n        nines: s.nines,\n        predigit: s.predigit,\n        have_predigit: s.have_predigit,\n        count: s.count,\n        result: s.result,\n        start_i: s.i,\n    }\n}\n\nfn to_state(&self, i: u32) -> state::Model {\n    state::Model {\n        digits: self.digits,\n        boxes: state::JsonVec(self.boxes.clone()),\n        i,\n        nines: self.nines,\n        predigit: self.predigit,\n        have_predigit: self.have_predigit,\n        count: self.count,\n        result: self.result.clone(),\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"step-3-checkpoint-in-a-transaction",children:"Step 3: Checkpoint in a Transaction"}),"\n",(0,s.jsx)(t.p,{children:"Inside the main loop, periodically save state. The delete-then-insert is wrapped in a transaction so the checkpoint is atomic: either the full state is written or nothing changes."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"fn persist_state(&self, db: &DatabaseConnection, i: u32) -> Result<(), DbErr> {\n    let txn = db.begin()?;\n    state::Entity::delete_by_id(self.digits).exec(&txn)?;\n    self.to_state(i + 1).into_active_model().insert(&txn)?;\n    txn.commit()?;\n    Ok(())\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note the ",(0,s.jsx)(t.code,{children:"i + 1"}),": we save the ",(0,s.jsx)(t.em,{children:"next"})," iteration index, not the current one. The state has already been mutated by ",(0,s.jsx)(t.code,{children:"step()"}),", so when the program resumes it should continue from the next iteration, not re-execute the one it just completed."]}),"\n",(0,s.jsxs)(t.p,{children:["If the process dies at any point before ",(0,s.jsx)(t.code,{children:"commit()"}),", SQLite rolls back the transaction automatically. The previous checkpoint remains intact. This is more resilient than writing to a plain JSON file, where a crash mid-write can leave you with a truncated or corrupted file and no valid checkpoint at all."]}),"\n",(0,s.jsx)(t.h3,{id:"step-4-resume-on-startup",children:"Step 4: Resume on Startup"}),"\n",(0,s.jsxs)(t.p,{children:["On startup, check for an existing checkpoint. ",(0,s.jsx)(t.code,{children:"get_schema_builder().sync()"})," creates the table from the entity definition if it doesn't already exist, so there is no need to write ",(0,s.jsx)(t.code,{children:"CREATE TABLE"})," SQL:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub fn resume(db: &DatabaseConnection, digits: u32) -> Result<Self, DbErr> {\n    db.get_schema_builder()\n        .register(state::Entity)\n        .sync(db)?;\n\n    match state::Entity::find_by_id(digits).one(db)? {\n        Some(s) => Ok(Self::from_state(s)),\n        None => Ok(Self::new(digits)),\n    }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"First run: creates the table, starts fresh. Subsequent runs: finds the checkpoint row, reconstructs the computation mid-flight. The calling code doesn't need to distinguish between the two cases."}),"\n",(0,s.jsx)(t.h3,{id:"putting-it-together",children:"Putting It Together"}),"\n",(0,s.jsx)(t.p,{children:"The main loop looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"// initialize states in self\n\nfor i in self.start_i..=self.digits {\n    self.step();\n\n    if self.count > 0 && self.count % checkpoint_interval == 0 {\n        self.persist_state(db, i)?;\n    }\n}\n\nself.finalize();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The full example including tests is in the ",(0,s.jsx)(t.a,{href:"https://github.com/SeaQL/sea-orm/tree/master/sea-orm-sync/examples/pi_spigot",children:"SeaORM repository"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"SeaORM Sync with rusqlite is a lightweight combination: a single-file database, no server, no async runtime. You define your state as an entity, and SeaORM handles the SQL. No hand-written queries, no migration files. You stay focused on the core program logic."}),"\n",(0,s.jsx)(t.p,{children:"The patterns here are reusable. State machine + serialization round-trip + transactional checkpoint: apply them to batch jobs, simulations, data pipelines, or any long-running process that shouldn't have to start over after a crash."}),"\n",(0,s.jsx)(t.h2,{id:"-rustacean-sticker-pack",children:"\ud83e\udd80 Rustacean Sticker Pack"}),"\n",(0,s.jsx)(t.p,{children:"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish."}),"\n",(0,s.jsx)(t.p,{children:"Sticker Pack Contents:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography"}),"\n",(0,s.jsx)(t.li,{children:"Mascots: Ferris the Crab x 3, Terres the Hermit Crab"}),"\n",(0,s.jsx)(t.li,{children:"The Rustacean wordmark"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://www.sea-ql.org/sticker-pack/",children:"Support SeaQL and get a Sticker Pack!"})}),"\n",(0,s.jsx)("a",{href:"https://www.sea-ql.org/sticker-pack/",children:(0,s.jsx)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},7935:e=>{e.exports=JSON.parse('{"permalink":"/blog/2026-02-28-sea-orm-sync","editUrl":"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2026-02-28-sea-orm-sync.md","source":"@site/blog/2026-02-28-sea-orm-sync.md","title":"Tutorial: let\'s make a program resumable with SQLite","description":"The Problem","date":"2026-02-28T00:00:00.000Z","tags":[{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":5.65,"hasTruncateMarker":false,"authors":[{"name":"SeaQL Team","title":"Chris Tsang","url":"https://github.com/SeaQL","imageURL":"https://www.sea-ql.org/blog/img/SeaQL.png","key":null,"page":null}],"frontMatter":{"slug":"2026-02-28-sea-orm-sync","title":"Tutorial: let\'s make a program resumable with SQLite","author":"SeaQL Team","author_title":"Chris Tsang","author_url":"https://github.com/SeaQL","author_image_url":"https://www.sea-ql.org/blog/img/SeaQL.png","image":"https://www.sea-ql.org/blog/img/SeaORM%202.0%20Banner.png","tags":["news"]},"unlisted":false,"nextItem":{"title":"SeaORM 2.0 with SQL Server Support","permalink":"/blog/2026-02-25-sea-orm-x"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);