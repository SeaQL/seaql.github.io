"use strict";(self.webpackChunksea_ql_blog=self.webpackChunksea_ql_blog||[]).push([[7151],{9680:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(6687);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(1308),r=(n(6687),n(9680));const o={slug:"2025-01-08-sea-orm-inheritance",title:"Tutorial: Modeling Inheritance in SeaORM",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%201.0%20Banner.png",tags:["news"]},i=void 0,l={permalink:"/blog/2025-01-08-sea-orm-inheritance",editUrl:"https://github.com/SeaQL/seaql.github.io/edit/master/Blog/blog/2025-01-08-sea-orm-inheritance.md",source:"@site/blog/2025-01-08-sea-orm-inheritance.md",title:"Tutorial: Modeling Inheritance in SeaORM",description:"Introduction",date:"2025-01-08T00:00:00.000Z",formattedDate:"January 8, 2025",tags:[{label:"news",permalink:"/blog/tags/news"}],readingTime:5.89,hasTruncateMarker:!1,authors:[{name:"SeaQL Team",title:"Chris Tsang",url:"https://github.com/SeaQL",imageURL:"https://www.sea-ql.org/blog/img/SeaQL.png"}],frontMatter:{slug:"2025-01-08-sea-orm-inheritance",title:"Tutorial: Modeling Inheritance in SeaORM",author:"SeaQL Team",author_title:"Chris Tsang",author_url:"https://github.com/SeaQL",author_image_url:"https://www.sea-ql.org/blog/img/SeaQL.png",image:"https://www.sea-ql.org/blog/img/SeaORM%201.0%20Banner.png",tags:["news"]},nextItem:{title:"What's new in SeaQuery 0.32.x",permalink:"/blog/2024-12-03-whats-new-in-seaquery-0.32.x"}},s={authorsImageUrls:[void 0]},u=[{value:"Introduction",id:"introduction",level:2},{value:"Schema",id:"schema",level:2},{value:"<code>BaseProduct</code>",id:"baseproduct",level:4},{value:"<code>ComplexProduct</code>",id:"complexproduct",level:4},{value:"<code>ProductType</code>",id:"producttype",level:4},{value:"1. Define result data structure",id:"1-define-result-data-structure",level:2},{value:"2. Define helper aliases",id:"2-define-helper-aliases",level:2},{value:"3. Custom selects",id:"3-custom-selects",level:2},{value:"4. Filter Conditions",id:"4-filter-conditions",level:2},{value:"5. Associated models",id:"5-associated-models",level:2},{value:"<code>ProductHistory</code>",id:"producthistory",level:4},{value:"Conclusion",id:"conclusion",level:2},{value:"Rustacean Sticker Pack \ud83e\udd80",id:"rustacean-sticker-pack-",level:2}],p={toc:u};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This tutorial walks you through the design and implementation of a REST API endpoint that involves some complex relational queries."),(0,r.kt)("p",null,"The API looks like this:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"POST")," ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/v1/complex-products")),(0,r.kt)("p",null,"Parameters (JSON body):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"id")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int[]")),(0,r.kt)("td",{parentName:"tr",align:null},"Get products with these ids")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"name")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},"Search products with name matching this")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"type")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"enum")," of ",(0,r.kt)("inlineCode",{parentName:"td"},"ProductType")),(0,r.kt)("td",{parentName:"tr",align:null},"Limit products to this type")))),(0,r.kt)("p",null,"Return example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": 1,\n    "name": "Mountain Bike V2",\n    "type": "Bike",\n    "price": "2500.0",\n    "lot_size": "1.0",\n    "date_added": "2020-01-01T00:00:00",\n    "last_modified": "2025-01-02T12:18:54",\n    "history": [\n        {\n            "from": "2020-01-01T00:00:00",\n            "until": "2022-01-01T00:00:00",\n            "name": "Mountain Bike V1"\n        }\n    ]\n}\n')),(0,r.kt)("h2",{id:"schema"},"Schema"),(0,r.kt)("p",null,"Imagine we run a store with many types of products. Each product type has its own attributes and we want to factor out the common product attributes to a base class."),(0,r.kt)("p",null,"In OOP terms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct BaseProduct {\n    r#type: ProductType,\n    ..\n}\n\n// made up syntax, but it means inheritance\nstruct ComplexProduct: BaseProduct { .. }\n\nenum ProductType { .. }\n")),(0,r.kt)("p",null,"In SQL terms, we have 3 entities and 2 relations among them:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BaseProduct")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"ComplexProduct")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BaseProduct")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"ProductType"))),(0,r.kt)("p",null,"Below are the SeaORM Entities:"),(0,r.kt)("h4",{id:"baseproduct"},(0,r.kt)("inlineCode",{parentName:"h4"},"BaseProduct")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "base_product")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i64,\n    #[sea_orm(unique)]\n    pub name: String,\n    pub type_id: i32, // linking to product_type\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_one = "super::complex_product::Entity")]\n    ComplexProduct,\n    #[sea_orm(has_many = "super::product_history::Entity")]\n    ProductHistory,\n    #[sea_orm(\n        belongs_to = "super::product_type::Entity",\n        from = "Column::TypeId",\n        to = "super::product_type::Column::Id",\n        on_update = "NoAction",\n        on_delete = "NoAction"\n    )]\n    ProductType,\n}\n')),(0,r.kt)("h4",{id:"complexproduct"},(0,r.kt)("inlineCode",{parentName:"h4"},"ComplexProduct")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "complex_product")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub product_id: i64, // linking to base_product\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub price: Option<Decimal>,\n    #[sea_orm(column_type = "Decimal(Some((30, 15)))", nullable)]\n    pub lot_size: Option<Decimal>,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n')),(0,r.kt)("h4",{id:"producttype"},(0,r.kt)("inlineCode",{parentName:"h4"},"ProductType")),(0,r.kt)("p",null,"Basically an 'enum table'."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = "product_type")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(unique)]\n    pub name: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = "super::base_product::Entity")]\n    BaseProduct,\n}\n')),(0,r.kt)("h2",{id:"1-define-result-data-structure"},"1. Define result data structure"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone, Debug, PartialEq, Eq, FromQueryResult, Serialize)]\npub struct ComplexProduct {\n    pub id: i64,\n    pub name: String,\n    pub r#type: String,\n    pub price: Decimal,\n    pub lot_size: Decimal,\n    pub date_added: DateTime,\n    pub last_modified: DateTime,\n    #[sea_orm(skip)]\n    pub history: Vec<product_history::Model>,\n}\n")),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"Serialize"),", you can transform the select result into JSON directly."),(0,r.kt)("h2",{id:"2-define-helper-aliases"},"2. Define helper aliases"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(DeriveIden, Clone, Copy)]\npub struct Id;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Name;\n\n#[derive(DeriveIden, Clone, Copy)]\npub struct Base;\n\nuse complex_product::Entity as Prod;\npub type ProdCol = <Prod as EntityTrait>::Column;\ntype ProdRel = <Prod as EntityTrait>::Relation;\n")),(0,r.kt)("p",null,"This would make our code much more concise and readable."),(0,r.kt)("p",null,"Avoid using ",(0,r.kt)("inlineCode",{parentName:"p"},"Alias::new")," because it's error-prone and slightly more expensive."),(0,r.kt)("h2",{id:"3-custom-selects"},"3. Custom selects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn query() -> Select<complex_product::Entity> {\n    complex_product::Entity::find()\n        .select_only()\n        .tbl_col_as((Base, Id), "id")\n        .tbl_col_as((Base, Name), "name")\n        .column_as(product_type::Column::Name, "type")\n        .column_as(ProdCol::Price, "price")\n        .column_as(ProdCol::LotSize, "lot_size")\n        .column_as(ProdCol::DateAdded, "date_added")\n        .column_as(ProdCol::LastModified, "last_modified")\n        .join_as(JoinType::InnerJoin, ProdRel::BaseProduct.def(), Base)\n        .join(JoinType::InnerJoin, base_product::Relation::ProductType.def().from_alias(Base))\n        .order_by_asc(Expr::col((Base, Id)))\n}\n')),(0,r.kt)("p",null,"Our query starts from ",(0,r.kt)("inlineCode",{parentName:"p"},"ComplexProduct"),". We join back to ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseProduct"),", alias it as ",(0,r.kt)("inlineCode",{parentName:"p"},"Base"),". We then join to ",(0,r.kt)("inlineCode",{parentName:"p"},"ProductType")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"Base"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ComplexProduct -> BaseProduct as Base -> ProductType\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.column_as"},(0,r.kt)("inlineCode",{parentName:"a"},"column_as"))," automatically prefix the column with the table name.\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/entity/struct.RelationDef.html#method.from_alias"},(0,r.kt)("inlineCode",{parentName:"a"},"from_alias"))," is doing the magic here, allowing us to reuse the existing Relation by overwriting the left hand side of the on condition."),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/trait.QuerySelect.html#method.join"},(0,r.kt)("inlineCode",{parentName:"a"},"join"))," method to construct complex joins in select queries. It takes any ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/entity/struct.RelationDef.html"},(0,r.kt)("inlineCode",{parentName:"a"},"RelationDef")),", and you can further customize the join conditions. You can find more examples ",(0,r.kt)("a",{parentName:"p",href:"https://www.sea-ql.org/SeaORM/docs/advanced-query/advanced-joins/#custom-join-conditions"},"here"),"."),(0,r.kt)("h2",{id:"4-filter-conditions"},"4. Filter Conditions"),(0,r.kt)("p",null,"Let's define struct for query parameters. Again, using serde here so it can be deserialized from JSON."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Default, Deserialize)]\npub struct Query {\n    #[serde(default)]\n    pub id: Vec<i64>, // if unspecified, will be an empty vec\n    pub name: Option<String>,\n    pub r#type: Option<String>,\n}\n")),(0,r.kt)("p",null,"Then, we transform the parameters into SQL where conditions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn condition(query: Query) -> Condition {\n    Condition::all()\n        .add_option(if !query.id.is_empty() {\n            Some(Expr::col((Base, Id)).is_in(query.id))\n        } else { None })\n        .add_option(if let Some(name) = &query.name {\n            Some(Expr::col((Base, Name)).like(name))\n        } else { None })\n        .add_option(if let Some(r#type) = &query.r#type {\n            Some(product_type::Column::Name.eq(r#type))\n        } else { None })\n}\n")),(0,r.kt)("p",null,"Bonus tip: if you're only using Postgres you can replace ",(0,r.kt)("inlineCode",{parentName:"p"},"is_in")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"any"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use sea_orm::sea_query::extension::postgres::PgFunc;\n\nExpr::col((Base, Id)).eq(PgFunc::any(query.id)) // WHERE base.id = ANY($N)\n")),(0,r.kt)("p",null,"Combining the above functions, here is how we implement the API endpoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub async fn query_products(db: DbConn, q: Query)\n    -> Result<Vec<ComplexProduct>, DbErr>\n{\n    query()\n        .filter(condition(q))\n        .into_model::<ComplexProduct>()\n        .all(&db)\n        .await\n}\n")),(0,r.kt)("h2",{id:"5-associated-models"},"5. Associated models"),(0,r.kt)("p",null,"Suppose we have a data structure associated with each ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseProduct")," recording its history."),(0,r.kt)("h4",{id:"producthistory"},(0,r.kt)("inlineCode",{parentName:"h4"},"ProductHistory")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize)]\n#[sea_orm(table_name = "product_history")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[serde(skip)]\n    pub id: i32,\n    #[serde(skip)]\n    pub product_id: i64,\n    pub from: DateTime,\n    pub until: DateTime,\n    pub name: Option<String>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = "super::base_product::Entity",\n        from = "Column::ProductId",\n        to = "super::base_product::Column::Id",\n        on_update = "NoAction",\n        on_delete = "Cascade"\n    )]\n    BaseProduct,\n}\n')),(0,r.kt)("p",null,"Let's make a helper function to query the histories associated to a set of products:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn history_of(ids: Vec<i64>) -> Select<product_history::Entity> {\n    product_history::Entity::find()\n        .filter(Expr::col(product_history::Column::ProductId).is_in(ids))\n        .order_by_asc(product_history::Column::Id)\n}\n\nlet histories = history_of(products.iter().map(|s| s.id).collect::<Vec<_>>())\n    .all(&db)\n    .await?;\n")),(0,r.kt)("p",null,"The final step is to associate ",(0,r.kt)("inlineCode",{parentName:"p"},"product_history::Model")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"ComplexProduct"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// parent should be unique and already ordered by id.\nfn associate(\n    mut parent: Vec<ComplexProduct>,\n    children: Vec<product_history::Model>,\n) -> Vec<ComplexProduct> {\n    let len = parent.len();\n    parent.dedup_by_key(|s| s.id);\n    if len != parent.len() {\n        warn!("parent is not unique.");\n    }\n\n    let parent_id_map: HashMap<i64, usize> = parent\n        .iter()\n        .enumerate()\n        .map(|(i, s)| (s.id, i))\n        .collect();\n\n    // put children into associated parent\n    for item in children {\n        if let Some(index) = parent_id_map.get(&item.product_id) {\n            parent[*index].history.push(item);\n        }\n    }\n\n    parent\n}\n\nlet products = associate(products, histories);\n')),(0,r.kt)("p",null,'This is sometimes called "data loader" pattern, and can be generalized with generics to work with any models.'),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"SeaORM's type system encourages you to write modular and reusable code, embracing the \"Don't repeat yourself\" principle."),(0,r.kt)("p",null,"You define the Entities and Relations once."),(0,r.kt)("p",null,"You define the aliases and query helpers once."),(0,r.kt)("p",null,"You can pass the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/struct.Select.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Select<T>"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/sea-orm/latest/sea_orm/query/struct.Condition.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Condition"))," around."),(0,r.kt)("p",null,"You then assemble these pieces together to implement any complex API!"),(0,r.kt)("h2",{id:"rustacean-sticker-pack-"},"Rustacean Sticker Pack \ud83e\udd80"),(0,r.kt)("p",null,"The Rustacean Sticker Pack is the perfect way to express your passion for Rust.\nOur stickers are made with a premium water-resistant vinyl with a unique matte finish.\nStick them on your laptop, notebook, or any gadget to show off your love for Rust!"),(0,r.kt)("p",null,"Moreover, all proceeds contributes directly to the ongoing development of SeaQL projects."),(0,r.kt)("p",null,"Sticker Pack Contents:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Logo of SeaQL projects: SeaQL, SeaORM, SeaQuery, Seaography, FireDBG"),(0,r.kt)("li",{parentName:"ul"},"Mascot of SeaQL: Terres the Hermit Crab"),(0,r.kt)("li",{parentName:"ul"},"Mascot of Rust: Ferris the Crab"),(0,r.kt)("li",{parentName:"ul"},"The Rustacean word")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.sea-ql.org/sticker-pack/"},"Support SeaQL and get a Sticker Pack!")),(0,r.kt)("a",{href:"https://www.sea-ql.org/sticker-pack/"},(0,r.kt)("img",{style:{borderRadius:"25px"},alt:"Rustacean Sticker Pack by SeaQL",src:"https://www.sea-ql.org/static/sticker-pack-1s.jpg"})))}d.isMDXComponent=!0}}]);